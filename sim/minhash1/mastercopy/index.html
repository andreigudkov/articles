<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]-->
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 1.5.8">
<meta name="author" content="Andrei Gudkov">
<title>Efficient implementation of MinHash, part 1</title>
<style>
/*! normalize.css v2.1.2 | MIT License | git.io/normalize */article,aside,details,figcaption,figure,footer,header,hgroup,main,nav,section,summary{display:block}audio,canvas,video{display:inline-block}audio:not([controls]){display:none;height:0}[hidden],template{display:none}script{display:none !important}html{font-family:sans-serif;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}a{background:transparent}a:focus{outline:thin dotted}a:active,a:hover{outline:0}h1{font-size:2em;margin:.67em 0}abbr[title]{border-bottom:1px dotted}b,strong{font-weight:bold}dfn{font-style:italic}hr{-moz-box-sizing:content-box;box-sizing:content-box;height:0}mark{background:#ff0;color:#000}code,kbd,pre,samp{font-family:monospace,serif;font-size:1em}pre{white-space:pre-wrap}q{quotes:"\201C" "\201D" "\2018" "\2019"}small{font-size:80%}sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}sup{top:-0.5em}sub{bottom:-0.25em}img{border:0}svg:not(:root){overflow:hidden}figure{margin:0}fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}legend{border:0;padding:0}button,input,select,textarea{font-family:inherit;font-size:100%;margin:0}button,input{line-height:normal}button,select{text-transform:none}button,html input[type="button"],input[type="reset"],input[type="submit"]{-webkit-appearance:button;cursor:pointer}button[disabled],html input[disabled]{cursor:default}input[type="checkbox"],input[type="radio"]{box-sizing:border-box;padding:0}input[type="search"]{-webkit-appearance:textfield;-moz-box-sizing:content-box;-webkit-box-sizing:content-box;box-sizing:content-box}input[type="search"]::-webkit-search-cancel-button,input[type="search"]::-webkit-search-decoration{-webkit-appearance:none}button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}textarea{overflow:auto;vertical-align:top}table{border-collapse:collapse;border-spacing:0}*,*::before,*::after{box-sizing:border-box;margin:0}body{font-family:Helvetica,Arial,sans-serif;font-size:16px;color:#222;line-height:1.5;max-width:55em;margin:0 auto}#content,#footnotes{padding-left:.5em;padding-right:.5em}strong{font-weight:bold}em{font-style:italic}:not(pre)>code{font-family:Courier,monospace;line-height:1.0}a{color:#0061c5;text-decoration:none}a:hover{text-decoration:underline}hr{border-width:0 0 1px 0;border-style:solid;border-color:#678}ul,ol{list-style-position:outside;padding-left:0;margin-left:2em}ul li ul,ul li ol,ol li ul,ol li ol{margin-left:1.414em}ul>li{list-style-type:square;font-size:80%}ul>li>*{font-size:125%}ol>li{font-weight:bold}ol>li>*{font-weight:normal}ol.arabic{list-style-type:decimal}ol.decimal{list-style-type:decimal-leading-zero}ol.loweralpha{list-style-type:lower-alpha}ol.upperalpha{list-style-type:upper-alpha}ol.lowerroman{list-style-type:lower-roman}ol.upperroman{list-style-type:upper-roman}ol.lowergreek{list-style-type:lower-greek}.dlist dt{color:#325d72;font-weight:bold}.dlist dt:not(:first-child){margin-top:1em}.dlist dd{margin-left:2em}td.hdlist1{color:#325d72;padding-right:.5em;vertical-align:top}td.hdlist2{padding-bottom:.5em}h1{font-size:28px;font-weight:normal;letter-spacing:-1px;color:white;background-color:#325d72;text-align:center;margin:0 0 .5em 0;padding:.05em .5em}@media print{h1{color:#325d72;background-color:white;font-weight:bold}}h1::after{content:':';width:0;overflow:hidden;display:inline-block;vertical-align:middle}.author{color:#325d72}.email::before{content:"<";color:#325d72}.email::after{content:">";color:#325d72}.author+br,.email+br{display:none}#author{padding-left:.5em}#toc{margin:1em 0 2em 0;padding-left:.5em}#toctitle{font-size:19px;font-weight:bold;color:#325d72;margin:.5em 0}#toc>ul{line-height:1.4;font-size:15px;margin:0 0 0 .5em}#toc ul li{list-style-type:none}#toc li{margin:0}.big{font-size:120%}.small{font-size:75%}.underline{text-decoration:underline}.overline{text-decoration:overline}.line-through{text-decoration:line-through}.aqua{color:#00bfbf}.aqua-background{background-color:#00fafa;border-radius:2px;padding:0 3px}.black{color:"black"}.black-background{background-color:"black";border-radius:2px;padding:0 3px}.blue{color:#0000bf}.blue-background{background-color:#0000fa;border-radius:2px;padding:0 3px}.fuchsia{color:#bf00bf}.fuchsia-background{background-color:#fa00fa;border-radius:2px;padding:0 3px}.gray{color:#606060}.gray-background{background-color:#7d7d7d;border-radius:2px;padding:0 3px}.green{color:#006000}.green-background{background-color:#007d00;border-radius:2px;padding:0 3px}.lime{color:#00bf00}.lime-background{background-color:#00fa00;border-radius:2px;padding:0 3px}.maroon{color:#600000}.maroon-background{background-color:#7d0000;border-radius:2px;padding:0 3px}.navy{color:#000060}.navy-background{background-color:#00007d;border-radius:2px;padding:0 3px}.olive{color:#606000}.olive-background{background-color:#7d7d00;border-radius:2px;padding:0 3px}.purple{color:#600060}.purple-background{background-color:#7d007d;border-radius:2px;padding:0 3px}.red{color:#bf0000}.red-background{background-color:#fa0000;border-radius:2px;padding:0 3px}.silver{color:#909090}.silver-background{background-color:#bcbcbc;border-radius:2px;padding:0 3px}.teal{color:#006060}.teal-background{background-color:#007d7d;border-radius:2px;padding:0 3px}.white{color:#bfbfbf}.white-background{background-color:#fafafa;border-radius:2px;padding:0 3px}.yellow{color:#bfbf00}.yellow-background{background-color:#fafa00;border-radius:2px;padding:0 3px}table.tableblock{border:1px solid #91a7b3;margin-left:auto;margin-right:auto}table.tableblock>caption.title{text-align:left;margin-bottom:.5em}table.tableblock>colgroup>col{width:inherit !important}table.tableblock>tbody>tr>td{border-style:solid;border-color:#91a7b3;border-width:0 1px;padding:0 5px 2px 5px}table.tableblock>tbody>tr:nth-of-type(2n){background-color:#f3f5f7}p.tableblock{text-align:inherit}table.tableblock>thead>tr>td,table.tableblock>thead>tr>th,table.tableblock>tfoot>tr>td,table.tableblock>tfoot>tr>th{color:#325d72;font-weight:bold;line-height:1.35;padding:2px 5px;border:1px solid #91a7b3}table.tableblock>thead>tr>th,table.tableblock>thead>tr>td{border-bottom-width:2px}table.tableblock>tfoot>tr>th,table.tableblock>tfoot>tr>td{border-top-width:2px}th.halign-left,td.halign-left{text-align:left}th.halign-right,td.halign-right{text-align:right}th.halign-center,td.halign-center{text-align:center}th.valign-top,td.valign-top{vertical-align:top}th.valign-bottom,td.valign-bottom{vertical-align:bottom}th.valign-middle,td.valign-middle{vertical-align:middle}div.listingblock{padding:.5em;border-style:solid;border-color:#678;border-width:0 0 0 2px;background-color:#f3f5f7;overflow:auto}div.listingblock .title{text-align:right}div.listingblock pre{font-family:Menlo,Consolas,Monaco,"Lucida Console",monospace;font-size:87.5%;white-space:pre;background-color:#f3f5f7 !important;margin:0}div.listingblock td.linenos{border-right:1px solid #91a7b3;padding-right:.67em}div.listingblock table.pyhltable div.linenodiv{color:#678;text-align:right}div.listingblock table.pyhltable td.code{padding-left:.67em}div.imageblock>div.content>img{max-width:98%}.text-indent{padding-left:2em}img.inlinemath{image-rendering:optimizequality;margin-top:.5ex}h2,h3,h4{font-weight:normal;color:#325d72;margin:0}h2{font-size:27px;letter-spacing:-1px;border-bottom:1px solid #91a7b3}h3{font-size:24px;letter-spacing:-0.75px}h4{font-size:21px;letter-spacing:-0.5px}.title{color:#325d72;font-weight:bold}#footer{font-size:80%;color:white;background-color:#325d72}@media print{#footer{color:#325d72;background-color:white;font-weight:bold}}#footer-text{text-align:center;padding:.5em}#footer-badges{display:none}span.footnote{vertical-align:super;font-size:80%}#footnotes>hr{display:none}#footnotes::before{display:block;border-bottom:1px solid #678;margin:.5em 0;content:"Notes";font-size:19px;font-weight:bold;color:#325d72}#footnotes .footnote{margin-left:.5em;font-size:15px}hr:not(:first-child){margin-top:1.5em}hr:not(:last-child){margin-bottom:1.5em}.imageblock:not(:last-child),.listingblock:not(:last-child),.tableblock:not(:last-child){margin-bottom:1em}p+*{margin-top:1em}.paragraph+*{margin-top:1em}p+.ulist,p+.olist,p+.dlist,p+.hdlist,.paragraph+.ulist,.paragraph+.olist,.paragraph+.dlist,.paragraph+.hdlist,.paragraph+.listingblock{margin-top:.5em !important}li *+.ulist,li *+.olist,li *+.dlist,li *+.hdlist{margin-top:.1em !important}.title:not(:first-child){margin-top:1.5em}.content+.title{margin-top:.5em !important}.title+*{margin-top:1.5em}.title+p,.title+.paragraph,.title+.ulist,.title+.olist,.title+.dlist,.title+.hdlist{margin-top:.5em !important}.ulist:not(:last-child){margin-bottom:1em}.olist:not(:last-child){margin-bottom:1em}li:not(:first-child){margin-top:.1em}.dlist:not(:last-child){margin-bottom:1em}.dlist:not(:first-child){margin-top:1em}.sect3:not(:last-child){margin-bottom:18px}.sect3:not(:first-child){margin-top:18px}h4:not(:last-child){margin-bottom:9px}.sect2:not(:last-child){margin-bottom:22px}.sect2:not(:first-child){margin-top:22px}h3:not(:last-child){margin-bottom:11px}.sect1:not(:last-child){margin-bottom:40px}.sect1:not(:first-child){margin-top:40px}#preamble:not(:last-child){margin-bottom:40px}h2:not(:last-child){margin-bottom:13px}#header:not(:last-child),#content:not(:last-child),#footnotes:not(:last-child){margin-bottom:2em}.text-left{text-align:left}.text-center{text-align:center}.text-right{text-align:right}
</style>
<style>
.listingblock .pygments .hll { background-color: #ffffcc }
.listingblock .pygments, .listingblock .pygments code { background: #f8f8f8; }
.listingblock .pygments .tok-c { color: #408080; font-style: italic } /* Comment */
.listingblock .pygments .tok-err { border: 1px solid #FF0000 } /* Error */
.listingblock .pygments .tok-k { color: #008000; font-weight: bold } /* Keyword */
.listingblock .pygments .tok-o { color: #666666 } /* Operator */
.listingblock .pygments .tok-ch { color: #408080; font-style: italic } /* Comment.Hashbang */
.listingblock .pygments .tok-cm { color: #408080; font-style: italic } /* Comment.Multiline */
.listingblock .pygments .tok-cp { color: #BC7A00 } /* Comment.Preproc */
.listingblock .pygments .tok-cpf { color: #408080; font-style: italic } /* Comment.PreprocFile */
.listingblock .pygments .tok-c1 { color: #408080; font-style: italic } /* Comment.Single */
.listingblock .pygments .tok-cs { color: #408080; font-style: italic } /* Comment.Special */
.listingblock .pygments .tok-gd { color: #A00000 } /* Generic.Deleted */
.listingblock .pygments .tok-ge { font-style: italic } /* Generic.Emph */
.listingblock .pygments .tok-gr { color: #FF0000 } /* Generic.Error */
.listingblock .pygments .tok-gh { color: #000080; font-weight: bold } /* Generic.Heading */
.listingblock .pygments .tok-gi { color: #00A000 } /* Generic.Inserted */
.listingblock .pygments .tok-go { color: #888888 } /* Generic.Output */
.listingblock .pygments .tok-gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.listingblock .pygments .tok-gs { font-weight: bold } /* Generic.Strong */
.listingblock .pygments .tok-gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.listingblock .pygments .tok-gt { color: #0044DD } /* Generic.Traceback */
.listingblock .pygments .tok-kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.listingblock .pygments .tok-kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.listingblock .pygments .tok-kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.listingblock .pygments .tok-kp { color: #008000 } /* Keyword.Pseudo */
.listingblock .pygments .tok-kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.listingblock .pygments .tok-kt { color: #B00040 } /* Keyword.Type */
.listingblock .pygments .tok-m { color: #666666 } /* Literal.Number */
.listingblock .pygments .tok-s { color: #BA2121 } /* Literal.String */
.listingblock .pygments .tok-na { color: #7D9029 } /* Name.Attribute */
.listingblock .pygments .tok-nb { color: #008000 } /* Name.Builtin */
.listingblock .pygments .tok-nc { color: #0000FF; font-weight: bold } /* Name.Class */
.listingblock .pygments .tok-no { color: #880000 } /* Name.Constant */
.listingblock .pygments .tok-nd { color: #AA22FF } /* Name.Decorator */
.listingblock .pygments .tok-ni { color: #999999; font-weight: bold } /* Name.Entity */
.listingblock .pygments .tok-ne { color: #D2413A; font-weight: bold } /* Name.Exception */
.listingblock .pygments .tok-nf { color: #0000FF } /* Name.Function */
.listingblock .pygments .tok-nl { color: #A0A000 } /* Name.Label */
.listingblock .pygments .tok-nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
.listingblock .pygments .tok-nt { color: #008000; font-weight: bold } /* Name.Tag */
.listingblock .pygments .tok-nv { color: #19177C } /* Name.Variable */
.listingblock .pygments .tok-ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
.listingblock .pygments .tok-w { color: #bbbbbb } /* Text.Whitespace */
.listingblock .pygments .tok-mb { color: #666666 } /* Literal.Number.Bin */
.listingblock .pygments .tok-mf { color: #666666 } /* Literal.Number.Float */
.listingblock .pygments .tok-mh { color: #666666 } /* Literal.Number.Hex */
.listingblock .pygments .tok-mi { color: #666666 } /* Literal.Number.Integer */
.listingblock .pygments .tok-mo { color: #666666 } /* Literal.Number.Oct */
.listingblock .pygments .tok-sa { color: #BA2121 } /* Literal.String.Affix */
.listingblock .pygments .tok-sb { color: #BA2121 } /* Literal.String.Backtick */
.listingblock .pygments .tok-sc { color: #BA2121 } /* Literal.String.Char */
.listingblock .pygments .tok-dl { color: #BA2121 } /* Literal.String.Delimiter */
.listingblock .pygments .tok-sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.listingblock .pygments .tok-s2 { color: #BA2121 } /* Literal.String.Double */
.listingblock .pygments .tok-se { color: #BB6622; font-weight: bold } /* Literal.String.Escape */
.listingblock .pygments .tok-sh { color: #BA2121 } /* Literal.String.Heredoc */
.listingblock .pygments .tok-si { color: #BB6688; font-weight: bold } /* Literal.String.Interpol */
.listingblock .pygments .tok-sx { color: #008000 } /* Literal.String.Other */
.listingblock .pygments .tok-sr { color: #BB6688 } /* Literal.String.Regex */
.listingblock .pygments .tok-s1 { color: #BA2121 } /* Literal.String.Single */
.listingblock .pygments .tok-ss { color: #19177C } /* Literal.String.Symbol */
.listingblock .pygments .tok-bp { color: #008000 } /* Name.Builtin.Pseudo */
.listingblock .pygments .tok-fm { color: #0000FF } /* Name.Function.Magic */
.listingblock .pygments .tok-vc { color: #19177C } /* Name.Variable.Class */
.listingblock .pygments .tok-vg { color: #19177C } /* Name.Variable.Global */
.listingblock .pygments .tok-vi { color: #19177C } /* Name.Variable.Instance */
.listingblock .pygments .tok-vm { color: #19177C } /* Name.Variable.Magic */
.listingblock .pygments .tok-il { color: #666666 } /* Literal.Number.Integer.Long */
</style>
</head>
<body class="article">
<div id="header">
<h1>Efficient implementation of MinHash, part 1</h1>
<div class="details">
<span id="author" class="author">Andrei Gudkov</span><br>
<span id="email" class="email"><a href="mailto:gudokk@gmail.com">gudokk@gmail.com</a></span><br>
</div>
</div>
<div id="content">
<div class="paragraph">
<p>MinHash is a technique widely used to compare texts for similarity.
For example, in web search it is used to detect mirror sites.
Mirror is a site that clones the contents of another site either
verbatim or very closely.
Web search engines are interested in mirror detection because of two reasons.
First of all, it significantly reduces cost of maintaining search engine.
Search engines typically index contents of only the primary web site (highestly ranked)
and ignore all its mirrors.
Secondly, mirrors to well-known sites often indicate phishing,
which raises red flags for security team.
Another application of MinHash is plagiarism detection.
Universities and scientific magazines are interested to automatically recognize
copypasted papers and thesises.</p>
</div>
<div class="paragraph">
<p>MinHash algorithm has a number of variations.
In this article I will focus on the MinHash variation that uses single hash function.
Such type of MinHash is computationally fast to construct, but computation of similarity
score between a pair of documents using their MinHashes is slow.
This limits application of this variation of MinHash to the collections of documents of small
to moderate sizes.</p>
</div>
<div class="paragraph">
<p>The high-level workflow is the following: for every text you have,
split it into sequence of words, then create a set of every K-tuple of adjacent words
(I will use K=3 below; every such triplet is called a <em>shingle</em>),
then hash these shingles into 32-bit hashes,
and finally select smallest unique N shingles.
These N shingles become the fingerprint (MinHash) of the text.
N is chosen typically from about 50 to a couple of hundreds
depending on the median size of the text of the collection.</p>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="overview.png" alt="overview" width="100%">
</div>
</div>
<div class="paragraph">
<p>Once fingerprints are generated for every text,
we can compute similarity of any pair of texts by computing their Jaccard score
of their fingerprints:</p>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="math-f7985fa2930103d5.svg" alt="J(t_1, t_2) = \frac
{\left | \mathrm{Fingerprint}(t_1) \cap \mathrm{Fingerprint}(t_2) \right |}
{\left | \mathrm{Fingerprint}(t_1) \cup \mathrm{Fingerprint}(t_2) \right |}
\in \left [ 0.0\,..\,1.0 \right ]" height="40">
</div>
</div>
<div class="paragraph">
<p>It can be proved that there is correlation between closeness of two texts and their similarity score <img src="math-34efd6251aa1ff62.svg" class="inlinemath" style="height:1.75ex;vertical-align:-0.391ex;" alt="J(t_1,t_2)"/>.
For any pair of documents, the closer Jaccard score between their fingerprints to one,
the closer Jaccard score between their full sets of shingles to one,
and the closer the texts themselves are.
For example, we can set threshold value to 0.8.
If Jaccard score exceeds 0.8, then we conclude that two texts are nearly identical.</p>
</div>
<div class="paragraph">
<p>The good thing about MinHash is that it is robust to minor modifications to the text.
For example, web pages often contain some elements which become different when site is mirrored,
such as current timestamp, domain name or manually added disclaimers.
Just comparing texts character-by-character would not be enough.
Another good thing about MinHash is that no matter how large input texts are,
the fingperprints it computes are of fixed, short lengths.
Fingerprint consisting of 128 32-bit hashes is only 512 bytes.</p>
</div>
<div class="paragraph">
<p>However, even this "computationally cheap" variant is expensive in practice.
In this article I will demonstrate efficient implementation of fingerprint generation and pair-wise
computation of <img src="math-c2b51b5f051a140e.svg" class="inlinemath" style="height:1.75ex;vertical-align:-0.391ex;" alt="J(t_1, t_2)"/>.</p>
</div>
<div class="paragraph">
<div class="title">Tokenizing text</div>
<p>First task is tokenizing text into words.
Usually high-quality text analysis requires NLP-based models.
For example, it is desirable to treat "N.B.A." identically to "NBA" rather
than consisting of three distinct tokens "N", "B", "A".
Similarily, words "happy" and "happiness" are usually stemmed to the same root "happi".
Luckily, in similarity detection we don&#8217;t need this level of complexity due
to probabilistic nature of the algorithm, and can define a word simply
as a sequence of adjacent alphanumeric characters.
Remaining (non-alphanumeric) characters are the delimeters.</p>
</div>
<div class="paragraph">
<p>Assuming that text is a sequence of 16-bit unicode code points,
the number of alphanumeric characters is large and, worse, they do not
form adjacent region.
In the image below, there is one pixel per every 16-bit code point.
Red pixels denote alphanumeric code points.</p>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="isalphanum.png" alt="isalphanum">
</div>
</div>
<div class="paragraph">
<p>The only reasonable way to store this information is in a lookup table with one bit
per every code point.
The table below was prebuilt in Java by probing code points with <code>Character.isLetterOrDigit(char c)</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cpp"><span></span><span class="tok-n">__attribute__</span><span class="tok-p">((</span><span class="tok-n">aligned</span><span class="tok-p">(</span><span class="tok-mi">64</span><span class="tok-p">)))</span> <span class="tok-k">const</span> <span class="tok-kt">uint64_t</span> <span class="tok-n">kAlphanumTable</span><span class="tok-p">[]</span> <span class="tok-o">=</span> <span class="tok-p">{</span>
  <span class="tok-mh">0x03ff000000000000</span><span class="tok-p">,</span> <span class="tok-mh">0x07fffffe07fffffe</span><span class="tok-p">,</span> <span class="tok-mh">0x0420040000000000</span><span class="tok-p">,</span> <span class="tok-mh">0xff7fffffff7fffff</span><span class="tok-p">,</span>
  <span class="tok-mh">0xffffffffffffffff</span><span class="tok-p">,</span> <span class="tok-mh">0xffffffffffffffff</span><span class="tok-p">,</span> <span class="tok-mh">0xffffffffffffffff</span><span class="tok-p">,</span> <span class="tok-mh">0xffffffffffffffff</span><span class="tok-p">,</span>
  <span class="tok-mh">0xffffffffffffffff</span><span class="tok-p">,</span> <span class="tok-mh">0xffffffffffffffff</span><span class="tok-p">,</span> <span class="tok-mh">0xffffffffffffffff</span><span class="tok-p">,</span> <span class="tok-mh">0x0000501f0003ffc3</span><span class="tok-p">,</span>
  <span class="tok-cm">/* ... */</span>
  <span class="tok-mh">0x3fffffffffffffff</span><span class="tok-p">,</span> <span class="tok-mh">0xffffffffffff0000</span><span class="tok-p">,</span> <span class="tok-mh">0xfffffffffffcffff</span><span class="tok-p">,</span> <span class="tok-mh">0x0fff0000000000ff</span><span class="tok-p">,</span>
  <span class="tok-mh">0x0000000000000000</span><span class="tok-p">,</span> <span class="tok-mh">0xffdf000000000000</span><span class="tok-p">,</span> <span class="tok-mh">0xffffffffffffffff</span><span class="tok-p">,</span> <span class="tok-mh">0x1fffffffffffffff</span><span class="tok-p">,</span>
  <span class="tok-mh">0x07fffffe03ff0000</span><span class="tok-p">,</span> <span class="tok-mh">0xffffffc007fffffe</span><span class="tok-p">,</span> <span class="tok-mh">0x7fffffffffffffff</span><span class="tok-p">,</span> <span class="tok-mh">0x000000001cfcfcfc</span><span class="tok-p">,</span>
<span class="tok-p">};</span>

<span class="tok-kr">inline</span> <span class="tok-kt">bool</span> <span class="tok-nf">IsAlphanum</span><span class="tok-p">(</span><span class="tok-kt">unsigned</span> <span class="tok-kt">int</span> <span class="tok-n">c</span><span class="tok-p">)</span> <span class="tok-p">{</span>
  <span class="tok-k">return</span> <span class="tok-p">(</span><span class="tok-n">kAlphanumTable</span><span class="tok-p">[</span><span class="tok-n">c</span><span class="tok-o">/</span><span class="tok-mi">64</span><span class="tok-p">]</span> <span class="tok-o">&gt;&gt;</span> <span class="tok-p">(</span><span class="tok-n">c</span><span class="tok-o">%</span><span class="tok-mi">64</span><span class="tok-p">))</span> <span class="tok-o">&amp;</span> <span class="tok-mh">0x1</span><span class="tok-p">;</span>
<span class="tok-p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<div class="title">Choosing hash function</div>
<p>Before we continue forward, let&#8217;s choose hash function.
We want it to be relatively fast to compute but complex enough to be robust to permutations,
e.g. we want for "word1 word2 word3" and "word1 word3 word2" to be hashed to different values.
Thus, per-character XOR is a bad idea.
Taking into consideration the above requirements, I chose
<a href="https://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function">FNV-1a</a>.
It is well studied, widely used in practice (glibc implements <code>std::hash&lt;T&gt;</code> by using it),
not very expensive (two multiplications per 16-bit character), and also easy to code.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cpp"><span></span><span class="tok-kt">uint32_t</span> <span class="tok-nf">fnv1a</span><span class="tok-p">(</span><span class="tok-k">const</span> <span class="tok-kt">uint16_t</span><span class="tok-o">*</span> <span class="tok-n">str</span><span class="tok-p">,</span> <span class="tok-kt">int</span> <span class="tok-n">len</span><span class="tok-p">)</span> <span class="tok-p">{</span>
  <span class="tok-kt">uint32_t</span> <span class="tok-n">hash</span> <span class="tok-o">=</span> <span class="tok-mi">2166136261</span><span class="tok-p">;</span>
  <span class="tok-k">for</span> <span class="tok-p">(</span><span class="tok-kt">size_t</span> <span class="tok-n">i</span> <span class="tok-o">=</span> <span class="tok-mi">0</span><span class="tok-p">;</span> <span class="tok-n">i</span> <span class="tok-o">&lt;</span> <span class="tok-n">len</span><span class="tok-p">;</span> <span class="tok-n">i</span><span class="tok-o">++</span><span class="tok-p">)</span> <span class="tok-p">{</span>
    <span class="tok-kt">uint16_t</span> <span class="tok-n">c</span> <span class="tok-o">=</span> <span class="tok-n">str</span><span class="tok-p">[</span><span class="tok-n">i</span><span class="tok-p">];</span>
    <span class="tok-n">hash</span> <span class="tok-o">=</span> <span class="tok-n">hash</span> <span class="tok-o">^</span> <span class="tok-p">(</span><span class="tok-n">c</span> <span class="tok-o">&amp;</span> <span class="tok-mh">0xff</span><span class="tok-p">);</span>
    <span class="tok-n">hash</span> <span class="tok-o">=</span> <span class="tok-n">hash</span> <span class="tok-o">*</span> <span class="tok-mi">16777619</span><span class="tok-p">;</span>
    <span class="tok-n">hash</span> <span class="tok-o">=</span> <span class="tok-n">hash</span> <span class="tok-o">^</span> <span class="tok-p">(</span><span class="tok-n">c</span> <span class="tok-o">&gt;&gt;</span> <span class="tok-mi">16</span><span class="tok-p">);</span>
    <span class="tok-n">hash</span> <span class="tok-o">=</span> <span class="tok-n">hash</span> <span class="tok-o">*</span> <span class="tok-mi">16777619</span><span class="tok-p">;</span>
  <span class="tok-p">}</span>
  <span class="tok-k">return</span> <span class="tok-n">hash</span><span class="tok-p">;</span>
<span class="tok-p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<div class="title">Generating shingles</div>
<p>First place where we can get significant gains in performance is shingle generation algorithm.
Below pseudocode demonstrates naive implementation.
It is implemented exactly as visualized in the very first image.
First, we split text into an array of separate words.
Next we are iterating over every sequence of K=3 adjacent words, compute and emit hash.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code>words[] = Tokenize(text)
for i := 0 .. words.length()-3:
  hash = InitHash()
  for k := 0 .. 2:
    for j := 0 .. words[i+k].length
      hash = UpdateHash(hash, words[i+k][j])
  Collect(hash)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Noticeable issue is that a copy of input text is made into the words array.
It shouldn&#8217;t be very hard to avoid copying because shingling is a type of streaming algorithm,
i.e. we need only to keep track of a sliding window of K=3 consecutive words at a time.</p>
</div>
<div class="paragraph">
<p>But we can do even better by implementing pipeline.
To do this, we are going to store K=3 partially computed hashes.
All these hashes are updated every time we read new alphanumeric character.
When the word is over, the head of the pipline is the full hash of the previous K words,
next element after the head is the partial hash for the last K-1 words, and so on.
When the word is over, we eject the head of the pipeline and shift
the remaining hashes.</p>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="pipeline.png" alt="pipeline" width="80%">
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cpp"><span></span><span class="tok-k">template</span><span class="tok-o">&lt;</span><span class="tok-kt">int</span> <span class="tok-n">K</span><span class="tok-o">&gt;</span> <span class="tok-c1">// shingle length in words, e.g. K=3</span>
<span class="tok-k">const</span> <span class="tok-kt">uint16_t</span><span class="tok-o">*</span> <span class="tok-n">txt</span><span class="tok-p">;</span> <span class="tok-c1">// arg</span>
<span class="tok-kt">int</span> <span class="tok-n">txt_length</span><span class="tok-p">;</span> <span class="tok-c1">// arg</span>
<span class="tok-p">...</span>

<span class="tok-c1">// main loop</span>
<span class="tok-kt">size_t</span> <span class="tok-n">i</span> <span class="tok-o">=</span> <span class="tok-mi">0</span><span class="tok-p">;</span>
<span class="tok-kt">uint32_t</span> <span class="tok-n">pipeline</span><span class="tok-p">[</span><span class="tok-n">K</span><span class="tok-p">];</span>
<span class="tok-k">while</span> <span class="tok-p">(</span><span class="tok-n">i</span> <span class="tok-o">&lt;</span> <span class="tok-n">txt_length</span><span class="tok-p">)</span> <span class="tok-p">{</span>
  <span class="tok-c1">// process next word</span>
  <span class="tok-k">while</span> <span class="tok-p">(</span><span class="tok-n">i</span> <span class="tok-o">&lt;</span> <span class="tok-n">txt_length</span> <span class="tok-o">&amp;&amp;</span> <span class="tok-n">IsAlphanum</span><span class="tok-p">(</span><span class="tok-n">txt</span><span class="tok-p">[</span><span class="tok-n">i</span><span class="tok-p">]))</span> <span class="tok-p">{</span>
    <span class="tok-kt">uint16_t</span> <span class="tok-n">c</span> <span class="tok-o">=</span> <span class="tok-n">txt</span><span class="tok-p">[</span><span class="tok-n">i</span><span class="tok-p">];</span>
    <span class="tok-k">for</span> <span class="tok-p">(</span><span class="tok-kt">int</span> <span class="tok-n">k</span> <span class="tok-o">=</span> <span class="tok-mi">0</span><span class="tok-p">;</span> <span class="tok-n">k</span> <span class="tok-o">&lt;</span> <span class="tok-n">K</span><span class="tok-p">;</span> <span class="tok-n">k</span><span class="tok-o">++</span><span class="tok-p">)</span> <span class="tok-p">{</span>
      <span class="tok-n">pipeline</span><span class="tok-p">[</span><span class="tok-n">k</span><span class="tok-p">]</span> <span class="tok-o">=</span> <span class="tok-n">pipeline</span><span class="tok-p">[</span><span class="tok-n">k</span><span class="tok-p">]</span> <span class="tok-o">^</span> <span class="tok-p">(</span><span class="tok-n">c</span> <span class="tok-o">&amp;</span> <span class="tok-mh">0xff</span><span class="tok-p">);</span>
      <span class="tok-n">pipeline</span><span class="tok-p">[</span><span class="tok-n">k</span><span class="tok-p">]</span> <span class="tok-o">=</span> <span class="tok-n">pipeline</span><span class="tok-p">[</span><span class="tok-n">k</span><span class="tok-p">]</span> <span class="tok-o">*</span> <span class="tok-mi">16777619</span><span class="tok-p">;</span>
      <span class="tok-n">pipiline</span><span class="tok-p">[</span><span class="tok-n">k</span><span class="tok-p">]</span> <span class="tok-o">=</span> <span class="tok-n">pipeline</span><span class="tok-p">[</span><span class="tok-n">k</span><span class="tok-p">]</span> <span class="tok-o">^</span> <span class="tok-p">(</span><span class="tok-n">c</span> <span class="tok-o">&gt;&gt;</span> <span class="tok-mi">16</span><span class="tok-p">);</span>
      <span class="tok-n">pipeline</span><span class="tok-p">[</span><span class="tok-n">k</span><span class="tok-p">]</span> <span class="tok-o">=</span> <span class="tok-n">pipeline</span><span class="tok-p">[</span><span class="tok-n">k</span><span class="tok-p">]</span> <span class="tok-o">*</span> <span class="tok-mi">16777619</span><span class="tok-p">;</span>
    <span class="tok-p">}</span>
    <span class="tok-n">i</span><span class="tok-o">++</span><span class="tok-p">;</span>
  <span class="tok-p">}</span>

  <span class="tok-c1">// collect head of the pipeline</span>
  <span class="tok-n">Collect</span><span class="tok-p">(</span><span class="tok-n">pipeline</span><span class="tok-p">[</span><span class="tok-mi">0</span><span class="tok-p">]);</span>

  <span class="tok-c1">// shift pipeline</span>
  <span class="tok-k">for</span> <span class="tok-p">(</span><span class="tok-kt">int</span> <span class="tok-n">k</span> <span class="tok-o">=</span> <span class="tok-mi">0</span><span class="tok-p">;</span> <span class="tok-n">k</span> <span class="tok-o">&lt;</span> <span class="tok-n">K</span><span class="tok-o">-</span><span class="tok-mi">1</span><span class="tok-p">;</span> <span class="tok-n">k</span><span class="tok-o">++</span><span class="tok-p">)</span> <span class="tok-p">{</span>
    <span class="tok-n">pipeline</span><span class="tok-p">[</span><span class="tok-n">k</span><span class="tok-p">]</span> <span class="tok-o">=</span> <span class="tok-n">pipeline</span><span class="tok-p">[</span><span class="tok-n">k</span><span class="tok-o">+</span><span class="tok-mi">1</span><span class="tok-p">];</span>
  <span class="tok-p">}</span>
  <span class="tok-n">pipeline</span><span class="tok-p">[</span><span class="tok-n">K</span><span class="tok-o">-</span><span class="tok-mi">1</span><span class="tok-p">]</span> <span class="tok-o">=</span> <span class="tok-mi">2166136261</span><span class="tok-p">;</span>

  <span class="tok-c1">// skip delimiter</span>
  <span class="tok-k">while</span> <span class="tok-p">(</span><span class="tok-n">i</span> <span class="tok-o">&lt;</span> <span class="tok-n">txt_length</span> <span class="tok-o">&amp;&amp;</span> <span class="tok-o">!</span><span class="tok-n">IsAlphanum</span><span class="tok-p">(</span><span class="tok-n">txt</span><span class="tok-p">[</span><span class="tok-n">i</span><span class="tok-p">]))</span> <span class="tok-p">{</span>
    <span class="tok-n">i</span><span class="tok-o">++</span><span class="tok-p">;</span>
  <span class="tok-p">}</span>
<span class="tok-p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>It is important that K is known at compile time and is not a runtime argument.
Because K is small (K=3 in our case), compiler unrolls the loop:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="asm"><span></span><span class="tok-nf">xorl</span>  <span class="tok-nv">%edx</span><span class="tok-p">,</span> <span class="tok-nv">%eax</span>
<span class="tok-nf">xorl</span>  <span class="tok-nv">%edx</span><span class="tok-p">,</span> <span class="tok-nv">%r13d</span>
<span class="tok-nf">xorl</span>  <span class="tok-nv">%r12d</span><span class="tok-p">,</span> <span class="tok-nv">%edx</span>
<span class="tok-nf">imull</span> <span class="tok-no">$637696617</span><span class="tok-p">,</span> <span class="tok-nv">%eax</span><span class="tok-p">,</span> <span class="tok-nv">%eax</span>
<span class="tok-nf">imull</span> <span class="tok-no">$637696617</span><span class="tok-p">,</span> <span class="tok-nv">%r13d</span><span class="tok-p">,</span> <span class="tok-nv">%r13d</span>
<span class="tok-nf">imull</span> <span class="tok-no">$637696617</span><span class="tok-p">,</span> <span class="tok-nv">%edx</span><span class="tok-p">,</span> <span class="tok-nv">%r12d</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Unrolling has obvious benefit of avoiding conditional check at every iteration.
But more important is that because iterations are independent from one another,
CPU can execute instructions in parallel.
This leads to significant speedup.</p>
</div>
<div class="paragraph">
<div class="title">Selecting smallest hashes</div>
<p>The most simple way would be to collect all hashes into a vector, sort them and then return smallest N hashes.
Experienced algorithmist may know a way to do this without sorting all hashes, by using <code>std::partial_sort</code>.
Its idea is similar to quick sort: at every step we choose pivot and exchange
elements so that in the end array consists of two groups of elements:
elements which are less or equal to pivot go to the beginning, while elements larger than pivot
go to the end of the array.
We repeat the process multiple times always by using left group.
Right group is of no importance and is ignored.</p>
</div>
<div class="paragraph">
<p>But <code>std::partial_sort</code> still implies that we need to collect all hashes somewhere.
This may be unfeasable for large texts.
We would like to design streaming algorithm with O(N) space.
This leads to the idea of storing N smallest hash values in sorted array.
As such, we can check the presense of an element in O(log N).
Inserting is more expensive because it requires to shift N/2 elements on average.</p>
</div>
<div class="paragraph">
<p>Even better idea is to use heap.
It would make insert really fast.
But the trouble is that our values are not unique,
and checking for element existance in a heap is O(N) time.
To avoid such expensive check, in addition to heap we can maintain
a hash table that would guard heap from receiving duplicate elements.
So, now the algorithm becomes like this: for every incoming hash,
check that it is smaller than <code>heap.peek()</code>,
check that it is not present in the hash table,
and if both conditions are satisfied, then update both heap and hash table by removing
<code>heap.peek()</code> element and inserting the incoming hash.</p>
</div>
<div class="paragraph">
<p>This version is asymptocitally optimal, but it still has some problems related to the nature of hash table.
Classical hash table uses dynamical memory allocations, linked lists and it also hashes values,
even though our elements are already high quality hashes themselves.
What if we could replace classical hash table with a simpler one?
We know the number of elements we are going to store in it in advance and also we have
copy of all elements in a heap, so we have something to offer in return.
After some time spent on thinking and benchmarking, this leads to the following solution.
Classical hash table is replaced with manually created hash table with the following properties:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>It is just an array of 4N uint32_t slots.
No more than 2N elements are going to be stored at any given time to ensure search/insert in O(1) time.</p>
</li>
<li>
<p>Special uint32_t value denotes empty slot.</p>
</li>
<li>
<p>Elements are inserted by using linear probing: if the desired slot is occupied,
we scan table below until we find free slot.
This is safe because no more than 2N elements will ever be stored there.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The tradeoff is that such implementation doesn&#8217;t allow deletions.
But this is not a problem.
As soon as table becomes 2N full, we just remove all elements from the table and repopulate it from the heap.
As such, load factor of the table oscillates betwen 0.25 and 0.5.</p>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="dataflow.png" alt="dataflow" width="100%">
</div>
</div>
<div class="paragraph">
<p>Below is the pseudo-code for the main loop:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code>def Collect(h):
  if h &lt; heap[0]:
    if !htable.contains(h):
      htable.insert(h)
      heap.pop(heap)
      heap.push(heap, h)

      if htable.size() &gt;= N*2:
        htable.clear()
        for i := 0 .. heap.size()-1:
          htable.insert(heap[i])</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the result we have a solution with O(1) time to check whether an element exists,
and with O(log N) insertion time.
Occasionally hash table must be repopulated, but this happens rarely and thus
its contribution to the total time is negligible.</p>
</div>
<div class="paragraph">
<div class="title">Evaluation</div>
<p>Test collection consists of 1000 long articles from Wikipedia,
varying in size from 16KB to 540KB.</p>
</div>
<table class="tableblock frame-all grid-all" style="width: 70%;">
<colgroup>
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top"></th>
<th class="tableblock halign-right valign-top">Time [s]</th>
<th class="tableblock halign-right valign-top">MChars/s</th>
<th class="tableblock halign-right valign-top">Speedup</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">naive</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock">0.939594</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock">52.7</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock">1.0</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">pipeline + sort</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock">0.513581</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock">96.3</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock">1.8</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">pipeline + unordered_set + heap</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock">0.276099</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock">179.2</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock">3.4</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">pipeline + custom htable + heap</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock">0.177911</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock">278.1</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock">5.3</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>First version is the naive, reference implementation of everything.
Second version uses pipelined shingle generation, but still collects and sorts all hashes to find N smallest.
Third version uses heap to find N smallest hashes, guarded by <code>std::unordered_set&lt;uint32_t&gt;</code>.
Final version is the modification where unordered set is replaced with custom hash table.
It reaches throughput of 278M characters per second&#8201;&#8212;&#8201;more than enough not to be a bottleneck
in a data pipeline.</p>
</div>
<div class="paragraph">
<div class="title">Pair-wise computation</div>
<p>At this point we have fingerprints for every document of the collection.
A fingerprint is a sorted array of up to N 32-bit hashes.
To compute Jaccard similarity score between two documents, we need to find the cardinality
of their fingerprint intersection.
This can be done with the classical algorithm:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cpp"><span></span><span class="tok-kt">double</span> <span class="tok-nf">JaccardClassical</span><span class="tok-p">(</span><span class="tok-k">const</span> <span class="tok-kt">uint32_t</span><span class="tok-o">*</span> <span class="tok-n">fng1</span><span class="tok-p">,</span> <span class="tok-kt">int</span> <span class="tok-n">len1</span><span class="tok-p">,</span>
                        <span class="tok-k">const</span> <span class="tok-kt">uint32_t</span><span class="tok-o">*</span> <span class="tok-n">fng2</span><span class="tok-p">,</span> <span class="tok-kt">int</span> <span class="tok-n">len2</span><span class="tok-p">)</span>
<span class="tok-p">{</span>
  <span class="tok-kt">int</span> <span class="tok-n">pos1</span> <span class="tok-o">=</span> <span class="tok-mi">0</span><span class="tok-p">;</span>
  <span class="tok-kt">int</span> <span class="tok-n">pos2</span> <span class="tok-o">=</span> <span class="tok-mi">0</span><span class="tok-p">;</span>
  <span class="tok-kt">int</span> <span class="tok-n">nintersect</span> <span class="tok-o">=</span> <span class="tok-mi">0</span><span class="tok-p">;</span>
  <span class="tok-k">while</span> <span class="tok-p">(</span><span class="tok-n">pos1</span> <span class="tok-o">&lt;</span> <span class="tok-n">len1</span> <span class="tok-o">&amp;&amp;</span> <span class="tok-n">pos2</span> <span class="tok-o">&lt;</span> <span class="tok-n">len2</span><span class="tok-p">)</span> <span class="tok-p">{</span>
    <span class="tok-k">if</span> <span class="tok-p">(</span><span class="tok-n">fng1</span><span class="tok-p">[</span><span class="tok-n">pos1</span><span class="tok-p">]</span> <span class="tok-o">==</span> <span class="tok-n">fng2</span><span class="tok-p">[</span><span class="tok-n">pos2</span><span class="tok-p">])</span> <span class="tok-p">{</span>
      <span class="tok-n">nintersect</span><span class="tok-o">++</span><span class="tok-p">;</span>
      <span class="tok-n">pos1</span><span class="tok-o">++</span><span class="tok-p">;</span>
      <span class="tok-n">pos2</span><span class="tok-o">++</span><span class="tok-p">;</span>
    <span class="tok-p">}</span> <span class="tok-k">else</span> <span class="tok-k">if</span> <span class="tok-p">(</span><span class="tok-n">fng1</span><span class="tok-p">[</span><span class="tok-n">pos1</span><span class="tok-p">]</span> <span class="tok-o">&lt;</span> <span class="tok-n">fng2</span><span class="tok-p">[</span><span class="tok-n">pos2</span><span class="tok-p">])</span> <span class="tok-p">{</span>
      <span class="tok-n">pos1</span><span class="tok-o">++</span><span class="tok-p">;</span>
    <span class="tok-p">}</span> <span class="tok-k">else</span> <span class="tok-p">{</span>
      <span class="tok-n">pos2</span><span class="tok-o">++</span><span class="tok-p">;</span>
    <span class="tok-p">}</span>
  <span class="tok-p">}</span>
  <span class="tok-kt">int</span> <span class="tok-n">nunion</span> <span class="tok-o">=</span> <span class="tok-n">len1</span> <span class="tok-o">+</span> <span class="tok-n">len2</span> <span class="tok-o">-</span> <span class="tok-n">nintersect</span><span class="tok-p">;</span>
  <span class="tok-k">return</span> <span class="tok-n">nintersect</span> <span class="tok-o">/</span> <span class="tok-p">(</span><span class="tok-kt">double</span><span class="tok-p">)</span> <span class="tok-n">nunion</span><span class="tok-p">;</span>
<span class="tok-p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>We wouldn&#8217;t trouble ourselves with optimization of this algorithm if it would be necessary
to compute Jaccard score for only a pair of documents.
The problem is that in practice it is usually required to solve one of the following more complex problems:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Given a collection of documents and a new document, find all documents in the collection
which have Jaccard score with the given document &ge; threshold (e.g. plagiarism detection).</p>
</li>
<li>
<p>Given a collection of documents, find all pairs of documents with Jaccard score &ge; threshold
(clusterization).</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Both algorithms are very expensive due to large number of Jaccard similarity score computations.
For example in case of clusterization, if we have 10K documents, it would be necessary to
compute Jaccard score ~50M times.
So, it is crucial to optimize the above algorithm.</p>
</div>
<div class="paragraph">
<p>We can make two observations.
First one is that we don&#8217;t care about Jaccard scores smaller than threshold.
If at some point during score computation we detect that <img src="math-c2b51b5f051a140e.svg" class="inlinemath" style="height:1.75ex;vertical-align:-0.391ex;" alt="J(t_1, t_2)"/> cannot be greater or equal to the threshold,
we can immediately abort computation and return 0.0.
Only values higher than the threshold matter.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s assume that we have already processed <img src="math-66a010542ea15151.svg" class="inlinemath" style="height:1.453ex;vertical-align:-0.531ex;" alt="\mathrm{pos}_1"/> and <img src="math-d3243da6448b67d3.svg" class="inlinemath" style="height:1.453ex;vertical-align:-0.531ex;" alt="\mathrm{pos}_2"/> hashes of the first and second
fingerprints respectively, and the number of identical hashes was <img src="math-115718387b3e8d60.svg" class="inlinemath" style="height:1.375ex;vertical-align:-0.016ex;" alt="\mathrm{nintersect}"/>.
Then <img src="math-c2b51b5f051a140e.svg" class="inlinemath" style="height:1.75ex;vertical-align:-0.391ex;" alt="J(t_1, t_2)"/> is subject to the following boundaries:</p>
</div>
<div class="imageblock text-indent">
<div class="content">
<img src="math-c29b6dd357e88d1e.svg" alt="\mathrm{min}(\mathrm{J}(t_1,t_2)) = \frac{\mathrm{nintersect}}{\mathrm{len}_1 + \mathrm{len}_2 - \mathrm{nintersect}}" height="37">
</div>
</div>
<div class="imageblock text-indent">
<div class="content">
<img src="math-3f56c1c1b3dcbead.svg" alt="\mathrm{max}(\mathrm{J}(t_1,t_2)) =
\frac{\mathrm{nintersect} + \mathrm{min}(\mathrm{len}_1 - \mathrm{pos}_1, \mathrm{len}_2 - \mathrm{pos}_2)}
     {\mathrm{len}_1 + \mathrm{len}_2 - \mathrm{nintersect} - \mathrm{min}(\mathrm{len}_1 - \mathrm{pos}_1,\mathrm{len}_2 - \mathrm{pos}_2)}" height="39">
</div>
</div>
<div class="paragraph">
<p>Let&#8217;s assume that we are interested only in Jaccard score greater or equal to threshold <img src="math-4893e9df8b5496eb.svg" class="inlinemath" style="height:0.906ex;vertical-align:-0.016ex;" alt="\alpha"/>.
If at any step the following condition is satisfied, we can immediately abort computation,
since we know that final <img src="math-34efd6251aa1ff62.svg" class="inlinemath" style="height:1.75ex;vertical-align:-0.391ex;" alt="J(t_1,t_2)"/> will be smaller than the desired threshold:</p>
</div>
<div class="imageblock text-indent">
<div class="content">
<img src="math-79920fc499aea7d9.svg" alt="\mathrm{max}(\mathrm{J}(t_1,t_2)) &lt; \alpha" height="15">
</div>
</div>
<div class="paragraph">
<p>Simplifying:</p>
</div>
<div class="imageblock text-indent">
<div class="content">
<img src="math-cd8d558242329cd2.svg" alt="\mathrm{nintersect} + \mathrm{min}(\mathrm{len}_1 - \mathrm{pos}_1, \mathrm{len}_2 - \mathrm{pos}_2) &lt;
\frac{\alpha}{1 + \alpha} (\mathrm{len}_1 + \mathrm{len}_2)" height="31">
</div>
</div>
<div class="paragraph">
<p>Since we know that <img src="math-b800664de46817f5.svg" class="inlinemath" style="height:4.125ex;vertical-align:-1.375ex;" alt="\mathrm{min}(a,b) \leq \frac{a+b}{2}"/>, we can tighten the abort condition
to get rid of <img src="math-ce0891f5c72d7611.svg" class="inlinemath" style="height:1.359ex;vertical-align:-0.0ex;" alt="\mathrm{min}"/> function:</p>
</div>
<div class="imageblock text-indent">
<div class="content">
<img src="math-43b3e6819b213a44.svg" alt="\mathrm{nintersect} + \frac{\mathrm{len}_1 + \mathrm{len}_2 - \mathrm{pos}_1 - \mathrm{pos}_2}{2} &lt;
\frac{\alpha}{1 + \alpha}(\mathrm{len}_1 + \mathrm{len}_2)" height="35">
</div>
</div>
<div class="imageblock text-indent">
<div class="content">
<img src="math-eefed2630d2b2e2c.svg" alt="\mathrm{pos}_1 + \mathrm{pos}_2 - 2\,\mathrm{nintersect} &gt;
\frac{1 - \alpha}{1 + \alpha}(\mathrm{len}_1 + \mathrm{len}_2)" height="35">
</div>
</div>
<div class="paragraph">
<p>Again, let&#8217;s tighten condition, now to avoid working with floating point:</p>
</div>
<div class="imageblock text-indent">
<div class="content">
<img src="math-8e70faad5194bf6e.svg" alt="\mathrm{pos}_1 + \mathrm{pos}_2 - 2\,\mathrm{nintersect} &gt;
\left \lceil \frac{1 - \alpha}{1 + \alpha}(\mathrm{len}_1 + \mathrm{len}_2) \right \rceil" height="41">
</div>
</div>
<div class="paragraph">
<p>Now let&#8217;s plug the above formula into the classical solution.
Right-hand side can be computed once we enter the function.
A new variable, <img src="math-043a718774c572bd.svg" class="inlinemath" style="height:0.906ex;vertical-align:-0.016ex;" alt="s"/>, stores the value of <img src="math-881dec7a568ffc0c.svg" class="inlinemath" style="height:1.891ex;vertical-align:-0.531ex;" alt="\mathrm{pos}_1 + \mathrm{pos}_2 - 2\,\mathrm{nintersect}"/>.
We update it each time we advance the positions.
If at some point it exceeds precomputed rind-hand side value, we abort the computation.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cpp"><span></span><span class="tok-kt">double</span> <span class="tok-nf">JaccardFast</span><span class="tok-p">(</span><span class="tok-k">const</span> <span class="tok-kt">uint32_t</span><span class="tok-o">*</span> <span class="tok-n">fng1</span><span class="tok-p">,</span> <span class="tok-kt">int</span> <span class="tok-n">len1</span><span class="tok-p">,</span>
                   <span class="tok-k">const</span> <span class="tok-kt">uint32_t</span><span class="tok-o">*</span> <span class="tok-n">fng2</span><span class="tok-p">,</span> <span class="tok-kt">int</span> <span class="tok-n">len2</span><span class="tok-p">,</span>
                   <span class="tok-kt">double</span> <span class="tok-n">alpha</span><span class="tok-p">)</span>
<span class="tok-p">{</span>
  <span class="tok-k">const</span> <span class="tok-kt">int</span> <span class="tok-n">smax</span> <span class="tok-o">=</span> <span class="tok-p">(</span><span class="tok-kt">int</span><span class="tok-p">)</span><span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">ceil</span><span class="tok-p">((</span><span class="tok-mf">1.0</span><span class="tok-o">-</span><span class="tok-n">alpha</span><span class="tok-p">)</span><span class="tok-o">/</span><span class="tok-p">(</span><span class="tok-mf">1.0</span> <span class="tok-o">+</span> <span class="tok-n">alpha</span><span class="tok-p">)</span> <span class="tok-o">*</span> <span class="tok-p">(</span><span class="tok-n">len1</span> <span class="tok-o">+</span> <span class="tok-n">len2</span><span class="tok-p">));</span>

  <span class="tok-kt">int</span> <span class="tok-n">pos1</span> <span class="tok-o">=</span> <span class="tok-mi">0</span><span class="tok-p">;</span>
  <span class="tok-kt">int</span> <span class="tok-n">pos2</span> <span class="tok-o">=</span> <span class="tok-mi">0</span><span class="tok-p">;</span>
  <span class="tok-kt">int</span> <span class="tok-n">nintersect</span> <span class="tok-o">=</span> <span class="tok-mi">0</span><span class="tok-p">;</span>
  <span class="tok-kt">int</span> <span class="tok-n">s</span> <span class="tok-o">=</span> <span class="tok-mi">0</span><span class="tok-p">;</span>
  <span class="tok-k">while</span> <span class="tok-p">(</span><span class="tok-n">pos1</span> <span class="tok-o">&lt;</span> <span class="tok-n">len1</span> <span class="tok-o">&amp;&amp;</span> <span class="tok-n">pos2</span> <span class="tok-o">&lt;</span> <span class="tok-n">len2</span><span class="tok-p">)</span> <span class="tok-p">{</span>
    <span class="tok-k">if</span> <span class="tok-p">(</span><span class="tok-n">fng1</span><span class="tok-p">[</span><span class="tok-n">pos1</span><span class="tok-p">]</span> <span class="tok-o">==</span> <span class="tok-n">fng2</span><span class="tok-p">[</span><span class="tok-n">pos2</span><span class="tok-p">])</span> <span class="tok-p">{</span>
      <span class="tok-n">nintersect</span><span class="tok-o">++</span><span class="tok-p">;</span>
      <span class="tok-n">pos1</span><span class="tok-o">++</span><span class="tok-p">;</span>
      <span class="tok-n">pos2</span><span class="tok-o">++</span><span class="tok-p">;</span>
      <span class="tok-cm">/* s = s + 1 + 1 - 2 = s */</span>
    <span class="tok-p">}</span> <span class="tok-k">else</span> <span class="tok-k">if</span> <span class="tok-p">(</span><span class="tok-n">fng1</span><span class="tok-p">[</span><span class="tok-n">pos1</span><span class="tok-p">]</span> <span class="tok-o">&lt;</span> <span class="tok-n">fng2</span><span class="tok-p">[</span><span class="tok-n">pos2</span><span class="tok-p">])</span> <span class="tok-p">{</span>
      <span class="tok-n">pos1</span><span class="tok-o">++</span><span class="tok-p">;</span>
      <span class="tok-n">s</span><span class="tok-o">++</span><span class="tok-p">;</span>
    <span class="tok-p">}</span> <span class="tok-k">else</span> <span class="tok-p">{</span>
      <span class="tok-n">pos2</span><span class="tok-o">++</span><span class="tok-p">;</span>
      <span class="tok-n">s</span><span class="tok-o">++</span><span class="tok-p">;</span>
    <span class="tok-p">}</span>
    <span class="tok-k">if</span> <span class="tok-p">(</span><span class="tok-n">s</span> <span class="tok-o">&gt;</span> <span class="tok-n">smax</span><span class="tok-p">)</span> <span class="tok-p">{</span>
      <span class="tok-k">return</span> <span class="tok-mf">0.0</span><span class="tok-p">;</span>
    <span class="tok-p">}</span>
  <span class="tok-p">}</span>
  <span class="tok-kt">int</span> <span class="tok-n">nunion</span> <span class="tok-o">=</span> <span class="tok-n">len1</span> <span class="tok-o">+</span> <span class="tok-n">len2</span> <span class="tok-o">-</span> <span class="tok-n">nintersect</span><span class="tok-p">;</span>
  <span class="tok-k">return</span> <span class="tok-n">nintersect</span> <span class="tok-o">/</span> <span class="tok-p">(</span><span class="tok-kt">double</span><span class="tok-p">)</span> <span class="tok-n">nunion</span><span class="tok-p">;</span>
<span class="tok-p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The second significant observation is that in 99% of all cases Jaccard score is smaller than threshold.
Given a pair of fingperprints of two random documents, very few hashes will be identical among them.
To skip large blocks of nonintersecting hashes, we can make use of
<a href="https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=pestr&amp;expand=829">pcmpesmtrm</a> SSE intruction.
Its intended application is fast string operations, such as substring search.
However, other applications were found for this instruction, including
<a href="http://www.adms-conf.org/p1-SCHLEGEL.pdf#Fast%20Sorted-Set%20Intersection%20using%20SIMD%20Instructions">intersecting</a>
of two sorted arrays.
Alas, <code>pcmpesmtrm</code> works natively only with 8- and 16-bit elements,
while shingle hashes are 32 bit long.
If they were 8 or 16 bits, we could just use the code from the article verbatim.
But because our elements are 32 bit long, we can use this instruction only as a prefilter:
we treat every 32-bit hash as a sequence of two 16 bit elements.
If the instruction returns non-zero mask (some of the 16-bit elements are equal),
this doesn&#8217;t prove that there are equal 32-bit elements.
But if returned mask is zero, then definitely none of the 32-bit elements are equal.
In this case we can advance one of the fingerprint positions by a block of four 32-bit hashes in bulk.
Taking into account that hashes do match very rarely, such precheck is worse the cost
paid for <code>pcmpesmtrm</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cpp"><span></span><span class="tok-kt">double</span> <span class="tok-nf">JaccardTurbo</span><span class="tok-p">(</span><span class="tok-k">const</span> <span class="tok-kt">uint32_t</span><span class="tok-o">*</span> <span class="tok-n">fng1</span><span class="tok-p">,</span> <span class="tok-kt">int</span> <span class="tok-n">len1</span><span class="tok-p">,</span>
                    <span class="tok-k">const</span> <span class="tok-kt">uint32_t</span><span class="tok-o">*</span> <span class="tok-n">fng2</span><span class="tok-p">,</span> <span class="tok-kt">int</span> <span class="tok-n">len2</span><span class="tok-p">,</span>
                    <span class="tok-kt">double</span> <span class="tok-n">alpha</span><span class="tok-p">)</span>
<span class="tok-p">{</span>
  <span class="tok-kt">int</span> <span class="tok-n">smin</span> <span class="tok-o">=</span> <span class="tok-p">(</span><span class="tok-kt">int</span><span class="tok-p">)</span><span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">ceil</span><span class="tok-p">((</span><span class="tok-mf">1.0</span><span class="tok-o">-</span><span class="tok-n">alpha</span><span class="tok-p">)</span><span class="tok-o">/</span><span class="tok-p">(</span><span class="tok-mf">1.0</span> <span class="tok-o">+</span> <span class="tok-n">alpha</span><span class="tok-p">)</span> <span class="tok-o">*</span> <span class="tok-p">(</span><span class="tok-n">len1</span> <span class="tok-o">+</span> <span class="tok-n">len2</span><span class="tok-p">));</span>

  <span class="tok-kt">int</span> <span class="tok-n">pos1</span> <span class="tok-o">=</span> <span class="tok-mi">0</span><span class="tok-p">;</span>
  <span class="tok-kt">int</span> <span class="tok-n">pos2</span> <span class="tok-o">=</span> <span class="tok-mi">0</span><span class="tok-p">;</span>
  <span class="tok-kt">int</span> <span class="tok-n">nintersect</span> <span class="tok-o">=</span> <span class="tok-mi">0</span><span class="tok-p">;</span>
  <span class="tok-kt">int</span> <span class="tok-n">s</span> <span class="tok-o">=</span> <span class="tok-mi">0</span><span class="tok-p">;</span>
  <span class="tok-k">while</span> <span class="tok-p">(</span><span class="tok-n">pos1</span><span class="tok-o">+</span><span class="tok-mi">4</span> <span class="tok-o">&lt;=</span> <span class="tok-n">len1</span> <span class="tok-o">&amp;&amp;</span> <span class="tok-n">pos2</span><span class="tok-o">+</span><span class="tok-mi">4</span> <span class="tok-o">&lt;=</span> <span class="tok-n">len2</span><span class="tok-p">)</span> <span class="tok-p">{</span>
    <span class="tok-kr">__m128i</span> <span class="tok-n">v1</span> <span class="tok-o">=</span> <span class="tok-n">_mm_loadu_si128</span><span class="tok-p">((</span><span class="tok-k">const</span> <span class="tok-kr">__m128i</span><span class="tok-o">*</span><span class="tok-p">)(</span><span class="tok-n">fng1</span> <span class="tok-o">+</span> <span class="tok-n">pos1</span><span class="tok-p">));</span>
    <span class="tok-kr">__m128i</span> <span class="tok-n">v2</span> <span class="tok-o">=</span> <span class="tok-n">_mm_loadu_si128</span><span class="tok-p">((</span><span class="tok-k">const</span> <span class="tok-kr">__m128i</span><span class="tok-o">*</span><span class="tok-p">)(</span><span class="tok-n">fng2</span> <span class="tok-o">+</span> <span class="tok-n">pos2</span><span class="tok-p">));</span>
    <span class="tok-kt">uint64_t</span> <span class="tok-n">m</span> <span class="tok-o">=</span> <span class="tok-n">_mm_cvtsi128_si64</span><span class="tok-p">(</span><span class="tok-n">_mm_cmpestrm</span><span class="tok-p">(</span><span class="tok-n">v1</span><span class="tok-p">,</span> <span class="tok-mi">8</span><span class="tok-p">,</span> <span class="tok-n">v2</span><span class="tok-p">,</span> <span class="tok-mi">8</span><span class="tok-p">,</span>
                 <span class="tok-n">_SIDD_UWORD_OPS</span><span class="tok-o">|</span><span class="tok-n">_SIDD_CMP_EQUAL_ANY</span><span class="tok-o">|</span><span class="tok-n">_SIDD_BIT_MASK</span><span class="tok-p">));</span>
    <span class="tok-k">if</span> <span class="tok-p">(</span><span class="tok-n">m</span><span class="tok-p">)</span> <span class="tok-p">{</span>
      <span class="tok-c1">// we have possible matches -- using classical algorithm</span>
      <span class="tok-k">for</span> <span class="tok-p">(</span><span class="tok-kt">int</span> <span class="tok-n">i</span> <span class="tok-o">=</span> <span class="tok-mi">0</span><span class="tok-p">;</span> <span class="tok-n">i</span> <span class="tok-o">&lt;</span> <span class="tok-mi">4</span><span class="tok-p">;</span> <span class="tok-n">i</span><span class="tok-o">++</span><span class="tok-p">)</span> <span class="tok-p">{</span>
        <span class="tok-k">if</span> <span class="tok-p">(</span><span class="tok-n">fng1</span><span class="tok-p">[</span><span class="tok-n">pos1</span><span class="tok-p">]</span> <span class="tok-o">==</span> <span class="tok-n">fng2</span><span class="tok-p">[</span><span class="tok-n">pos2</span><span class="tok-p">])</span> <span class="tok-p">{</span>
          <span class="tok-n">nintersect</span><span class="tok-o">++</span><span class="tok-p">;</span>
          <span class="tok-n">pos1</span><span class="tok-o">++</span><span class="tok-p">;</span>
          <span class="tok-n">pos2</span><span class="tok-o">++</span><span class="tok-p">;</span>
        <span class="tok-p">}</span> <span class="tok-k">else</span> <span class="tok-k">if</span> <span class="tok-p">(</span><span class="tok-n">fng1</span><span class="tok-p">[</span><span class="tok-n">pos1</span><span class="tok-p">]</span> <span class="tok-o">&lt;</span> <span class="tok-n">fng2</span><span class="tok-p">[</span><span class="tok-n">pos2</span><span class="tok-p">])</span> <span class="tok-p">{</span>
          <span class="tok-n">pos1</span><span class="tok-o">++</span><span class="tok-p">;</span>
          <span class="tok-n">s</span><span class="tok-o">++</span><span class="tok-p">;</span>
        <span class="tok-p">}</span> <span class="tok-k">else</span> <span class="tok-p">{</span>
          <span class="tok-n">pos2</span><span class="tok-o">++</span><span class="tok-p">;</span>
          <span class="tok-n">s</span><span class="tok-o">++</span><span class="tok-p">;</span>
        <span class="tok-p">}</span>
      <span class="tok-p">}</span>
    <span class="tok-p">}</span> <span class="tok-k">else</span> <span class="tok-p">{</span>
      <span class="tok-c1">// no matches</span>
      <span class="tok-k">if</span> <span class="tok-p">(</span><span class="tok-n">fng1</span><span class="tok-p">[</span><span class="tok-n">pos1</span><span class="tok-o">+</span><span class="tok-mi">3</span><span class="tok-p">]</span> <span class="tok-o">&lt;</span> <span class="tok-n">fng2</span><span class="tok-p">[</span><span class="tok-n">pos2</span><span class="tok-o">+</span><span class="tok-mi">3</span><span class="tok-p">])</span> <span class="tok-p">{</span>
        <span class="tok-n">pos1</span> <span class="tok-o">+=</span> <span class="tok-mi">4</span><span class="tok-p">;</span>
      <span class="tok-p">}</span> <span class="tok-k">else</span> <span class="tok-p">{</span>
        <span class="tok-n">pos2</span> <span class="tok-o">+=</span> <span class="tok-mi">4</span><span class="tok-p">;</span>
      <span class="tok-p">}</span>
      <span class="tok-n">s</span> <span class="tok-o">+=</span> <span class="tok-mi">4</span><span class="tok-p">;</span>
    <span class="tok-p">}</span>
    <span class="tok-k">if</span> <span class="tok-p">(</span><span class="tok-n">s</span> <span class="tok-o">&gt;</span> <span class="tok-n">smax</span><span class="tok-p">)</span> <span class="tok-p">{</span>
      <span class="tok-k">return</span> <span class="tok-mf">0.0</span><span class="tok-p">;</span>
    <span class="tok-p">}</span>
  <span class="tok-p">}</span>

  <span class="tok-c1">// process up to three remaining hashes</span>
  <span class="tok-k">while</span> <span class="tok-p">(</span><span class="tok-n">pos1</span> <span class="tok-o">&lt;</span> <span class="tok-n">len1</span> <span class="tok-o">&amp;&amp;</span> <span class="tok-n">pos2</span> <span class="tok-o">&lt;</span> <span class="tok-n">len2</span><span class="tok-p">)</span> <span class="tok-p">{</span>
    <span class="tok-k">if</span> <span class="tok-p">(</span><span class="tok-n">fng1</span><span class="tok-p">[</span><span class="tok-n">pos1</span><span class="tok-p">]</span> <span class="tok-o">==</span> <span class="tok-n">fng2</span><span class="tok-p">[</span><span class="tok-n">pos2</span><span class="tok-p">])</span> <span class="tok-p">{</span>
      <span class="tok-n">nintersect</span><span class="tok-o">++</span><span class="tok-p">;</span>
      <span class="tok-n">pos1</span><span class="tok-o">++</span><span class="tok-p">;</span>
      <span class="tok-n">pos2</span><span class="tok-o">++</span><span class="tok-p">;</span>
    <span class="tok-p">}</span> <span class="tok-k">else</span> <span class="tok-k">if</span> <span class="tok-p">(</span><span class="tok-n">fng1</span><span class="tok-p">[</span><span class="tok-n">pos1</span><span class="tok-p">]</span> <span class="tok-o">&lt;</span> <span class="tok-n">fng2</span><span class="tok-p">[</span><span class="tok-n">pos2</span><span class="tok-p">])</span> <span class="tok-p">{</span>
      <span class="tok-n">pos1</span><span class="tok-o">++</span><span class="tok-p">;</span>
    <span class="tok-p">}</span> <span class="tok-k">else</span> <span class="tok-p">{</span>
      <span class="tok-n">pos2</span><span class="tok-o">++</span><span class="tok-p">;</span>
    <span class="tok-p">}</span>
  <span class="tok-p">}</span>

  <span class="tok-kt">int</span> <span class="tok-n">nunion</span> <span class="tok-o">=</span> <span class="tok-n">len1</span> <span class="tok-o">+</span> <span class="tok-n">len2</span> <span class="tok-o">-</span> <span class="tok-n">nintersect</span><span class="tok-p">;</span>
  <span class="tok-k">return</span> <span class="tok-n">nintersect</span> <span class="tok-o">/</span> <span class="tok-p">(</span><span class="tok-kt">double</span><span class="tok-p">)</span> <span class="tok-n">nunion</span><span class="tok-p">;</span>
<span class="tok-p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<div class="title">Evaluation</div>
<p>The following table summarizes performance results of the above three versions.
All documents in a collection of 2000 documents were compared pairwise,
resulting in total of ~2M computations.
Shingle parameters were N=128 and K=3, threshold value was set to 0.5.</p>
</div>
<table class="tableblock frame-all grid-all" style="width: 70%;">
<colgroup>
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top"></th>
<th class="tableblock halign-right valign-top">Time [s]</th>
<th class="tableblock halign-right valign-top">Computations/s</th>
<th class="tableblock halign-right valign-top">Speedup</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">classical</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock">2.372734</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock">0.84 M/s</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock">1.00</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">classical + fast abort</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock">1.041861</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock">1.92 M/s</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock">2.28</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">classical + pcmpestrm + fast abort</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock">0.632168</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock">3.16 M/s</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock">3.75</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Since documents in the collection were Wikipedia pages, you may be interested
to know which pages had the highest <img src="math-34efd6251aa1ff62.svg" class="inlinemath" style="height:1.75ex;vertical-align:-0.391ex;" alt="J(t_1,t_2)"/>.
I found three main caterogries: pages listing rulers for some specific year;
pages listing animals of African countries;
and surprisingly similar user discussion pages (probably, created by bots).</p>
</div>
<div class="paragraph">
<p>To give some understanding of performance limitations, let&#8217;s assume that we need to clusterize
large collection of documents and we are alotted a single CPU core for 24 hours.
Using the optimized version will allow us to process a collection of ~740K documents.
For larger collections it may be suitable to use MinHash version with multiple hash functions.
I will describe it later in the next article.</p>
</div>
<div class="paragraph">
<div class="title">Sources</div>
<p>C++ source code is located at <a href="https://github.com/andreigudkov/articles/">github</a>.</p>
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2019-06-24 15:34:07 UTC
</div>
</div>
</body>
</html>