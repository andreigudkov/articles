<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]-->
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 1.5.8">
<title>Rationale behind Boyer-Moore algorithm</title>
<style>
/*! normalize.css v2.1.2 | MIT License | git.io/normalize */article,aside,details,figcaption,figure,footer,header,hgroup,main,nav,section,summary{display:block}audio,canvas,video{display:inline-block}audio:not([controls]){display:none;height:0}[hidden],template{display:none}script{display:none !important}html{font-family:sans-serif;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}a{background:transparent}a:focus{outline:thin dotted}a:active,a:hover{outline:0}h1{font-size:2em;margin:.67em 0}abbr[title]{border-bottom:1px dotted}b,strong{font-weight:bold}dfn{font-style:italic}hr{-moz-box-sizing:content-box;box-sizing:content-box;height:0}mark{background:#ff0;color:#000}code,kbd,pre,samp{font-family:monospace,serif;font-size:1em}pre{white-space:pre-wrap}q{quotes:"\201C" "\201D" "\2018" "\2019"}small{font-size:80%}sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}sup{top:-0.5em}sub{bottom:-0.25em}img{border:0}svg:not(:root){overflow:hidden}figure{margin:0}fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}legend{border:0;padding:0}button,input,select,textarea{font-family:inherit;font-size:100%;margin:0}button,input{line-height:normal}button,select{text-transform:none}button,html input[type="button"],input[type="reset"],input[type="submit"]{-webkit-appearance:button;cursor:pointer}button[disabled],html input[disabled]{cursor:default}input[type="checkbox"],input[type="radio"]{box-sizing:border-box;padding:0}input[type="search"]{-webkit-appearance:textfield;-moz-box-sizing:content-box;-webkit-box-sizing:content-box;box-sizing:content-box}input[type="search"]::-webkit-search-cancel-button,input[type="search"]::-webkit-search-decoration{-webkit-appearance:none}button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}textarea{overflow:auto;vertical-align:top}table{border-collapse:collapse;border-spacing:0}*,*::before,*::after{box-sizing:border-box;margin:0}body{font-family:Helvetica,Arial,sans-serif;font-size:16px;color:#222;line-height:1.5;max-width:55em;margin:0 auto}#content,#footnotes{padding-left:.5em;padding-right:.5em}strong{font-weight:bold}em{font-style:italic}:not(pre)>code{font-family:Courier,monospace;line-height:1.0}a{color:#0061c5;text-decoration:none}a:hover{text-decoration:underline}hr{border-width:0 0 1px 0;border-style:solid;border-color:#678}ul,ol{list-style-position:outside;padding-left:0;margin-left:2em}ul li ul,ul li ol,ol li ul,ol li ol{margin-left:1.414em}ul>li{list-style-type:square;font-size:80%}ul>li>*{font-size:125%}ol>li{font-weight:bold}ol>li>*{font-weight:normal}ol.arabic{list-style-type:decimal}ol.decimal{list-style-type:decimal-leading-zero}ol.loweralpha{list-style-type:lower-alpha}ol.upperalpha{list-style-type:upper-alpha}ol.lowerroman{list-style-type:lower-roman}ol.upperroman{list-style-type:upper-roman}ol.lowergreek{list-style-type:lower-greek}.dlist dt{color:#325d72;font-weight:bold}.dlist dt:not(:first-child){margin-top:1em}.dlist dd{margin-left:2em}td.hdlist1{color:#325d72;padding-right:.5em;vertical-align:top}td.hdlist2{padding-bottom:.5em}h1{font-size:28px;font-weight:normal;letter-spacing:-1px;color:white;background-color:#325d72;text-align:center;margin:0 0 .5em 0;padding:.05em .5em}@media print{h1{color:#325d72;background-color:white;font-weight:bold}}h1::after{content:':';width:0;overflow:hidden;display:inline-block;vertical-align:middle}.author{color:#325d72}.email::before{content:"<";color:#325d72}.email::after{content:">";color:#325d72}.author+br,.email+br{display:none}#author{padding-left:.5em}#toc{margin:1em 0 2em 0;padding-left:.5em}#toctitle{font-size:19px;font-weight:bold;color:#325d72;margin:.5em 0}#toc>ul{line-height:1.4;font-size:15px;margin:0 0 0 .5em}#toc ul li{list-style-type:none}#toc li{margin:0}.big{font-size:120%}.small{font-size:75%}.underline{text-decoration:underline}.overline{text-decoration:overline}.line-through{text-decoration:line-through}.aqua{color:#00bfbf}.aqua-background{background-color:#00fafa;border-radius:2px;padding:0 3px}.black{color:"black"}.black-background{background-color:"black";border-radius:2px;padding:0 3px}.blue{color:#0000bf}.blue-background{background-color:#0000fa;border-radius:2px;padding:0 3px}.fuchsia{color:#bf00bf}.fuchsia-background{background-color:#fa00fa;border-radius:2px;padding:0 3px}.gray{color:#606060}.gray-background{background-color:#7d7d7d;border-radius:2px;padding:0 3px}.green{color:#006000}.green-background{background-color:#007d00;border-radius:2px;padding:0 3px}.lime{color:#00bf00}.lime-background{background-color:#00fa00;border-radius:2px;padding:0 3px}.maroon{color:#600000}.maroon-background{background-color:#7d0000;border-radius:2px;padding:0 3px}.navy{color:#000060}.navy-background{background-color:#00007d;border-radius:2px;padding:0 3px}.olive{color:#606000}.olive-background{background-color:#7d7d00;border-radius:2px;padding:0 3px}.purple{color:#600060}.purple-background{background-color:#7d007d;border-radius:2px;padding:0 3px}.red{color:#bf0000}.red-background{background-color:#fa0000;border-radius:2px;padding:0 3px}.silver{color:#909090}.silver-background{background-color:#bcbcbc;border-radius:2px;padding:0 3px}.teal{color:#006060}.teal-background{background-color:#007d7d;border-radius:2px;padding:0 3px}.white{color:#bfbfbf}.white-background{background-color:#fafafa;border-radius:2px;padding:0 3px}.yellow{color:#bfbf00}.yellow-background{background-color:#fafa00;border-radius:2px;padding:0 3px}table.tableblock{border:1px solid #91a7b3;margin-left:auto;margin-right:auto}table.tableblock>caption.title{text-align:left;margin-bottom:.5em}table.tableblock>colgroup>col{width:inherit !important}table.tableblock>tbody>tr>td{border-style:solid;border-color:#91a7b3;border-width:0 1px;padding:0 5px 2px 5px}table.tableblock>tbody>tr:nth-of-type(2n){background-color:#f3f5f7}p.tableblock{text-align:inherit}table.tableblock>thead>tr>td,table.tableblock>thead>tr>th,table.tableblock>tfoot>tr>td,table.tableblock>tfoot>tr>th{color:#325d72;font-weight:bold;line-height:1.35;padding:2px 5px;border:1px solid #91a7b3}table.tableblock>thead>tr>th,table.tableblock>thead>tr>td{border-bottom-width:2px}table.tableblock>tfoot>tr>th,table.tableblock>tfoot>tr>td{border-top-width:2px}th.halign-left,td.halign-left{text-align:left}th.halign-right,td.halign-right{text-align:right}th.halign-center,td.halign-center{text-align:center}th.valign-top,td.valign-top{vertical-align:top}th.valign-bottom,td.valign-bottom{vertical-align:bottom}th.valign-middle,td.valign-middle{vertical-align:middle}div.listingblock{padding:.5em;border-style:solid;border-color:#678;border-width:0 0 0 2px;background-color:#f3f5f7;overflow:auto}div.listingblock .title{text-align:right}div.listingblock pre{font-family:Menlo,Consolas,Monaco,"Lucida Console",monospace;font-size:87.5%;white-space:pre;background-color:#f3f5f7 !important;margin:0}div.listingblock td.linenos{border-right:1px solid #91a7b3;padding-right:.67em}div.listingblock table.pyhltable div.linenodiv{color:#678;text-align:right}div.listingblock table.pyhltable td.code{padding-left:.67em}div.imageblock>div.content>img{max-width:98%}.text-indent{padding-left:2em}img.inlinemath{image-rendering:optimizequality;margin-top:.5ex}h2,h3,h4{font-weight:normal;color:#325d72;margin:0}h2{font-size:27px;letter-spacing:-1px;border-bottom:1px solid #91a7b3}h3{font-size:24px;letter-spacing:-0.75px}h4{font-size:21px;letter-spacing:-0.5px}.title{color:#325d72;font-weight:bold}#footer{font-size:80%;color:white;background-color:#325d72}@media print{#footer{color:#325d72;background-color:white;font-weight:bold}}#footer-text{text-align:center;padding:.5em}#footer-badges{display:none}span.footnote{vertical-align:super;font-size:80%}#footnotes>hr{display:none}#footnotes::before{display:block;border-bottom:1px solid #678;margin:.5em 0;content:"Notes";font-size:19px;font-weight:bold;color:#325d72}#footnotes .footnote{margin-left:.5em;font-size:15px}hr:not(:first-child){margin-top:1.5em}hr:not(:last-child){margin-bottom:1.5em}.imageblock:not(:last-child),.listingblock:not(:last-child),.tableblock:not(:last-child){margin-bottom:1em}p+*{margin-top:1em}.paragraph+*{margin-top:1em}p+.ulist,p+.olist,p+.dlist,p+.hdlist,.paragraph+.ulist,.paragraph+.olist,.paragraph+.dlist,.paragraph+.hdlist,.paragraph+.listingblock{margin-top:.5em !important}li *+.ulist,li *+.olist,li *+.dlist,li *+.hdlist{margin-top:.1em !important}.title:not(:first-child){margin-top:1.5em}.content+.title{margin-top:.5em !important}.title+*{margin-top:1.5em}.title+p,.title+.paragraph,.title+.ulist,.title+.olist,.title+.dlist,.title+.hdlist{margin-top:.5em !important}.ulist:not(:last-child){margin-bottom:1em}.olist:not(:last-child){margin-bottom:1em}li:not(:first-child){margin-top:.1em}.dlist:not(:last-child){margin-bottom:1em}.dlist:not(:first-child){margin-top:1em}.sect3:not(:last-child){margin-bottom:18px}.sect3:not(:first-child){margin-top:18px}h4:not(:last-child){margin-bottom:9px}.sect2:not(:last-child){margin-bottom:22px}.sect2:not(:first-child){margin-top:22px}h3:not(:last-child){margin-bottom:11px}.sect1:not(:last-child){margin-bottom:40px}.sect1:not(:first-child){margin-top:40px}#preamble:not(:last-child){margin-bottom:40px}h2:not(:last-child){margin-bottom:13px}#header:not(:last-child),#content:not(:last-child),#footnotes:not(:last-child){margin-bottom:2em}.text-left{text-align:left}.text-center{text-align:center}.text-right{text-align:right}
</style>
<style>
.listingblock .pygments .hll { background-color: #ffffcc }
.listingblock .pygments, .listingblock .pygments code { background: #f8f8f8; }
.listingblock .pygments .tok-c { color: #408080; font-style: italic } /* Comment */
.listingblock .pygments .tok-err { border: 1px solid #FF0000 } /* Error */
.listingblock .pygments .tok-k { color: #008000; font-weight: bold } /* Keyword */
.listingblock .pygments .tok-o { color: #666666 } /* Operator */
.listingblock .pygments .tok-ch { color: #408080; font-style: italic } /* Comment.Hashbang */
.listingblock .pygments .tok-cm { color: #408080; font-style: italic } /* Comment.Multiline */
.listingblock .pygments .tok-cp { color: #BC7A00 } /* Comment.Preproc */
.listingblock .pygments .tok-cpf { color: #408080; font-style: italic } /* Comment.PreprocFile */
.listingblock .pygments .tok-c1 { color: #408080; font-style: italic } /* Comment.Single */
.listingblock .pygments .tok-cs { color: #408080; font-style: italic } /* Comment.Special */
.listingblock .pygments .tok-gd { color: #A00000 } /* Generic.Deleted */
.listingblock .pygments .tok-ge { font-style: italic } /* Generic.Emph */
.listingblock .pygments .tok-gr { color: #FF0000 } /* Generic.Error */
.listingblock .pygments .tok-gh { color: #000080; font-weight: bold } /* Generic.Heading */
.listingblock .pygments .tok-gi { color: #00A000 } /* Generic.Inserted */
.listingblock .pygments .tok-go { color: #888888 } /* Generic.Output */
.listingblock .pygments .tok-gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.listingblock .pygments .tok-gs { font-weight: bold } /* Generic.Strong */
.listingblock .pygments .tok-gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.listingblock .pygments .tok-gt { color: #0044DD } /* Generic.Traceback */
.listingblock .pygments .tok-kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.listingblock .pygments .tok-kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.listingblock .pygments .tok-kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.listingblock .pygments .tok-kp { color: #008000 } /* Keyword.Pseudo */
.listingblock .pygments .tok-kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.listingblock .pygments .tok-kt { color: #B00040 } /* Keyword.Type */
.listingblock .pygments .tok-m { color: #666666 } /* Literal.Number */
.listingblock .pygments .tok-s { color: #BA2121 } /* Literal.String */
.listingblock .pygments .tok-na { color: #7D9029 } /* Name.Attribute */
.listingblock .pygments .tok-nb { color: #008000 } /* Name.Builtin */
.listingblock .pygments .tok-nc { color: #0000FF; font-weight: bold } /* Name.Class */
.listingblock .pygments .tok-no { color: #880000 } /* Name.Constant */
.listingblock .pygments .tok-nd { color: #AA22FF } /* Name.Decorator */
.listingblock .pygments .tok-ni { color: #999999; font-weight: bold } /* Name.Entity */
.listingblock .pygments .tok-ne { color: #D2413A; font-weight: bold } /* Name.Exception */
.listingblock .pygments .tok-nf { color: #0000FF } /* Name.Function */
.listingblock .pygments .tok-nl { color: #A0A000 } /* Name.Label */
.listingblock .pygments .tok-nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
.listingblock .pygments .tok-nt { color: #008000; font-weight: bold } /* Name.Tag */
.listingblock .pygments .tok-nv { color: #19177C } /* Name.Variable */
.listingblock .pygments .tok-ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
.listingblock .pygments .tok-w { color: #bbbbbb } /* Text.Whitespace */
.listingblock .pygments .tok-mb { color: #666666 } /* Literal.Number.Bin */
.listingblock .pygments .tok-mf { color: #666666 } /* Literal.Number.Float */
.listingblock .pygments .tok-mh { color: #666666 } /* Literal.Number.Hex */
.listingblock .pygments .tok-mi { color: #666666 } /* Literal.Number.Integer */
.listingblock .pygments .tok-mo { color: #666666 } /* Literal.Number.Oct */
.listingblock .pygments .tok-sa { color: #BA2121 } /* Literal.String.Affix */
.listingblock .pygments .tok-sb { color: #BA2121 } /* Literal.String.Backtick */
.listingblock .pygments .tok-sc { color: #BA2121 } /* Literal.String.Char */
.listingblock .pygments .tok-dl { color: #BA2121 } /* Literal.String.Delimiter */
.listingblock .pygments .tok-sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.listingblock .pygments .tok-s2 { color: #BA2121 } /* Literal.String.Double */
.listingblock .pygments .tok-se { color: #BB6622; font-weight: bold } /* Literal.String.Escape */
.listingblock .pygments .tok-sh { color: #BA2121 } /* Literal.String.Heredoc */
.listingblock .pygments .tok-si { color: #BB6688; font-weight: bold } /* Literal.String.Interpol */
.listingblock .pygments .tok-sx { color: #008000 } /* Literal.String.Other */
.listingblock .pygments .tok-sr { color: #BB6688 } /* Literal.String.Regex */
.listingblock .pygments .tok-s1 { color: #BA2121 } /* Literal.String.Single */
.listingblock .pygments .tok-ss { color: #19177C } /* Literal.String.Symbol */
.listingblock .pygments .tok-bp { color: #008000 } /* Name.Builtin.Pseudo */
.listingblock .pygments .tok-fm { color: #0000FF } /* Name.Function.Magic */
.listingblock .pygments .tok-vc { color: #19177C } /* Name.Variable.Class */
.listingblock .pygments .tok-vg { color: #19177C } /* Name.Variable.Global */
.listingblock .pygments .tok-vi { color: #19177C } /* Name.Variable.Instance */
.listingblock .pygments .tok-vm { color: #19177C } /* Name.Variable.Magic */
.listingblock .pygments .tok-il { color: #666666 } /* Literal.Number.Integer.Long */
</style>
</head>
<body class="article">
<div id="header">
<h1>Rationale behind Boyer-Moore algorithm</h1>
</div>
<div id="content">
<div class="paragraph">
<p>Andrei Gudkov &lt;<a href="mailto:gudokk@gmail.com">gudokk@gmail.com</a>&gt;</p>
</div>
<div class="paragraph">
<p>Searching for the first occurrence of a substring in a string is a well-studied problem.
A variety of methods were developed to solve it, including "algorithmically
oriented" methods and also brute-force methods utilizing special CPU instructions
(e.g. x86-64 <a href="https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=pcmpestr">pcmpestri</a>).
It is commonly stated that Boyer-Moore algorithm (BM) is the most efficient
algorithm in general.
This is particularly true if the goal is to search for a substring in a <em>huge</em>
volume of data, so that some time may be invested in substring preprocessing
before starting the search without noticeable reduction in performance.
In this article I will try to gradually explain what makes BM so good.
I expect that reader has at least superficial knowledge of the classical <code>strstr()</code> algorithms.</p>
</div>
<div class="paragraph">
<p>The problem is stated as following: we need to find first position
of some given substring ("pattern", P) inside text T,
or return -1 if P is not found in T.
Lengths of the pattern and the text are |P| and |T| respectively.
All characters belong to an alphabet A of cardinality |A|.</p>
</div>
<div class="paragraph">
<div class="title">1. Left-to-right vs right-to-left</div>
<p>Substring search algorithms can be roughly classified by the order they use
to compare characters of the pattern, such as left-to-right (L2R for short, e.g. KMP),
right-to-left (R2L, e.g. BM) or even from the middle of the pattern
(e.g. <a href="http://www-igm.univ-mlv.fr/~lecroq/string/node26.html">Two Way algorithm</a>).
Intuitively it should be easy to understand that right-to-left (R2L) algorithms
are the most efficient.
The reason for this is that they may produce much longer shifts in general
after comparing only small number of characters.</p>
</div>
<div class="paragraph">
<p>To demonstrate this, let&#8217;s imagine artificial case when characters
of the pattern do not occur in text.
If we are to search such pattern left-to-right, then every shift
would be exactly of length one, resulting in O(|T|) comparisons in total.
We align pattern with the beginning of the text, then we compare
first character of the pattern with respective character of the text,
understand that they do not match, next we shift pattern to the right by one,
and then repeat this process all over again until end of text is reached.
The fact that the first character of the pattern doesn&#8217;t match the respective
character of the text doesn&#8217;t produce any additional useful information.
We will have to shift the pattern every time by 1.
However, if we are searching right-to-left, then pattern is shifted
by |P| every time.
After hitting mismatch on the right-most pattern character,
we immediately come to the conclusion that all shorter shifts are of no use
because the observed character in the text is not present in the pattern at all.
The shortest shift that makes sense is |P|.
Thus right-to-left algorithms demonstrates O(|T|/|P|) comparisons at best.</p>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="l2r-vs-r2l.svg" alt="l2r vs r2l" width="90%">
</div>
</div>
<div class="paragraph">
<p>In general case, when there are no artificial limitations as above,
difference in efficiency of L2R and R2L algorithms is not so dramatic:
L2R algorithm may produce longer than one shifts after successfully comparing
couple of characters and eventually hitting mismatch,
while R2L may produce shifts shorter than the pattern length |P|.
However, L2R is never able to produce such long shift after comparing only single character
as demonstrated above.
Typically the longer the pattern, the larger the benefits of R2L over L2R are.</p>
</div>
<div class="paragraph">
<div class="title">2. Baseline right-to-left algorithm</div>
<p>Now we will construct straightforward but efficient algorithm in the R2L family.
Let&#8217;s align pattern with text and perform comparisons right-to-left
while respective characters match.
Either all of the pattern characters match and we have an answer, or,
most likely, we will hit mismatch at some point.
This means that current alignment of the pattern with the text cannot be the answer
and we need to shift the pattern to the right to the next possible match.
How long would be the shift?
At this point we know the following:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><img src="math-148de9c5a7a44d19.svg" class="inlinemath" style="height:1.281ex;vertical-align:-0.391ex;" alt="p"/>&#8201;&#8212;&#8201;the length of the matched suffix.
Note that we don&#8217;t need to memorize the actual characters because we can
always figure them out from the pattern P, which we keep in RAM.</p>
</li>
<li>
<p><img src="math-2e7d2c03a9507ae2.svg" class="inlinemath" style="height:0.906ex;vertical-align:-0.016ex;" alt="c"/>&#8201;&#8212;&#8201;character of the text that caused mismatch</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>This is all information that we have.
We can write current state as the pair <img src="math-84eeafaed1ead774.svg" class="inlinemath" style="height:1.734ex;vertical-align:-0.391ex;" alt="(p,c)"/>, where <img src="math-36fb895c8c604740.svg" class="inlinemath" style="height:2.0ex;vertical-align:-0.5ex;" alt="p\in\lbrack0\,..\,\lvert\mathrm{P}\rvert{-}1\rbrack"/>
and <img src="math-2e7d2c03a9507ae2.svg" class="inlinemath" style="height:0.906ex;vertical-align:-0.016ex;" alt="c"/> is one of the characters of the alphabet, which usually consists of all one-byte
characters: <img src="math-dfefcd4be01bde4c.svg" class="inlinemath" style="height:1.719ex;vertical-align:-0.328ex;" alt="c\in\left\lbrack0\,..\,255\right\rbrack"/>.</p>
</div>
<div class="paragraph">
<p>To compute the longest shift, imagine the string
<img src="math-41d4ec5bbe4c0d36.svg" class="inlinemath" style="height:2.0ex;vertical-align:-0.5ex;" alt="
  \mathrm{S}=(c,\;
    \mathrm{P}\lbrack\lvert\mathrm{P}\rvert{-}p\rbrack,\;
    ..,\;
    \mathrm{P}\lbrack\lvert\mathrm{P}\rvert{-}2\rbrack,\;
    \mathrm{P}\lbrack\lvert\mathrm{P}\rvert{-}1\rbrack
  )
"/>,
i.e. this is the actual string we observed in the text and which is not the suffix
of the pattern (which we hoped for) because of <img src="math-2e7d2c03a9507ae2.svg" class="inlinemath" style="height:0.906ex;vertical-align:-0.016ex;" alt="c"/>.
Since it doesn&#8217;t match the end of the pattern, let&#8217;s search for
the right-most occurrence of this string in the pattern.
If we found such occurrence, good, this gives us next possible shift and
we can restart the matching process.
Example below demonstrates the pattern "bragracadabra".
Here we observed the string "gra" in the text that is not the suffix
of the pattern.
But we found the string "gra" inside the pattern itself, so we shifted
the pattern to the right by 7 characters to align pattern&#8217;s rightmost "gra"
with the text&#8217;s "gra".
Next step is to match newly aligned pattern all over again from the last character.</p>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="match-full.svg" alt="match full" width="90%">
</div>
</div>
<div class="paragraph">
<p>If, however, the string
<img src="math-41d4ec5bbe4c0d36.svg" class="inlinemath" style="height:2.0ex;vertical-align:-0.5ex;" alt="
  \mathrm{S}=(c,\;
    \mathrm{P}\lbrack\lvert\mathrm{P}\rvert{-}p\rbrack,\;
    ..,\;
    \mathrm{P}\lbrack\lvert\mathrm{P}\rvert{-}2\rbrack,\;
    \mathrm{P}\lbrack\lvert\mathrm{P}\rvert{-}1\rbrack
  )
"/> cannot be found anywhere in the pattern in full,
let&#8217;s try to align the pattern in such way that its beginning is also the ending of S.
If there are multiple such alignments, we need to choose the longest matching sequence
(corresponding to the shortest shift) in order not to miss possible answer.
In the example below, we hit mismatch when comparing 'a' with 'u'.
Now we need to find string S="ubra" inside the pattern, but there is no such string occurs.
The shortest shift of interest is to align the pattern so that the prefix "bra"
of the pattern matches the same sequence of characters in the text:</p>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="match-partial.svg" alt="match partial" width="90%">
</div>
</div>
<div class="paragraph">
<p>In the best case, when neither of the above two cases produce a shift,
the smallest possible shift is by the whole pattern length |P|:</p>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="match-none.svg" alt="match none" width="90%">
</div>
</div>
<div class="paragraph">
<p>Working with pattern every time we hit mismatch is not very efficient.
But since the number of possible mismatch states is fixed at |A|x|P|,
we can precompute all possible shifts into lookup table (LUT).
For example, for the pattern "bragracadabra", <code>lut['g'][2]=7</code> means that
in a situation when 2 pattern characters matched successfully and the next character
of the text ('g') mismatched (S="gra"), we shift pattern by 7 characters and
start matching all over again.</p>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="bragracadabra.svg" alt="bragracadabra" width="35%">
</div>
</div>
<table class="tableblock frame-all grid-all" style="width: 1%;">
<colgroup>
<col style="width: 7.1428%;">
<col style="width: 7.1428%;">
<col style="width: 7.1428%;">
<col style="width: 7.1428%;">
<col style="width: 7.1428%;">
<col style="width: 7.1428%;">
<col style="width: 7.1428%;">
<col style="width: 7.1428%;">
<col style="width: 7.1428%;">
<col style="width: 7.1428%;">
<col style="width: 7.1428%;">
<col style="width: 7.1428%;">
<col style="width: 7.1428%;">
<col style="width: 7.1436%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-right valign-top"></th>
<th class="tableblock halign-right valign-top">0</th>
<th class="tableblock halign-right valign-top">1</th>
<th class="tableblock halign-right valign-top">2</th>
<th class="tableblock halign-right valign-top">3</th>
<th class="tableblock halign-right valign-top">4</th>
<th class="tableblock halign-right valign-top">5</th>
<th class="tableblock halign-right valign-top">6</th>
<th class="tableblock halign-right valign-top">7</th>
<th class="tableblock halign-right valign-top">8</th>
<th class="tableblock halign-right valign-top">9</th>
<th class="tableblock halign-right valign-top">10</th>
<th class="tableblock halign-right valign-top">11</th>
<th class="tableblock halign-right valign-top">12</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-right valign-top"><p class="tableblock"><strong>&#8230;&#8203;</strong></p></td>
<td class="tableblock halign-right valign-top"></td>
<td class="tableblock halign-right valign-top"></td>
<td class="tableblock halign-right valign-top"></td>
<td class="tableblock halign-right valign-top"></td>
<td class="tableblock halign-right valign-top"></td>
<td class="tableblock halign-right valign-top"></td>
<td class="tableblock halign-right valign-top"></td>
<td class="tableblock halign-right valign-top"></td>
<td class="tableblock halign-right valign-top"></td>
<td class="tableblock halign-right valign-top"></td>
<td class="tableblock halign-right valign-top"></td>
<td class="tableblock halign-right valign-top"></td>
<td class="tableblock halign-right valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-right valign-top"><p class="tableblock"><strong>a</strong></p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock">&mdash;</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock">13</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock">13</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock">&mdash;</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock">10</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock">&mdash;</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock">10</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock">&mdash;</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock">10</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock">10</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock">&mdash;</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock">10</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock">10</p></td>
</tr>
<tr>
<td class="tableblock halign-right valign-top"><p class="tableblock"><strong>b</strong></p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock">13</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock">&mdash;</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock">10</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock">10</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock">10</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock">10</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock">10</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock">10</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock">10</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock">10</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock">10</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock">&mdash;</p></td>
</tr>
<tr>
<td class="tableblock halign-right valign-top"><p class="tableblock"><strong>c</strong></p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock">6</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock">5</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock">13</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock">10</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock">10</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock">10</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock">&mdash;</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock">10</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock">10</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock">10</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock">10</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock">10</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock">10</p></td>
</tr>
<tr>
<td class="tableblock halign-right valign-top"><p class="tableblock"><strong>d</strong></p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock">4</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock">3</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock">13</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock">10</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock">&mdash;</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock">10</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock">10</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock">10</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock">10</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock">10</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock">10</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock">10</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock">10</p></td>
</tr>
<tr>
<td class="tableblock halign-right valign-top"><p class="tableblock"><strong>e</strong></p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock">13</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock">13</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock">13</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock">10</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock">10</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock">10</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock">10</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock">10</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock">10</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock">10</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock">10</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock">10</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock">10</p></td>
</tr>
<tr>
<td class="tableblock halign-right valign-top"><p class="tableblock"><strong>g</strong></p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock">9</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock">13</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock">7</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock">10</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock">10</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock">10</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock">10</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock">10</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock">10</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock">&mdash;</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock">10</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock">10</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock">10</p></td>
</tr>
<tr>
<td class="tableblock halign-right valign-top"><p class="tableblock"><strong>r</strong></p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock">&mdash;</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock">13</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock">10</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock">10</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock">10</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock">10</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock">10</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock">&mdash;</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock">10</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock">10</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock">&mdash;</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock">10</p></td>
</tr>
<tr>
<td class="tableblock halign-right valign-top"><p class="tableblock"><strong>u</strong></p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock">13</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock">13</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock">13</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock">10</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock">10</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock">10</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock">10</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock">10</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock">10</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock">10</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock">10</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock">10</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock">10</p></td>
</tr>
<tr>
<td class="tableblock halign-right valign-top"><p class="tableblock"><strong>&#8230;&#8203;</strong></p></td>
<td class="tableblock halign-right valign-top"></td>
<td class="tableblock halign-right valign-top"></td>
<td class="tableblock halign-right valign-top"></td>
<td class="tableblock halign-right valign-top"></td>
<td class="tableblock halign-right valign-top"></td>
<td class="tableblock halign-right valign-top"></td>
<td class="tableblock halign-right valign-top"></td>
<td class="tableblock halign-right valign-top"></td>
<td class="tableblock halign-right valign-top"></td>
<td class="tableblock halign-right valign-top"></td>
<td class="tableblock halign-right valign-top"></td>
<td class="tableblock halign-right valign-top"></td>
<td class="tableblock halign-right valign-top"></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>When the goal is to search for a substring in a huge dataset that is
thousands or, even better, millions of times larger than the pattern,
performance of the preprocessing stage is of no importance,
and any simple algorithm to fill in the table may be used.
Examples of such applications would be "Find" tool in a browser
(searching for a substring in a very long PDF document)
or database query engine (apply predicate <code>WHERE name CONTAINS "abc"</code> in
a collection of millions of strings).
However, when text size is small or prior knowledge of lengths
of pattern and text is not known (e.g. implementing canonical
libc <code>strstr()</code> function), preprocessing step becomes a bottleneck
and should be carefully implemented.
Good implementation of preprocessing is not simple and is out of scope
of this article.</p>
</div>
<div class="paragraph">
<p>After LUT has been constructed, matching algorithm is simple to implement:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="java"><table class="pyhltable"><tr><td class="linenos"><div class="linenodiv"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19</div></td><td class="code"><span></span><span class="tok-kt">int</span> <span class="tok-nf">strstr</span><span class="tok-o">(</span><span class="tok-n">String</span> <span class="tok-n">pattern</span><span class="tok-o">,</span> <span class="tok-n">String</span> <span class="tok-n">text</span><span class="tok-o">)</span> <span class="tok-o">{</span>
  <span class="tok-kt">int</span><span class="tok-o">[][]</span> <span class="tok-n">table</span> <span class="tok-o">=</span> <span class="tok-n">build_table</span><span class="tok-o">(</span><span class="tok-n">pattern</span><span class="tok-o">);</span> <span class="tok-c1">// table[c][p] =&gt; shift</span>

  <span class="tok-kt">int</span> <span class="tok-n">offset</span> <span class="tok-o">=</span> <span class="tok-mi">0</span><span class="tok-o">;</span>
  <span class="tok-n">outer</span><span class="tok-o">:</span>
  <span class="tok-k">while</span> <span class="tok-o">(</span><span class="tok-n">offset</span> <span class="tok-o">&lt;=</span> <span class="tok-n">text</span><span class="tok-o">.</span><span class="tok-na">length</span><span class="tok-o">()</span> <span class="tok-o">-</span> <span class="tok-n">pattern</span><span class="tok-o">.</span><span class="tok-na">length</span><span class="tok-o">())</span> <span class="tok-o">{</span>
    <span class="tok-k">for</span> <span class="tok-o">(</span><span class="tok-kt">int</span> <span class="tok-n">i</span> <span class="tok-o">=</span> <span class="tok-n">pattern</span><span class="tok-o">.</span><span class="tok-na">length</span><span class="tok-o">()</span> <span class="tok-o">-</span> <span class="tok-mi">1</span><span class="tok-o">;</span> <span class="tok-n">i</span> <span class="tok-o">&gt;=</span> <span class="tok-mi">0</span><span class="tok-o">;</span> <span class="tok-n">i</span><span class="tok-o">--)</span> <span class="tok-o">{</span>
      <span class="tok-k">if</span> <span class="tok-o">(</span><span class="tok-n">text</span><span class="tok-o">[</span><span class="tok-n">offset</span><span class="tok-o">+</span><span class="tok-n">i</span><span class="tok-o">]</span> <span class="tok-o">!=</span> <span class="tok-n">pattern</span><span class="tok-o">[</span><span class="tok-n">i</span><span class="tok-o">])</span> <span class="tok-o">{</span>
        <span class="tok-kt">char</span> <span class="tok-n">c</span> <span class="tok-o">=</span> <span class="tok-n">text</span><span class="tok-o">[</span><span class="tok-n">offset</span><span class="tok-o">+</span><span class="tok-n">i</span><span class="tok-o">];</span> <span class="tok-c1">// mismatched character</span>
        <span class="tok-kt">int</span> <span class="tok-n">p</span> <span class="tok-o">=</span> <span class="tok-n">pattern</span><span class="tok-o">.</span><span class="tok-na">length</span><span class="tok-o">()</span> <span class="tok-o">-</span> <span class="tok-n">i</span> <span class="tok-o">-</span> <span class="tok-mi">1</span><span class="tok-o">;</span> <span class="tok-c1">// length of the matched suffix</span>
        <span class="tok-n">offset</span> <span class="tok-o">+=</span> <span class="tok-n">table</span><span class="tok-o">[</span><span class="tok-n">c</span><span class="tok-o">][</span><span class="tok-n">p</span><span class="tok-o">];</span>
        <span class="tok-k">goto</span> <span class="tok-n">outer</span><span class="tok-o">;</span>
      <span class="tok-o">}</span>
    <span class="tok-o">}</span>
    <span class="tok-k">return</span> <span class="tok-n">offset</span><span class="tok-o">;</span>
  <span class="tok-o">}</span>

  <span class="tok-k">return</span> <span class="tok-o">-</span><span class="tok-mi">1</span><span class="tok-o">;</span>
<span class="tok-o">}</span>
</td></tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>Above algorithm is one the most efficient among all algorithms which
perform comparisons right-to-left and is very natural at the same time.
But why "one of the most"?
It still has a flaw: it drops all accumulated information after making a shift
and starts comparing characters all over again.
Or, in another words, matching "sessions" are independent and do not
carry information from one to another.
This is the trait shared between all applied substring search algorithms,
including BM, KMP and naive O(|P|*|T|) algorithm.
To demonstrate the case, recall one of the previous examples.
The sequence "bra" from the text will be compared twice: first time during the original&#8201;&#8212;&#8201;unsuccessful&#8201;&#8212;&#8201;alignment and second time during the second&#8201;&#8212;&#8201;successful&#8201;&#8212;&#8201;alignment.</p>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="compare-twice.svg" alt="compare twice" width="90%">
</div>
</div>
<div class="paragraph">
<div class="title">3. Issues with the above algorithm</div>
<p>The algorithm constructed above is very natural and, at first glance,
algorithmically fast.
However, it has two issues making it impractical.
Both issues are caused by the too large LUT size.</p>
</div>
<div class="paragraph">
<p>The first issue was already discussed earlier: because of large
number of LUT entries, preprocessing takes too much time.
This pushes minimal volume of data to make this algorithm worse of using
to enormously high values, like hundreds of kilobytes.
While it is still a good choice for large-scale processing (database engines),
it is of no use for solving ad-hoc <code>strstr()</code> problems.
You do not want to spend on preprocessing 100x time than actual search would take.</p>
</div>
<div class="paragraph">
<p>The second issue relates to hardware.
Large LUTs are not cache-friendly.
For example, if pattern consists of 32 single-byte characters,
then table size is
256 <span class="small">[alphabet size]</span> * 32 <span class="small">[pattern length]</span> * (32/8) <span class="small">[bytes/entry]</span> = 32 KiB.
Such LUT would occupy entire L1d cache!
OK, I acknowledge that this may be an overestimation.
Typically not all of the characters of the alphabet are present in the text.
For example, for ASCII text, characters with codes above 127 most likely won&#8217;t
occur in text at all.
But even if only half of LUT is accessed often,
it is too huge to be efficiently cached.
Remember that search algorithm rarely works alone.
Input data must be retrieved from somewhere, possibly decompressed
and/or transformed in other ways.
All these pieces of code also compete for cache.
There are high chances that LUT entries will constantly flip back and forth
between being cached and evicted, thus decreasing cache efficiency.</p>
</div>
<div class="paragraph">
<div class="title">4. Fixing baseline algorithm</div>
<p>You can think of BM as of baseline algorithm with fixes for the above issues.
The idea of BM is to split single large LUT of size |A|x|P| into two much smaller,
independent LUTs of size |A| and |P| respectively.
These two tables are entirely independent and do not know anything about one another.</p>
</div>
<div class="paragraph">
<p>The first linear LUT of size |P| is used to implemented so-called "good suffix" heuristic.
For every suffix length <img src="math-148de9c5a7a44d19.svg" class="inlinemath" style="height:1.281ex;vertical-align:-0.391ex;" alt="p"/>, it returns the next possible shift,
but it doesn&#8217;t know anything about the character that caused mismatch.
It knows only the suffix length.
It is computed in the same way as the "big" LUT, but instead of computing shifts for every string
<img src="math-b258d3d504b404b4.svg" class="inlinemath" style="height:2.0ex;vertical-align:-0.5ex;" alt="
  (c,\;
    \mathrm{P}\lbrack\lvert\mathrm{P}\rvert{-}p\rbrack,\;
    ..,\;
    \mathrm{P}\lbrack\lvert\mathrm{P}\rvert{-}2\rbrack,\;
    \mathrm{P}\lbrack\lvert\mathrm{P}\rvert{-}1\rbrack
  )
"/> we need to compute shifts for every string
<img src="math-d88edf5a32919099.svg" class="inlinemath" style="height:2.0ex;vertical-align:-0.5ex;" alt="
  (
    \mathrm{P}\lbrack\lvert\mathrm{P}\rvert{-}p\rbrack,\;
    ..,\;
    \mathrm{P}\lbrack\lvert\mathrm{P}\rvert{-}2\rbrack,\;
    \mathrm{P}\lbrack\lvert\mathrm{P}\rvert{-}1\rbrack
  )
"/>.
In special case when <img src="math-96765f99ce46a7f7.svg" class="inlinemath" style="height:1.734ex;vertical-align:-0.391ex;" alt="p=0"/> table entry is set to 1, indicating minimal possible shift.</p>
</div>
<div class="paragraph">
<p>Another linear LUT of size |A| is used to implement "bad character" heuristic
and deals with character mismatches.
Given some alphabet character <img src="math-2e7d2c03a9507ae2.svg" class="inlinemath" style="height:0.906ex;vertical-align:-0.016ex;" alt="c"/>, it returns such shift that would align
pattern so that rightmost occurrence of the character <img src="math-2e7d2c03a9507ae2.svg" class="inlinemath" style="height:0.906ex;vertical-align:-0.016ex;" alt="c"/> in the pattern is strictly
under the text&#8217;s <img src="math-2e7d2c03a9507ae2.svg" class="inlinemath" style="height:0.906ex;vertical-align:-0.016ex;" alt="c"/>.
But it doesn&#8217;t know anything about how many characters matched successfully
before we hit mismatch.
To compute this table, we need just to find the positions of the right-most occurrences
of every character in alphabet.
When some character <img src="math-2e7d2c03a9507ae2.svg" class="inlinemath" style="height:0.906ex;vertical-align:-0.016ex;" alt="c"/> doesn&#8217;t occur in pattern, table entry is set to -1,
like if the character existed in pattern in position -1.
This allows to avoid conditional code in the matching function.</p>
</div>
<div class="paragraph">
<p>Such approach reduces table sizes from |A|*|P| down to |A|+|P| at the cost of slightly worse
theoretical performance (demonstrated a bit later).</p>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="bragracadabra.svg" alt="bragracadabra" width="35%">
</div>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 7.1428%;">
<col style="width: 7.1428%;">
<col style="width: 7.1428%;">
<col style="width: 7.1428%;">
<col style="width: 7.1428%;">
<col style="width: 7.1428%;">
<col style="width: 7.1428%;">
<col style="width: 7.1428%;">
<col style="width: 7.1428%;">
<col style="width: 7.1428%;">
<col style="width: 7.1428%;">
<col style="width: 7.1428%;">
<col style="width: 7.1428%;">
<col style="width: 7.1436%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">good suffix length</th>
<th class="tableblock halign-left valign-top">&nbsp;0</th>
<th class="tableblock halign-left valign-top">&nbsp;1</th>
<th class="tableblock halign-left valign-top">&nbsp;2</th>
<th class="tableblock halign-left valign-top">&nbsp;3</th>
<th class="tableblock halign-left valign-top">&nbsp;4</th>
<th class="tableblock halign-left valign-top">&nbsp;5</th>
<th class="tableblock halign-left valign-top">&nbsp;6</th>
<th class="tableblock halign-left valign-top">&nbsp;7</th>
<th class="tableblock halign-left valign-top">&nbsp;8</th>
<th class="tableblock halign-left valign-top">&nbsp;9</th>
<th class="tableblock halign-left valign-top">10</th>
<th class="tableblock halign-left valign-top">11</th>
<th class="tableblock halign-left valign-top">12</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">shift</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&nbsp;1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&nbsp;3</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&nbsp;7</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">10</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">10</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">10</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">10</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">10</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">10</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">10</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">10</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">10</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">10</p></td>
</tr>
</tbody>
</table>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 9.0909%;">
<col style="width: 9.0909%;">
<col style="width: 9.0909%;">
<col style="width: 9.0909%;">
<col style="width: 9.0909%;">
<col style="width: 9.0909%;">
<col style="width: 9.0909%;">
<col style="width: 9.0909%;">
<col style="width: 9.0909%;">
<col style="width: 9.0909%;">
<col style="width: 9.091%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">bad character</th>
<th class="tableblock halign-left valign-top"><strong>&#8230;&#8203;</strong></th>
<th class="tableblock halign-left valign-top">&nbsp;a</th>
<th class="tableblock halign-left valign-top">&nbsp;b</th>
<th class="tableblock halign-left valign-top">&nbsp;c</th>
<th class="tableblock halign-left valign-top">&nbsp;d</th>
<th class="tableblock halign-left valign-top">&nbsp;e</th>
<th class="tableblock halign-left valign-top">&nbsp;g</th>
<th class="tableblock halign-left valign-top">&nbsp;r</th>
<th class="tableblock halign-left valign-top">&nbsp;u</th>
<th class="tableblock halign-left valign-top"><strong>&#8230;&#8203;</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">right-most position</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&#8230;&#8203;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">12</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">10</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&nbsp;6</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&nbsp;8</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&nbsp;-1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&nbsp;3</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">11</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&nbsp;-1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&#8230;&#8203;</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Matching algorithm must be slightly modified.
As before, we align pattern and compare characters of the pattern right to left
until we hit mismatch.
When this has happened, we query both tables: matched suffix length is passed
to "good suffix" LUT, while mismatched character <img src="math-2e7d2c03a9507ae2.svg" class="inlinemath" style="height:0.906ex;vertical-align:-0.016ex;" alt="c"/> from the text
is passed to "bad character" LUT.
Effective shift is the maximum of the two shifts returned by these tables.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="java"><table class="pyhltable"><tr><td class="linenos"><div class="linenodiv"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26</div></td><td class="code"><span></span>
<span class="tok-kt">int</span> <span class="tok-nf">strstr</span><span class="tok-o">(</span><span class="tok-n">String</span> <span class="tok-n">pattern</span><span class="tok-o">,</span> <span class="tok-n">String</span> <span class="tok-n">text</span><span class="tok-o">)</span> <span class="tok-o">{</span>
  <span class="tok-c1">// good_suffix_table[p] =&gt; shift</span>
  <span class="tok-kt">int</span><span class="tok-o">[]</span> <span class="tok-n">good_suffix_table</span> <span class="tok-o">=</span> <span class="tok-n">build_good_suffix_table</span><span class="tok-o">(</span><span class="tok-n">pattern</span><span class="tok-o">);</span>
  <span class="tok-c1">// bad_character_table[c] =&gt; right-most position of c</span>
  <span class="tok-kt">int</span><span class="tok-o">[]</span> <span class="tok-n">bad_character_table</span> <span class="tok-o">=</span> <span class="tok-n">build_bad_character_table</span><span class="tok-o">(</span><span class="tok-n">pattern</span><span class="tok-o">);</span>

  <span class="tok-kt">int</span> <span class="tok-n">offset</span> <span class="tok-o">=</span> <span class="tok-mi">0</span><span class="tok-o">;</span>
  <span class="tok-n">outer</span><span class="tok-o">:</span>
  <span class="tok-k">while</span> <span class="tok-o">(</span><span class="tok-n">offset</span> <span class="tok-o">&lt;=</span> <span class="tok-n">text</span><span class="tok-o">.</span><span class="tok-na">length</span><span class="tok-o">()</span> <span class="tok-o">-</span> <span class="tok-n">pattern</span><span class="tok-o">.</span><span class="tok-na">length</span><span class="tok-o">())</span> <span class="tok-o">{</span>
    <span class="tok-k">for</span> <span class="tok-o">(</span><span class="tok-kt">int</span> <span class="tok-n">i</span> <span class="tok-o">=</span> <span class="tok-n">pattern</span><span class="tok-o">.</span><span class="tok-na">length</span><span class="tok-o">()</span> <span class="tok-o">-</span> <span class="tok-mi">1</span><span class="tok-o">;</span> <span class="tok-n">i</span> <span class="tok-o">&gt;=</span> <span class="tok-mi">0</span><span class="tok-o">;</span> <span class="tok-n">i</span><span class="tok-o">--)</span> <span class="tok-o">{</span>
      <span class="tok-k">if</span> <span class="tok-o">(</span><span class="tok-n">text</span><span class="tok-o">[</span><span class="tok-n">offset</span><span class="tok-o">+</span><span class="tok-n">i</span><span class="tok-o">]</span> <span class="tok-o">!=</span> <span class="tok-n">pattern</span><span class="tok-o">[</span><span class="tok-n">i</span><span class="tok-o">])</span> <span class="tok-o">{</span>
        <span class="tok-kt">char</span> <span class="tok-n">c</span> <span class="tok-o">=</span> <span class="tok-n">text</span><span class="tok-o">[</span><span class="tok-n">offset</span><span class="tok-o">+</span><span class="tok-n">i</span><span class="tok-o">];</span> <span class="tok-c1">// mismatched character</span>
        <span class="tok-kt">int</span> <span class="tok-n">p</span> <span class="tok-o">=</span> <span class="tok-n">pattern</span><span class="tok-o">.</span><span class="tok-na">length</span><span class="tok-o">()</span> <span class="tok-o">-</span> <span class="tok-n">i</span> <span class="tok-o">-</span> <span class="tok-mi">1</span><span class="tok-o">;</span> <span class="tok-c1">// length of the matched suffix</span>
        <span class="tok-n">offset</span> <span class="tok-o">+=</span> <span class="tok-n">Math</span><span class="tok-o">.</span><span class="tok-na">max</span><span class="tok-o">(</span>
          <span class="tok-n">good_suffix_table</span><span class="tok-o">[</span><span class="tok-n">p</span><span class="tok-o">],</span>
          <span class="tok-n">i</span> <span class="tok-o">-</span> <span class="tok-n">bad_character_table</span><span class="tok-o">[</span><span class="tok-n">c</span><span class="tok-o">]</span>
        <span class="tok-o">);</span>
        <span class="tok-k">goto</span> <span class="tok-n">outer</span><span class="tok-o">;</span>
      <span class="tok-o">}</span>
    <span class="tok-o">}</span>
    <span class="tok-k">return</span> <span class="tok-n">offset</span><span class="tok-o">;</span>
  <span class="tok-o">}</span>

  <span class="tok-k">return</span> <span class="tok-o">-</span><span class="tok-mi">1</span><span class="tok-o">;</span>
<span class="tok-o">}</span>
</td></tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<div class="title">5. Why does such simplification work well?</div>
<p>At first glance, decoupling composite state <img src="math-84eeafaed1ead774.svg" class="inlinemath" style="height:1.734ex;vertical-align:-0.391ex;" alt="(p,c)"/> into two independent
smaller states should lead to significant performance penalty.
However, in real-world applications it doesn&#8217;t do so.
The key observation is that at any given moment during the matching process
at least one of the tables produces long shift.</p>
</div>
<div class="paragraph">
<p>When we align pattern with the text and immediately hit mismatch,
matched suffix is of length 0, meaning that good suffix heuristic doesn&#8217;t
result in any meaningful shift at all.
Effective shift entirely comes from the bad character heuristic,
which at this moment works very well.
In the best case, when text character that caused mismatch cannot be found
anywhere in the pattern, the shift is of length |P|,
thus skipping large portion of the text.</p>
</div>
<div class="paragraph">
<p>However, bad character heuristic performs progressively poorer with increase
in matched length suffix.
Recall that bad character heuristic doesn&#8217;t know anything about the length of the
matched suffix.
Whether matched suffix is of length 0, of length 15, or of length 1000, it returns
the same shift: it will align the problematic character <img src="math-2e7d2c03a9507ae2.svg" class="inlinemath" style="height:0.906ex;vertical-align:-0.016ex;" alt="c"/> with its rightmost
occurrence in the pattern.
In worst case, when the character <img src="math-2e7d2c03a9507ae2.svg" class="inlinemath" style="height:0.906ex;vertical-align:-0.016ex;" alt="c"/> occurs somewhere in already matched suffix,
the shift is <em>negative</em> and is of no use to us.
To demonstrate, consider the following example.
We matched successfully the suffix "adabra", but failed at 'r'.
Bad character heuristic knows only one piece of information, the character 'r',
and instructs us to realign pattern so that rightmost occurrence of the 'r' in the pattern
is under currently observed 'r' in the text.
Because 'r' occurs in already matched suffix, this results in negative shift.</p>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="negative-shift.svg" alt="negative shift" width="90%">
</div>
</div>
<div class="paragraph">
<p>The good thing is that with the increase of the matched suffix length,
good suffix heuristic becomes more useful.
Indeed, the longer the matched suffix is, the less chances that it occurs anywhere
in the pattern again.
So, good suffix heuristic will produce long shifts in such cases.</p>
</div>
<div class="paragraph">
<p>Combined, two heuristics result in that no matter what matched suffix length is,
one or another of them produces long shift:</p>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="max-shift-graph.svg" alt="max shift graph" width="70%">
</div>
</div>
<div class="paragraph">
<p>Of course, there are still cases when neither of the two heuristics is able to produce
long shift, but their combination (as in the baseline algorithm) would do so.
In the example below, good suffix heuristic ("er") returns a shift of only 2,
while bad character heuristic ('e') returns negative shift.
Thus, we would shift only by two characters: not so great.
On the other hand, the combined LUT would produce a shift by the whole pattern (+12),
because neither "eer" occurs in the pattern, nor there is non-empty prefix in the
pattern that is also the suffix of "eer".
This is much better.</p>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="combined-better.svg" alt="combined better" width="90%">
</div>
</div>
<div class="paragraph">
<div class="title">6. Modifications</div>
<p>Vanilla BM is not the holy grail.
It can be freely modified to adjust it to a particular problem.
Depending on volume of data, alphabet cardinality, pattern length and hardware,
one or another modification may perform even better.
Here is a list of a few ideas to start with:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Use only bad character heuristic.
Preprocessing stage becomes very easy to code.</p>
</li>
<li>
<p>Use only good suffix heuristic.
This makes sense if alphabet cardinality is tiny,
because the same identical characters would appear multiple times in the pattern,
thus nullifying benefits of bad character heuristic.</p>
</li>
<li>
<p>Do not shift after first mismatch.
Instead, use additional heuristic based on the character immediately left
of the mismatched character, which may or may not mismatch.</p>
</li>
<li>
<p>Use baseline algorithm described in the beginning of the article.
You can control LUT size by using hashing: <code>shift = lut[hash(s*13+p) % desired_size]</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>However, BM demonstrated high efficiency in large variety of cases, which makes it
the first-choice <code>strstr()</code> algorithm even in situations when you do not
have prior knowledge of the data you will stream through it.</p>
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2019-08-29 09:52:49 UTC
</div>
</div>
</body>
</html>