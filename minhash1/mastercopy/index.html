<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]-->
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 1.5.4">
<meta name="author" content="Andrei Gudkov">
<title>Efficient implementation of MinHash, part 1</title>
<style>
/*! normalize.css v2.1.2 | MIT License | git.io/normalize */article,aside,details,figcaption,figure,footer,header,hgroup,main,nav,section,summary{display:block}audio,canvas,video{display:inline-block}audio:not([controls]){display:none;height:0}[hidden],template{display:none}script{display:none!important}html{font-family:sans-serif;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}a{background:transparent}a:focus{outline:thin dotted}a:active,a:hover{outline:0}h1{font-size:2em;margin:.67em 0}abbr[title]{border-bottom:1px dotted}b,strong{font-weight:bold}dfn{font-style:italic}hr{-moz-box-sizing:content-box;box-sizing:content-box;height:0}mark{background:#ff0;color:#000}code,kbd,pre,samp{font-family:monospace,serif;font-size:1em}pre{white-space:pre-wrap}q{quotes:"\201C" "\201D" "\2018" "\2019"}small{font-size:80%}sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}sup{top:-0.5em}sub{bottom:-0.25em}img{border:0}svg:not(:root){overflow:hidden}figure{margin:0}fieldset{border:1px solid #c0c0c0;margin:0 2px;padding:.35em .625em .75em}legend{border:0;padding:0}button,input,select,textarea{font-family:inherit;font-size:100%;margin:0}button,input{line-height:normal}button,select{text-transform:none}button,html input[type="button"],input[type="reset"],input[type="submit"]{-webkit-appearance:button;cursor:pointer}button[disabled],html input[disabled]{cursor:default}input[type="checkbox"],input[type="radio"]{box-sizing:border-box;padding:0}input[type="search"]{-webkit-appearance:textfield;-moz-box-sizing:content-box;-webkit-box-sizing:content-box;box-sizing:content-box}input[type="search"]::-webkit-search-cancel-button,input[type="search"]::-webkit-search-decoration{-webkit-appearance:none}button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}textarea{overflow:auto;vertical-align:top}table{border-collapse:collapse;border-spacing:0}*,*::before,*::after{box-sizing:border-box;margin:0}body{font-family:Helvetica,Arial,sans-serif;font-size:16px;color:#222;line-height:1.5;max-width:55em;margin:0 auto}#content,#footnotes{padding-left:.5em;padding-right:.5em}strong{font-weight:bold}em{font-style:italic}:not(pre)>code{font-family:Courier,monospace;line-height:1.0}a{color:#0061c5;text-decoration:none}a:hover{text-decoration:underline}hr{border-width:0 0 1px 0;border-style:solid;border-color:#678}ul,ol{list-style-position:outside;padding-left:0;margin-left:2em}ul li ul,ul li ol,ol li ul,ol li ol{margin-left:1.414em}ul>li{list-style-type:square;font-size:80%}ul>li>*{font-size:125%}ol>li{font-weight:bold}ol>li>*{font-weight:normal}ol.arabic{list-style-type:decimal}ol.decimal{list-style-type:decimal-leading-zero}ol.loweralpha{list-style-type:lower-alpha}ol.upperalpha{list-style-type:upper-alpha}ol.lowerroman{list-style-type:lower-roman}ol.upperroman{list-style-type:upper-roman}ol.lowergreek{list-style-type:lower-greek}.dlist dt{color:#325d72;font-weight:bold}.dlist dt:not(:first-child){margin-top:1em}.dlist dd{margin-left:2em}td.hdlist1{color:#325d72;padding-right:.5em;vertical-align:top}td.hdlist2{padding-bottom:.5em}h1{font-size:28px;font-weight:normal;letter-spacing:-1px;color:white;background-color:#325d72;text-align:center;margin:0 0 .5em 0;padding:.05em .5em}@media print{h1{color:#325d72;background-color:white;font-weight:bold}}h1::after{content:':';width:0;overflow:hidden;display:inline-block;vertical-align:middle}.author{color:#325d72}.email::before{content:"<";color:#325d72}.email::after{content:">";color:#325d72}.author+br,.email+br{display:none}#author{padding-left:.5em}#toc{margin:1em 0 2em 0;padding-left:.5em}#toctitle{font-size:19px;font-weight:bold;color:#325d72;margin:.5em 0}#toc>ul{line-height:1.4;font-size:15px;margin:0 0 0 .5em}#toc ul li{list-style-type:none}#toc li{margin:0}.big{font-size:120%}.small{font-size:75%}.underline{text-decoration:underline}.overline{text-decoration:overline}.line-through{text-decoration:line-through}.aqua{color:#00bfbf}.aqua-background{background-color:#00fafa;border-radius:2px;padding:0 3px}.black{color:"black"}.black-background{background-color:"black";border-radius:2px;padding:0 3px}.blue{color:#0000bf}.blue-background{background-color:#0000fa;border-radius:2px;padding:0 3px}.fuchsia{color:#bf00bf}.fuchsia-background{background-color:#fa00fa;border-radius:2px;padding:0 3px}.gray{color:#606060}.gray-background{background-color:#7d7d7d;border-radius:2px;padding:0 3px}.green{color:#006000}.green-background{background-color:#007d00;border-radius:2px;padding:0 3px}.lime{color:#00bf00}.lime-background{background-color:#00fa00;border-radius:2px;padding:0 3px}.maroon{color:#600000}.maroon-background{background-color:#7d0000;border-radius:2px;padding:0 3px}.navy{color:#000060}.navy-background{background-color:#00007d;border-radius:2px;padding:0 3px}.olive{color:#606000}.olive-background{background-color:#7d7d00;border-radius:2px;padding:0 3px}.purple{color:#600060}.purple-background{background-color:#7d007d;border-radius:2px;padding:0 3px}.red{color:#bf0000}.red-background{background-color:#fa0000;border-radius:2px;padding:0 3px}.silver{color:#909090}.silver-background{background-color:#bcbcbc;border-radius:2px;padding:0 3px}.teal{color:#006060}.teal-background{background-color:#007d7d;border-radius:2px;padding:0 3px}.white{color:#bfbfbf}.white-background{background-color:#fafafa;border-radius:2px;padding:0 3px}.yellow{color:#bfbf00}.yellow-background{background-color:#fafa00;border-radius:2px;padding:0 3px}table.tableblock{border:1px solid #91a7b3;margin-left:auto;margin-right:auto}table.tableblock>caption.title{text-align:left;margin-bottom:.5em}table.tableblock>colgroup>col{width:inherit!important}table.tableblock>tbody>tr>td{border-style:solid;border-color:#91a7b3;border-width:0 1px;padding:0 5px 2px 5px}table.tableblock>tbody>tr:nth-of-type(2n){background-color:#f3f5f7}p.tableblock{text-align:inherit}table.tableblock>thead>tr>td,table.tableblock>thead>tr>th,table.tableblock>tfoot>tr>td,table.tableblock>tfoot>tr>th{color:#325d72;font-weight:bold;line-height:1.35;padding:2px 5px;border:1px solid #91a7b3}table.tableblock>thead>tr>th,table.tableblock>thead>tr>td{border-bottom-width:2px}table.tableblock>tfoot>tr>th,table.tableblock>tfoot>tr>td{border-top-width:2px}th.halign-left,td.halign-left{text-align:left}th.halign-right,td.halign-right{text-align:right}th.halign-center,td.halign-center{text-align:center}th.valign-top,td.valign-top{vertical-align:top}th.valign-bottom,td.valign-bottom{vertical-align:bottom}th.valign-middle,td.valign-middle{vertical-align:middle}div.listingblock{padding:.5em;border-style:solid;border-color:#678;border-width:0 0 0 2px;background-color:#f3f5f7;overflow:auto}div.listingblock .title{text-align:right}div.listingblock pre{font-family:Menlo,Consolas,Monaco,"Lucida Console",monospace;font-size:87.5%;white-space:pre;background-color:#f3f5f7!important;margin:0}div.listingblock td.linenos{border-right:1px solid #91a7b3;padding-right:.67em}div.listingblock table.pyhltable div.linenodiv{color:#678;text-align:right}div.listingblock table.pyhltable td.code{padding-left:.67em}div.imageblock>div.content>img{max-width:98%}.text-indent{padding-left:2em}img.inlinemath{image-rendering:optimizequality;margin-top:.5ex}h2,h3,h4{font-weight:normal;color:#325d72;margin:0}h2{font-size:27px;letter-spacing:-1px;border-bottom:1px solid #91a7b3}h3{font-size:24px;letter-spacing:-0.75px}h4{font-size:21px;letter-spacing:-0.5px}.title{color:#325d72;font-weight:bold}#footer{font-size:80%;color:white;background-color:#325d72}@media print{#footer{color:#325d72;background-color:white;font-weight:bold}}#footer-text{text-align:center;padding:.5em}#footer-badges{display:none}span.footnote{vertical-align:super;font-size:80%}#footnotes>hr{display:none}#footnotes::before{display:block;border-bottom:1px solid #678;margin:.5em 0;content:"Notes";font-size:19px;font-weight:bold;color:#325d72}#footnotes .footnote{margin-left:.5em;font-size:15px}hr:not(:first-child){margin-top:1.5em}hr:not(:last-child){margin-bottom:1.5em}.imageblock:not(:last-child),.listingblock:not(:last-child),.tableblock:not(:last-child){margin-bottom:1em}p+*{margin-top:1em}.paragraph+*{margin-top:1em}p+.ulist,p+.olist,p+.dlist,p+.hdlist,.paragraph+.ulist,.paragraph+.olist,.paragraph+.dlist,.paragraph+.hdlist,.paragraph+.listingblock{margin-top:.5em!important}li *+.ulist,li *+.olist,li *+.dlist,li *+.hdlist{margin-top:.1em!important}.title:not(:first-child){margin-top:1.5em}.content+.title{margin-top:.5em!important}.title+*{margin-top:1.5em}.title+p,.title+.paragraph,.title+.ulist,.title+.olist,.title+.dlist,.title+.hdlist{margin-top:.5em!important}.ulist:not(:last-child){margin-bottom:1em}.olist:not(:last-child){margin-bottom:1em}li:not(:first-child){margin-top:.1em}.dlist:not(:last-child){margin-bottom:1em}.dlist:not(:first-child){margin-top:1em}.sect3:not(:last-child){margin-bottom:18px}.sect3:not(:first-child){margin-top:18px}h4:not(:last-child){margin-bottom:9px}.sect2:not(:last-child){margin-bottom:22px}.sect2:not(:first-child){margin-top:22px}h3:not(:last-child){margin-bottom:11px}.sect1:not(:last-child){margin-bottom:40px}.sect1:not(:first-child){margin-top:40px}#preamble:not(:last-child){margin-bottom:40px}h2:not(:last-child){margin-bottom:13px}#header:not(:last-child),#content:not(:last-child),#footnotes:not(:last-child){margin-bottom:2em}
</style>
<style>
.listingblock .pygments .hll { background-color: #ffffcc }
.listingblock .pygments  { background: #f8f8f8; }
.listingblock .pygments .tok-c { color: #408080; font-style: italic } /* Comment */
.listingblock .pygments .tok-err { border: 1px solid #FF0000 } /* Error */
.listingblock .pygments .tok-k { color: #008000; font-weight: bold } /* Keyword */
.listingblock .pygments .tok-o { color: #666666 } /* Operator */
.listingblock .pygments .tok-ch { color: #408080; font-style: italic } /* Comment.Hashbang */
.listingblock .pygments .tok-cm { color: #408080; font-style: italic } /* Comment.Multiline */
.listingblock .pygments .tok-cp { color: #BC7A00 } /* Comment.Preproc */
.listingblock .pygments .tok-cpf { color: #408080; font-style: italic } /* Comment.PreprocFile */
.listingblock .pygments .tok-c1 { color: #408080; font-style: italic } /* Comment.Single */
.listingblock .pygments .tok-cs { color: #408080; font-style: italic } /* Comment.Special */
.listingblock .pygments .tok-gd { color: #A00000 } /* Generic.Deleted */
.listingblock .pygments .tok-ge { font-style: italic } /* Generic.Emph */
.listingblock .pygments .tok-gr { color: #FF0000 } /* Generic.Error */
.listingblock .pygments .tok-gh { color: #000080; font-weight: bold } /* Generic.Heading */
.listingblock .pygments .tok-gi { color: #00A000 } /* Generic.Inserted */
.listingblock .pygments .tok-go { color: #888888 } /* Generic.Output */
.listingblock .pygments .tok-gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.listingblock .pygments .tok-gs { font-weight: bold } /* Generic.Strong */
.listingblock .pygments .tok-gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.listingblock .pygments .tok-gt { color: #0044DD } /* Generic.Traceback */
.listingblock .pygments .tok-kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.listingblock .pygments .tok-kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.listingblock .pygments .tok-kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.listingblock .pygments .tok-kp { color: #008000 } /* Keyword.Pseudo */
.listingblock .pygments .tok-kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.listingblock .pygments .tok-kt { color: #B00040 } /* Keyword.Type */
.listingblock .pygments .tok-m { color: #666666 } /* Literal.Number */
.listingblock .pygments .tok-s { color: #BA2121 } /* Literal.String */
.listingblock .pygments .tok-na { color: #7D9029 } /* Name.Attribute */
.listingblock .pygments .tok-nb { color: #008000 } /* Name.Builtin */
.listingblock .pygments .tok-nc { color: #0000FF; font-weight: bold } /* Name.Class */
.listingblock .pygments .tok-no { color: #880000 } /* Name.Constant */
.listingblock .pygments .tok-nd { color: #AA22FF } /* Name.Decorator */
.listingblock .pygments .tok-ni { color: #999999; font-weight: bold } /* Name.Entity */
.listingblock .pygments .tok-ne { color: #D2413A; font-weight: bold } /* Name.Exception */
.listingblock .pygments .tok-nf { color: #0000FF } /* Name.Function */
.listingblock .pygments .tok-nl { color: #A0A000 } /* Name.Label */
.listingblock .pygments .tok-nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
.listingblock .pygments .tok-nt { color: #008000; font-weight: bold } /* Name.Tag */
.listingblock .pygments .tok-nv { color: #19177C } /* Name.Variable */
.listingblock .pygments .tok-ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
.listingblock .pygments .tok-w { color: #bbbbbb } /* Text.Whitespace */
.listingblock .pygments .tok-mb { color: #666666 } /* Literal.Number.Bin */
.listingblock .pygments .tok-mf { color: #666666 } /* Literal.Number.Float */
.listingblock .pygments .tok-mh { color: #666666 } /* Literal.Number.Hex */
.listingblock .pygments .tok-mi { color: #666666 } /* Literal.Number.Integer */
.listingblock .pygments .tok-mo { color: #666666 } /* Literal.Number.Oct */
.listingblock .pygments .tok-sa { color: #BA2121 } /* Literal.String.Affix */
.listingblock .pygments .tok-sb { color: #BA2121 } /* Literal.String.Backtick */
.listingblock .pygments .tok-sc { color: #BA2121 } /* Literal.String.Char */
.listingblock .pygments .tok-dl { color: #BA2121 } /* Literal.String.Delimiter */
.listingblock .pygments .tok-sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.listingblock .pygments .tok-s2 { color: #BA2121 } /* Literal.String.Double */
.listingblock .pygments .tok-se { color: #BB6622; font-weight: bold } /* Literal.String.Escape */
.listingblock .pygments .tok-sh { color: #BA2121 } /* Literal.String.Heredoc */
.listingblock .pygments .tok-si { color: #BB6688; font-weight: bold } /* Literal.String.Interpol */
.listingblock .pygments .tok-sx { color: #008000 } /* Literal.String.Other */
.listingblock .pygments .tok-sr { color: #BB6688 } /* Literal.String.Regex */
.listingblock .pygments .tok-s1 { color: #BA2121 } /* Literal.String.Single */
.listingblock .pygments .tok-ss { color: #19177C } /* Literal.String.Symbol */
.listingblock .pygments .tok-bp { color: #008000 } /* Name.Builtin.Pseudo */
.listingblock .pygments .tok-fm { color: #0000FF } /* Name.Function.Magic */
.listingblock .pygments .tok-vc { color: #19177C } /* Name.Variable.Class */
.listingblock .pygments .tok-vg { color: #19177C } /* Name.Variable.Global */
.listingblock .pygments .tok-vi { color: #19177C } /* Name.Variable.Instance */
.listingblock .pygments .tok-vm { color: #19177C } /* Name.Variable.Magic */
.listingblock .pygments .tok-il { color: #666666 } /* Literal.Number.Integer.Long */
</style>
</head>
<body class="article">
<div id="header">
<h1>Efficient implementation of MinHash, part 1</h1>
<div class="details">
<span id="author" class="author">Andrei Gudkov</span><br>
<span id="email" class="email"><a href="mailto:gudokk@gmail.com">gudokk@gmail.com</a></span><br>
</div>
</div>
<div id="content">
<div class="paragraph">
<p>MinHash is a technique widely used to compare texts for similarity.
For example, in web search it is used to detect mirror sites.
Mirror is a site that clones the contents of another site either
verbatim or very closely.
Web search engines are interested in mirror detection because of two reasons.
First of all, it significantly reduces cost of maintaining search engine.
Search engines typically index contents of only the primary web site (highestly ranked)
and ignore all its mirrors.
Secondly, mirrors to well-known sites often indicate phishing,
which raises red flags and requires manual review from security team.
Another application of MinHash is plagiarism detection.
Universities and scientific magazines are interested to automatically recognize
copypasted papers and thesises.</p>
</div>
<div class="paragraph">
<p>MinHash algorithm has a number of variations.
In this article I will focus on the MinHash variation that uses single hash function.
Such type of MinHash is computationally fast to construct, but computation of similarity
score is slow, in particularly when the goal is to find distances between one new document
and all the documents from preexisting collection.
This variation is suitable for ad-hoc similarity computation between a single pair of documents
or between one document and all the documents from collection of small to moderate size.</p>
</div>
<div class="paragraph">
<p>The workflow is the following: for every text you have,
split it into sequence of words, then create a set of every triplet of adjacent words
(every such triplet is called a <em>shingle</em>),
then hash these shingles, and finally select smallest unique N shingles.
These N shingles become the fingerprint (MinHash) of the text.
N is chosen typically from about 50 to a couple of hundreds
depending on median size of the text of the corpus.</p>
</div>
<div class="imageblock" style="text-align: center">
<div class="content">
<img src="dataflow.png" alt="dataflow" width="100%">
</div>
</div>
<div class="paragraph">
<p>Once fingerprints are generated for every text,
we can compute similarity for any pair of texts by computing Jaccard distance
of their fingerprints:</p>
</div>
<div class="imageblock" style="text-align: center">
<div class="content">
<img src="math-f7985fa2930103d5.svg" alt="J(t_1, t_2) = \frac
{\left | \mathrm{Fingerprint}(t_1) \cap \mathrm{Fingerprint}(t_2) \right |}
{\left | \mathrm{Fingerprint}(t_1) \cup \mathrm{Fingerprint}(t_2) \right |}
\in \left [ 0.0\,..\,1.0 \right ]" height="40">
</div>
</div>
<div class="paragraph">
<p>It can be stastically proved that the closer Jaccard distance to one, the closer the texts are.
For example, we can set threshold value to 0.9.
If Jaccard distance exceeds 0.9, then we conclude that two texts are nearly identical.</p>
</div>
<div class="paragraph">
<p>The good thing about MinHash is that it is robust to minor modifications to the text.
Web pages often contain some elements which become different when site is mirrored, such
as current timestamp, domain name or manually added disclaimers.
Just comparing texts character-by-character would not be enough.
Another good thing about MinHash is that no matter how large input texts are,
the fingperprints it computes are of fixed, short lengths.
Fingprint consisting of 128 32-bit hashes is only one 512 bytes.</p>
</div>
<div class="paragraph">
<p>However, even this "computationally cheap" variant is expensive in practice.
In this article I will demonstrate efficient implementation of fingerprint generation and pair-wise
computation of <img src="math-c2b51b5f051a140e.svg" class="inlinemath" style="height:1.766ex;vertical-align:-0.391ex;" alt="J(t_1, t_2)"/>.</p>
</div>
<div class="paragraph">
<div class="title">Tokenizing text</div>
<p>First task is tokenizing text into words.
Usually high-quality text analysis requires NLP-based models.
For example, it is desirable to treat "N.B.A." identically to "NBA" rather
than consisting of three distinct tokens "N", "B", "A".
Similarily, words "happy" and "happiness" are better to be stemmed to the same root "happi".
Luckily, in similarity detection we don&#8217;t need this level of complexity due
to probabilistc nature of the algorithm, and can define a word simply
as a sequence of adjacent alphanumerical characters.
Remaining (non-alphanum) characters are the delimeters.</p>
</div>
<div class="paragraph">
<p>Assuming that text is a sequence of 16-bit unicode code points,
the number of alphanumerical characters is extermely large and they do not
form adjacent region.
In the image below, there is one pixel per every 16-bit code point.
Red pixels denote alphanumerical code points.</p>
</div>
<div class="imageblock" style="text-align: center">
<div class="content">
<img src="isalphanum.png" alt="isalphanum">
</div>
</div>
<div class="paragraph">
<p>As such, the only reasonable way to store this information is in a lookup table with one bit
per every code point.
The table below was prebuilt in Java by probing code points with <code>Character.isLetterOrDigit(char c)</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cpp"><span class="tok-n">__attribute__</span><span class="tok-p">((</span><span class="tok-n">aligned</span><span class="tok-p">(</span><span class="tok-mi">64</span><span class="tok-p">)))</span> <span class="tok-k">const</span> <span class="tok-kt">uint64_t</span> <span class="tok-n">kAlphanumTable</span><span class="tok-p">[]</span> <span class="tok-o">=</span> <span class="tok-p">{</span>
  <span class="tok-mh">0x03ff000000000000</span><span class="tok-p">,</span> <span class="tok-mh">0x07fffffe07fffffe</span><span class="tok-p">,</span> <span class="tok-mh">0x0420040000000000</span><span class="tok-p">,</span> <span class="tok-mh">0xff7fffffff7fffff</span><span class="tok-p">,</span>
  <span class="tok-mh">0xffffffffffffffff</span><span class="tok-p">,</span> <span class="tok-mh">0xffffffffffffffff</span><span class="tok-p">,</span> <span class="tok-mh">0xffffffffffffffff</span><span class="tok-p">,</span> <span class="tok-mh">0xffffffffffffffff</span><span class="tok-p">,</span>
  <span class="tok-mh">0xffffffffffffffff</span><span class="tok-p">,</span> <span class="tok-mh">0xffffffffffffffff</span><span class="tok-p">,</span> <span class="tok-mh">0xffffffffffffffff</span><span class="tok-p">,</span> <span class="tok-mh">0x0000501f0003ffc3</span><span class="tok-p">,</span>
  <span class="tok-mh">0x0000000000000000</span><span class="tok-p">,</span> <span class="tok-mh">0x3cdf000000000000</span><span class="tok-p">,</span> <span class="tok-mh">0xfffffffbffffd740</span><span class="tok-p">,</span> <span class="tok-mh">0xffbfffffffffffff</span><span class="tok-p">,</span>
  <span class="tok-mh">0xffffffffffffffff</span><span class="tok-p">,</span> <span class="tok-mh">0xffffffffffffffff</span><span class="tok-p">,</span> <span class="tok-mh">0xfffffffffffffc03</span><span class="tok-p">,</span> <span class="tok-mh">0xffffffffffffffff</span><span class="tok-p">,</span>
  <span class="tok-mh">0xfffe00ffffffffff</span><span class="tok-p">,</span> <span class="tok-mh">0xfffffffe027fffff</span><span class="tok-p">,</span> <span class="tok-mh">0x00000000000000ff</span><span class="tok-p">,</span> <span class="tok-mh">0x000707ffffff0000</span><span class="tok-p">,</span>
  <span class="tok-cm">/* ... */</span>
  <span class="tok-mh">0x3fffffffffffffff</span><span class="tok-p">,</span> <span class="tok-mh">0xffffffffffff0000</span><span class="tok-p">,</span> <span class="tok-mh">0xfffffffffffcffff</span><span class="tok-p">,</span> <span class="tok-mh">0x0fff0000000000ff</span><span class="tok-p">,</span>
  <span class="tok-mh">0x0000000000000000</span><span class="tok-p">,</span> <span class="tok-mh">0xffdf000000000000</span><span class="tok-p">,</span> <span class="tok-mh">0xffffffffffffffff</span><span class="tok-p">,</span> <span class="tok-mh">0x1fffffffffffffff</span><span class="tok-p">,</span>
  <span class="tok-mh">0x07fffffe03ff0000</span><span class="tok-p">,</span> <span class="tok-mh">0xffffffc007fffffe</span><span class="tok-p">,</span> <span class="tok-mh">0x7fffffffffffffff</span><span class="tok-p">,</span> <span class="tok-mh">0x000000001cfcfcfc</span><span class="tok-p">,</span>
<span class="tok-p">};</span>

<span class="tok-kr">inline</span> <span class="tok-kt">bool</span> <span class="tok-nf">IsAlphanum</span><span class="tok-p">(</span><span class="tok-kt">unsigned</span> <span class="tok-kt">int</span> <span class="tok-n">c</span><span class="tok-p">)</span> <span class="tok-p">{</span>
  <span class="tok-k">return</span> <span class="tok-p">(</span><span class="tok-n">kAlphanumTable</span><span class="tok-p">[</span><span class="tok-n">c</span><span class="tok-o">/</span><span class="tok-mi">64</span><span class="tok-p">]</span> <span class="tok-o">&gt;&gt;</span> <span class="tok-p">(</span><span class="tok-n">c</span><span class="tok-o">%</span><span class="tok-mi">64</span><span class="tok-p">))</span> <span class="tok-o">&amp;</span> <span class="tok-mh">0x1</span><span class="tok-p">;</span>
<span class="tok-p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<div class="title">Choosing hash function</div>
<p>Before we continue forward, let&#8217;s choose hash function.
We want it to be relatively fast to compute but complex enough to be robust to permutations,
e.g. "word1 word2 word3" and "word1 word3 word2" must be almost always hashed to different values.
Thus, per-character XOR is a bad idea.
Taking into consideration the above requirements, I chose
<a href="https://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function">FNV-1a</a>.
It is well studied, widely used in practice (glibc implements <code>std::hash&lt;T&gt;</code> by using it),
not very expensive (two multiplications per character), and also easy to code.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cpp"><span class="tok-kt">uint32_t</span> <span class="tok-nf">fnv1a</span><span class="tok-p">(</span><span class="tok-k">const</span> <span class="tok-kt">uint16_t</span><span class="tok-o">*</span> <span class="tok-n">str</span><span class="tok-p">,</span> <span class="tok-kt">int</span> <span class="tok-n">len</span><span class="tok-p">)</span> <span class="tok-p">{</span>
  <span class="tok-kt">uint32_t</span> <span class="tok-n">hash</span> <span class="tok-o">=</span> <span class="tok-mi">2166136261</span><span class="tok-p">;</span>
  <span class="tok-k">for</span> <span class="tok-p">(</span><span class="tok-kt">size_t</span> <span class="tok-n">i</span> <span class="tok-o">=</span> <span class="tok-mi">0</span><span class="tok-p">;</span> <span class="tok-n">i</span> <span class="tok-o">&lt;</span> <span class="tok-n">len</span><span class="tok-p">;</span> <span class="tok-n">i</span><span class="tok-o">++</span><span class="tok-p">)</span> <span class="tok-p">{</span>
    <span class="tok-kt">uint16_t</span> <span class="tok-n">c</span> <span class="tok-o">=</span> <span class="tok-n">str</span><span class="tok-p">[</span><span class="tok-n">i</span><span class="tok-p">];</span>
    <span class="tok-n">hash</span> <span class="tok-o">=</span> <span class="tok-n">hash</span> <span class="tok-o">^</span> <span class="tok-p">(</span><span class="tok-n">c</span> <span class="tok-o">&amp;</span> <span class="tok-mh">0xff</span><span class="tok-p">);</span>
    <span class="tok-n">hash</span> <span class="tok-o">=</span> <span class="tok-n">hash</span> <span class="tok-o">*</span> <span class="tok-mi">16777619</span><span class="tok-p">;</span>
    <span class="tok-n">hash</span> <span class="tok-o">=</span> <span class="tok-n">hash</span> <span class="tok-o">^</span> <span class="tok-p">(</span><span class="tok-n">c</span> <span class="tok-o">&gt;&gt;</span> <span class="tok-mi">16</span><span class="tok-p">);</span>
    <span class="tok-n">hash</span> <span class="tok-o">=</span> <span class="tok-n">hash</span> <span class="tok-o">*</span> <span class="tok-mi">16777619</span><span class="tok-p">;</span>
  <span class="tok-p">}</span>
  <span class="tok-k">return</span> <span class="tok-n">hash</span><span class="tok-p">;</span>
<span class="tok-p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<div class="title">Generating shingles</div>
<p>The first place where we can get major significatn performance gains/improvmenets is shingle generating algorithm.
Below pseudocode displays naive implementation.
It is implemented exactly as visualzed in the first image.
First, text iss split into a vector of separate words.
Next Just iterate over every sequence of three adjacent words, compute and emit hash.</p>
</div>
<div class="paragraph">
<p>split into words
for i 0 .. words.length():
  hash = &#8230;&#8203;;
  for j 0..2:
    for int k = 0; words[i+j].lenth();
      update_hash(hash, word[][]);
  collector.collect(hash)</p>
</div>
<div class="paragraph">
<p>The first obvious thing that we would like to avoid is copying.
It shouldn&#8217;t be very hard to do since shingling is a type of streaming aglrotihgm,
i.e. we need only to keep track on a window of three consecuteive words at a time.</p>
</div>
<div class="paragraph">
<p>A bit more subtle way is that in the algorithm above we process every character
multiple times.</p>
</div>
<div class="paragraph">
<p>pipelineing
tmplateinzing</p>
</div>
<div class="paragraph">
<p>What we are woul like to achieve is to use every character only once.
template is better since K  is small and allows for the compiler to unroll the loop.</p>
</div>
<div class="paragraph">
<p>The optimization is possible because we can use pipelining to process only single character at a time
and never return to it.</p>
</div>
<div class="paragraph">
<p>We store K partially computed hashes.
All hashes are simultaneously and inependeintly are updated when we read new alphanumeric character.
When word is over, this means that head of the pipline is the hash for the last K words,
head-1 is for the last K-1 words and so on.
When non-alphanum character is encountered, we eject head of the pipleine and shift
the remaining hashes.</p>
</div>
<div class="paragraph">
<p>text&#8230;&#8203;..</p>
</div>
<div class="literalblock">
<div class="content">
<pre>hash0
hash1
hash2</pre>
</div>
</div>
<div class="paragraph">
<p>The optimization comes for at least two resons: every character is processed only once.
Seconly, because there is not dpeenedncy between ccles of the hash update,
compiler can unroll the loop, and the cpu OOO can execute it truly in parallel way.</p>
</div>
<div class="paragraph">
<div class="title">Selecting smallest hashes</div>
<p>This is the second major imporeenetn.</p>
</div>
<div class="paragraph">
<p>Since this algorithm is quadratic, it can be troublesome.
There is not much we can do with SSE.
Better to stick to correct high-level algorithm.</p>
</div>
<div class="paragraph">
<p>First of all, let&#8217;s (mentally, on paper) try common algorithsm.
If we knew that shingles are unique, we could use just heap (priority queue).
Also we could use partial_sort.
Partial_sort can be adapted to non-unique, but anyway it requires fully buffered,
and we will try to avoid that.
After a lot of epxerimenting, following solutions can to my mind:
 1. sorted vector. checking is lograithmic. insertion is slow.
 2. attempt to guard sorted vector with simple hash table with true positives:
    this significatly reduces amount of time required to check
 3. prioarity_queue with classical hash table.</p>
</div>
<div class="paragraph">
<p>Eventually soution that won is the following
Hash table usess linear probing and doesn&#8217;t support element-wise removal.</p>
</div>
<div class="paragraph">
<p>Some of the implemented and versions are providded below with tests:</p>
</div>
<div class="paragraph">
<p>we can fuse</p>
</div>
<div class="paragraph">
<div class="title">Pair-wise computation</div>
<p>TBD</p>
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2019-06-19 16:37:08 UTC
</div>
</div>
</body>
</html>