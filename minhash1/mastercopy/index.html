<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]-->
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 1.5.4">
<meta name="author" content="Andrei Gudkov">
<title>Efficient implementation of MinHash, part 1</title>
<style>
/*! normalize.css v2.1.2 | MIT License | git.io/normalize */article,aside,details,figcaption,figure,footer,header,hgroup,main,nav,section,summary{display:block}audio,canvas,video{display:inline-block}audio:not([controls]){display:none;height:0}[hidden],template{display:none}script{display:none!important}html{font-family:sans-serif;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}a{background:transparent}a:focus{outline:thin dotted}a:active,a:hover{outline:0}h1{font-size:2em;margin:.67em 0}abbr[title]{border-bottom:1px dotted}b,strong{font-weight:bold}dfn{font-style:italic}hr{-moz-box-sizing:content-box;box-sizing:content-box;height:0}mark{background:#ff0;color:#000}code,kbd,pre,samp{font-family:monospace,serif;font-size:1em}pre{white-space:pre-wrap}q{quotes:"\201C" "\201D" "\2018" "\2019"}small{font-size:80%}sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}sup{top:-0.5em}sub{bottom:-0.25em}img{border:0}svg:not(:root){overflow:hidden}figure{margin:0}fieldset{border:1px solid #c0c0c0;margin:0 2px;padding:.35em .625em .75em}legend{border:0;padding:0}button,input,select,textarea{font-family:inherit;font-size:100%;margin:0}button,input{line-height:normal}button,select{text-transform:none}button,html input[type="button"],input[type="reset"],input[type="submit"]{-webkit-appearance:button;cursor:pointer}button[disabled],html input[disabled]{cursor:default}input[type="checkbox"],input[type="radio"]{box-sizing:border-box;padding:0}input[type="search"]{-webkit-appearance:textfield;-moz-box-sizing:content-box;-webkit-box-sizing:content-box;box-sizing:content-box}input[type="search"]::-webkit-search-cancel-button,input[type="search"]::-webkit-search-decoration{-webkit-appearance:none}button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}textarea{overflow:auto;vertical-align:top}table{border-collapse:collapse;border-spacing:0}*,*::before,*::after{box-sizing:border-box;margin:0}body{font-family:Helvetica,Arial,sans-serif;font-size:16px;color:#222;line-height:1.5;max-width:55em;margin:0 auto}#content,#footnotes{padding-left:.5em;padding-right:.5em}strong{font-weight:bold}em{font-style:italic}:not(pre)>code{font-family:Courier,monospace;line-height:1.0}a{color:#0061c5;text-decoration:none}a:hover{text-decoration:underline}hr{border-width:0 0 1px 0;border-style:solid;border-color:#678}ul,ol{list-style-position:outside;padding-left:0;margin-left:2em}ul li ul,ul li ol,ol li ul,ol li ol{margin-left:1.414em}ul>li{list-style-type:square;font-size:80%}ul>li>*{font-size:125%}ol>li{font-weight:bold}ol>li>*{font-weight:normal}ol.arabic{list-style-type:decimal}ol.decimal{list-style-type:decimal-leading-zero}ol.loweralpha{list-style-type:lower-alpha}ol.upperalpha{list-style-type:upper-alpha}ol.lowerroman{list-style-type:lower-roman}ol.upperroman{list-style-type:upper-roman}ol.lowergreek{list-style-type:lower-greek}.dlist dt{color:#325d72;font-weight:bold}.dlist dt:not(:first-child){margin-top:1em}.dlist dd{margin-left:2em}td.hdlist1{color:#325d72;padding-right:.5em;vertical-align:top}td.hdlist2{padding-bottom:.5em}h1{font-size:28px;font-weight:normal;letter-spacing:-1px;color:white;background-color:#325d72;text-align:center;margin:0 0 .5em 0;padding:.05em .5em}@media print{h1{color:#325d72;background-color:white;font-weight:bold}}h1::after{content:':';width:0;overflow:hidden;display:inline-block;vertical-align:middle}.author{color:#325d72}.email::before{content:"<";color:#325d72}.email::after{content:">";color:#325d72}.author+br,.email+br{display:none}#author{padding-left:.5em}#toc{margin:1em 0 2em 0;padding-left:.5em}#toctitle{font-size:19px;font-weight:bold;color:#325d72;margin:.5em 0}#toc>ul{line-height:1.4;font-size:15px;margin:0 0 0 .5em}#toc ul li{list-style-type:none}#toc li{margin:0}.big{font-size:120%}.small{font-size:75%}.underline{text-decoration:underline}.overline{text-decoration:overline}.line-through{text-decoration:line-through}.aqua{color:#00bfbf}.aqua-background{background-color:#00fafa;border-radius:2px;padding:0 3px}.black{color:"black"}.black-background{background-color:"black";border-radius:2px;padding:0 3px}.blue{color:#0000bf}.blue-background{background-color:#0000fa;border-radius:2px;padding:0 3px}.fuchsia{color:#bf00bf}.fuchsia-background{background-color:#fa00fa;border-radius:2px;padding:0 3px}.gray{color:#606060}.gray-background{background-color:#7d7d7d;border-radius:2px;padding:0 3px}.green{color:#006000}.green-background{background-color:#007d00;border-radius:2px;padding:0 3px}.lime{color:#00bf00}.lime-background{background-color:#00fa00;border-radius:2px;padding:0 3px}.maroon{color:#600000}.maroon-background{background-color:#7d0000;border-radius:2px;padding:0 3px}.navy{color:#000060}.navy-background{background-color:#00007d;border-radius:2px;padding:0 3px}.olive{color:#606000}.olive-background{background-color:#7d7d00;border-radius:2px;padding:0 3px}.purple{color:#600060}.purple-background{background-color:#7d007d;border-radius:2px;padding:0 3px}.red{color:#bf0000}.red-background{background-color:#fa0000;border-radius:2px;padding:0 3px}.silver{color:#909090}.silver-background{background-color:#bcbcbc;border-radius:2px;padding:0 3px}.teal{color:#006060}.teal-background{background-color:#007d7d;border-radius:2px;padding:0 3px}.white{color:#bfbfbf}.white-background{background-color:#fafafa;border-radius:2px;padding:0 3px}.yellow{color:#bfbf00}.yellow-background{background-color:#fafa00;border-radius:2px;padding:0 3px}table.tableblock{border:1px solid #91a7b3;margin-left:auto;margin-right:auto}table.tableblock>caption.title{text-align:left;margin-bottom:.5em}table.tableblock>colgroup>col{width:inherit!important}table.tableblock>tbody>tr>td{border-style:solid;border-color:#91a7b3;border-width:0 1px;padding:0 5px 2px 5px}table.tableblock>tbody>tr:nth-of-type(2n){background-color:#f3f5f7}p.tableblock{text-align:inherit}table.tableblock>thead>tr>td,table.tableblock>thead>tr>th,table.tableblock>tfoot>tr>td,table.tableblock>tfoot>tr>th{color:#325d72;font-weight:bold;line-height:1.35;padding:2px 5px;border:1px solid #91a7b3}table.tableblock>thead>tr>th,table.tableblock>thead>tr>td{border-bottom-width:2px}table.tableblock>tfoot>tr>th,table.tableblock>tfoot>tr>td{border-top-width:2px}th.halign-left,td.halign-left{text-align:left}th.halign-right,td.halign-right{text-align:right}th.halign-center,td.halign-center{text-align:center}th.valign-top,td.valign-top{vertical-align:top}th.valign-bottom,td.valign-bottom{vertical-align:bottom}th.valign-middle,td.valign-middle{vertical-align:middle}div.listingblock{padding:.5em;border-style:solid;border-color:#678;border-width:0 0 0 2px;background-color:#f3f5f7;overflow:auto}div.listingblock .title{text-align:right}div.listingblock pre{font-family:Menlo,Consolas,Monaco,"Lucida Console",monospace;font-size:87.5%;white-space:pre;background-color:#f3f5f7!important;margin:0}div.listingblock td.linenos{border-right:1px solid #91a7b3;padding-right:.67em}div.listingblock table.pyhltable div.linenodiv{color:#678;text-align:right}div.listingblock table.pyhltable td.code{padding-left:.67em}div.imageblock>div.content>img{max-width:98%}.text-indent{padding-left:2em}img.inlinemath{image-rendering:optimizequality;margin-top:.5ex}h2,h3,h4{font-weight:normal;color:#325d72;margin:0}h2{font-size:27px;letter-spacing:-1px;border-bottom:1px solid #91a7b3}h3{font-size:24px;letter-spacing:-0.75px}h4{font-size:21px;letter-spacing:-0.5px}.title{color:#325d72;font-weight:bold}#footer{font-size:80%;color:white;background-color:#325d72}@media print{#footer{color:#325d72;background-color:white;font-weight:bold}}#footer-text{text-align:center;padding:.5em}#footer-badges{display:none}span.footnote{vertical-align:super;font-size:80%}#footnotes>hr{display:none}#footnotes::before{display:block;border-bottom:1px solid #678;margin:.5em 0;content:"Notes";font-size:19px;font-weight:bold;color:#325d72}#footnotes .footnote{margin-left:.5em;font-size:15px}hr:not(:first-child){margin-top:1.5em}hr:not(:last-child){margin-bottom:1.5em}.imageblock:not(:last-child),.listingblock:not(:last-child),.tableblock:not(:last-child){margin-bottom:1em}p+*{margin-top:1em}.paragraph+*{margin-top:1em}p+.ulist,p+.olist,p+.dlist,p+.hdlist,.paragraph+.ulist,.paragraph+.olist,.paragraph+.dlist,.paragraph+.hdlist,.paragraph+.listingblock{margin-top:.5em!important}li *+.ulist,li *+.olist,li *+.dlist,li *+.hdlist{margin-top:.1em!important}.title:not(:first-child){margin-top:1.5em}.content+.title{margin-top:.5em!important}.title+*{margin-top:1.5em}.title+p,.title+.paragraph,.title+.ulist,.title+.olist,.title+.dlist,.title+.hdlist{margin-top:.5em!important}.ulist:not(:last-child){margin-bottom:1em}.olist:not(:last-child){margin-bottom:1em}li:not(:first-child){margin-top:.1em}.dlist:not(:last-child){margin-bottom:1em}.dlist:not(:first-child){margin-top:1em}.sect3:not(:last-child){margin-bottom:18px}.sect3:not(:first-child){margin-top:18px}h4:not(:last-child){margin-bottom:9px}.sect2:not(:last-child){margin-bottom:22px}.sect2:not(:first-child){margin-top:22px}h3:not(:last-child){margin-bottom:11px}.sect1:not(:last-child){margin-bottom:40px}.sect1:not(:first-child){margin-top:40px}#preamble:not(:last-child){margin-bottom:40px}h2:not(:last-child){margin-bottom:13px}#header:not(:last-child),#content:not(:last-child),#footnotes:not(:last-child){margin-bottom:2em}
</style>
<style>
.listingblock .pygments .hll { background-color: #ffffcc }
.listingblock .pygments  { background: #f8f8f8; }
.listingblock .pygments .tok-c { color: #408080; font-style: italic } /* Comment */
.listingblock .pygments .tok-err { border: 1px solid #FF0000 } /* Error */
.listingblock .pygments .tok-k { color: #008000; font-weight: bold } /* Keyword */
.listingblock .pygments .tok-o { color: #666666 } /* Operator */
.listingblock .pygments .tok-ch { color: #408080; font-style: italic } /* Comment.Hashbang */
.listingblock .pygments .tok-cm { color: #408080; font-style: italic } /* Comment.Multiline */
.listingblock .pygments .tok-cp { color: #BC7A00 } /* Comment.Preproc */
.listingblock .pygments .tok-cpf { color: #408080; font-style: italic } /* Comment.PreprocFile */
.listingblock .pygments .tok-c1 { color: #408080; font-style: italic } /* Comment.Single */
.listingblock .pygments .tok-cs { color: #408080; font-style: italic } /* Comment.Special */
.listingblock .pygments .tok-gd { color: #A00000 } /* Generic.Deleted */
.listingblock .pygments .tok-ge { font-style: italic } /* Generic.Emph */
.listingblock .pygments .tok-gr { color: #FF0000 } /* Generic.Error */
.listingblock .pygments .tok-gh { color: #000080; font-weight: bold } /* Generic.Heading */
.listingblock .pygments .tok-gi { color: #00A000 } /* Generic.Inserted */
.listingblock .pygments .tok-go { color: #888888 } /* Generic.Output */
.listingblock .pygments .tok-gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.listingblock .pygments .tok-gs { font-weight: bold } /* Generic.Strong */
.listingblock .pygments .tok-gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.listingblock .pygments .tok-gt { color: #0044DD } /* Generic.Traceback */
.listingblock .pygments .tok-kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.listingblock .pygments .tok-kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.listingblock .pygments .tok-kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.listingblock .pygments .tok-kp { color: #008000 } /* Keyword.Pseudo */
.listingblock .pygments .tok-kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.listingblock .pygments .tok-kt { color: #B00040 } /* Keyword.Type */
.listingblock .pygments .tok-m { color: #666666 } /* Literal.Number */
.listingblock .pygments .tok-s { color: #BA2121 } /* Literal.String */
.listingblock .pygments .tok-na { color: #7D9029 } /* Name.Attribute */
.listingblock .pygments .tok-nb { color: #008000 } /* Name.Builtin */
.listingblock .pygments .tok-nc { color: #0000FF; font-weight: bold } /* Name.Class */
.listingblock .pygments .tok-no { color: #880000 } /* Name.Constant */
.listingblock .pygments .tok-nd { color: #AA22FF } /* Name.Decorator */
.listingblock .pygments .tok-ni { color: #999999; font-weight: bold } /* Name.Entity */
.listingblock .pygments .tok-ne { color: #D2413A; font-weight: bold } /* Name.Exception */
.listingblock .pygments .tok-nf { color: #0000FF } /* Name.Function */
.listingblock .pygments .tok-nl { color: #A0A000 } /* Name.Label */
.listingblock .pygments .tok-nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
.listingblock .pygments .tok-nt { color: #008000; font-weight: bold } /* Name.Tag */
.listingblock .pygments .tok-nv { color: #19177C } /* Name.Variable */
.listingblock .pygments .tok-ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
.listingblock .pygments .tok-w { color: #bbbbbb } /* Text.Whitespace */
.listingblock .pygments .tok-mb { color: #666666 } /* Literal.Number.Bin */
.listingblock .pygments .tok-mf { color: #666666 } /* Literal.Number.Float */
.listingblock .pygments .tok-mh { color: #666666 } /* Literal.Number.Hex */
.listingblock .pygments .tok-mi { color: #666666 } /* Literal.Number.Integer */
.listingblock .pygments .tok-mo { color: #666666 } /* Literal.Number.Oct */
.listingblock .pygments .tok-sa { color: #BA2121 } /* Literal.String.Affix */
.listingblock .pygments .tok-sb { color: #BA2121 } /* Literal.String.Backtick */
.listingblock .pygments .tok-sc { color: #BA2121 } /* Literal.String.Char */
.listingblock .pygments .tok-dl { color: #BA2121 } /* Literal.String.Delimiter */
.listingblock .pygments .tok-sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.listingblock .pygments .tok-s2 { color: #BA2121 } /* Literal.String.Double */
.listingblock .pygments .tok-se { color: #BB6622; font-weight: bold } /* Literal.String.Escape */
.listingblock .pygments .tok-sh { color: #BA2121 } /* Literal.String.Heredoc */
.listingblock .pygments .tok-si { color: #BB6688; font-weight: bold } /* Literal.String.Interpol */
.listingblock .pygments .tok-sx { color: #008000 } /* Literal.String.Other */
.listingblock .pygments .tok-sr { color: #BB6688 } /* Literal.String.Regex */
.listingblock .pygments .tok-s1 { color: #BA2121 } /* Literal.String.Single */
.listingblock .pygments .tok-ss { color: #19177C } /* Literal.String.Symbol */
.listingblock .pygments .tok-bp { color: #008000 } /* Name.Builtin.Pseudo */
.listingblock .pygments .tok-fm { color: #0000FF } /* Name.Function.Magic */
.listingblock .pygments .tok-vc { color: #19177C } /* Name.Variable.Class */
.listingblock .pygments .tok-vg { color: #19177C } /* Name.Variable.Global */
.listingblock .pygments .tok-vi { color: #19177C } /* Name.Variable.Instance */
.listingblock .pygments .tok-vm { color: #19177C } /* Name.Variable.Magic */
.listingblock .pygments .tok-il { color: #666666 } /* Literal.Number.Integer.Long */
</style>
</head>
<body class="article">
<div id="header">
<h1>Efficient implementation of MinHash, part 1</h1>
<div class="details">
<span id="author" class="author">Andrei Gudkov</span><br>
<span id="email" class="email"><a href="mailto:gudokk@gmail.com">gudokk@gmail.com</a></span><br>
</div>
</div>
<div id="content">
<div class="paragraph">
<p>MinHash is a technique widely used to compare texts for similarity.
For example, in web search it is used to detect mirror sites.
Mirror is a site that clones the contents of another site either
verbatim or very closely.
Web search engines are interested in mirror detection because of two reasons.
First of all, it significantly reduces cost of maintaining search engine.
Search engines typically index contents of only the primary web site (highestly ranked)
and ignore all its mirrors.
Secondly, mirrors to well-known sites often indicate phishing,
which raises red flags and requires manual review from security team.
Another application of MinHash is plagiarism detection.
Universities and scientific magazines are interested to automatically recognize
copypasted papers and thesises.</p>
</div>
<div class="paragraph">
<p>MinHash algorithm has a number of variations.
In this article I will focus on the MinHash variation that uses single hash function.
Such type of MinHash is computationally fast to construct, but computation of similarity
score is slow, in particularly when the goal is to find distances between one new document
and all the documents from preexisting collection.
This variation is suitable for ad-hoc similarity computation between a single pair of documents
or between one document and all the documents from the collection of moderate size.</p>
</div>
<div class="paragraph">
<p>The workflow is the following: for every text you have,
split it into sequence of words, then create a set of every K-tuple of adjacent words
(K=3 below; every such triplet is called a <em>shingle</em>),
then hash these shingles, and finally select smallest unique N shingles.
These N shingles become the fingerprint (MinHash) of the text.
N is chosen typically from about 50 to a couple of hundreds
depending on median size of the text of the corpus.</p>
</div>
<div class="imageblock" style="text-align: center">
<div class="content">
<img src="overview.png" alt="overview" width="100%">
</div>
</div>
<div class="paragraph">
<p>Once fingerprints are generated for every text,
we can compute similarity for any pair of texts by computing Jaccard distance
of their fingerprints:</p>
</div>
<div class="imageblock" style="text-align: center">
<div class="content">
<img src="math-f7985fa2930103d5.svg" alt="J(t_1, t_2) = \frac
{\left | \mathrm{Fingerprint}(t_1) \cap \mathrm{Fingerprint}(t_2) \right |}
{\left | \mathrm{Fingerprint}(t_1) \cup \mathrm{Fingerprint}(t_2) \right |}
\in \left [ 0.0\,..\,1.0 \right ]" height="40">
</div>
</div>
<div class="paragraph">
<p>It can be stastically proved that the closer Jaccard distance between two fingerprints to one,
the closer Jaccard distance between two texts.
For example, we can set threshold value to 0.9.
If Jaccard distance exceeds 0.9, then we conclude that two texts are nearly identical.</p>
</div>
<div class="paragraph">
<p>The good thing about MinHash is that it is robust to minor modifications to the text.
Web pages often contain some elements which become different when site is mirrored, such
as current timestamp, domain name or manually added disclaimers.
Just comparing texts character-by-character would not be enough.
Another good thing about MinHash is that no matter how large input texts are,
the fingperprints it computes are of fixed, short lengths.
Fingerprint consisting of 128 32-bit hashes is only one 512 bytes.</p>
</div>
<div class="paragraph">
<p>However, even this "computationally cheap" variant is expensive in practice.
In this article I will demonstrate efficient implementation of fingerprint generation and pair-wise
computation of <img src="math-c2b51b5f051a140e.svg" class="inlinemath" style="height:1.766ex;vertical-align:-0.391ex;" alt="J(t_1, t_2)"/>.</p>
</div>
<div class="paragraph">
<div class="title">Tokenizing text</div>
<p>First task is tokenizing text into words.
Usually high-quality text analysis requires NLP-based models.
For example, it is desirable to treat "N.B.A." identically to "NBA" rather
than consisting of three distinct tokens "N", "B", "A".
Similarily, words "happy" and "happiness" are better to be stemmed to the same root "happi".
Luckily, in similarity detection we don&#8217;t need this level of complexity due
to probabilistic nature of the algorithm, and can define a word simply
as a sequence of adjacent alphanumeric characters.
Remaining (non-alphanumic) characters are the delimeters.</p>
</div>
<div class="paragraph">
<p>Assuming that text is a sequence of 16-bit unicode code points,
the number of alphanumeric characters is large and, worse, they do not
form adjacent region.
In the image below, there is one pixel per every 16-bit code point.
Red pixels denote alphanumeric code points.</p>
</div>
<div class="imageblock" style="text-align: center">
<div class="content">
<img src="isalphanum.png" alt="isalphanum">
</div>
</div>
<div class="paragraph">
<p>As such, the only reasonable way to store this information is in a lookup table with one bit
per every code point.
The table below was prebuilt in Java by probing code points with <code>Character.isLetterOrDigit(char c)</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cpp"><span class="tok-n">__attribute__</span><span class="tok-p">((</span><span class="tok-n">aligned</span><span class="tok-p">(</span><span class="tok-mi">64</span><span class="tok-p">)))</span> <span class="tok-k">const</span> <span class="tok-kt">uint64_t</span> <span class="tok-n">kAlphanumTable</span><span class="tok-p">[]</span> <span class="tok-o">=</span> <span class="tok-p">{</span>
  <span class="tok-mh">0x03ff000000000000</span><span class="tok-p">,</span> <span class="tok-mh">0x07fffffe07fffffe</span><span class="tok-p">,</span> <span class="tok-mh">0x0420040000000000</span><span class="tok-p">,</span> <span class="tok-mh">0xff7fffffff7fffff</span><span class="tok-p">,</span>
  <span class="tok-mh">0xffffffffffffffff</span><span class="tok-p">,</span> <span class="tok-mh">0xffffffffffffffff</span><span class="tok-p">,</span> <span class="tok-mh">0xffffffffffffffff</span><span class="tok-p">,</span> <span class="tok-mh">0xffffffffffffffff</span><span class="tok-p">,</span>
  <span class="tok-mh">0xffffffffffffffff</span><span class="tok-p">,</span> <span class="tok-mh">0xffffffffffffffff</span><span class="tok-p">,</span> <span class="tok-mh">0xffffffffffffffff</span><span class="tok-p">,</span> <span class="tok-mh">0x0000501f0003ffc3</span><span class="tok-p">,</span>
  <span class="tok-cm">/* ... */</span>
  <span class="tok-mh">0x3fffffffffffffff</span><span class="tok-p">,</span> <span class="tok-mh">0xffffffffffff0000</span><span class="tok-p">,</span> <span class="tok-mh">0xfffffffffffcffff</span><span class="tok-p">,</span> <span class="tok-mh">0x0fff0000000000ff</span><span class="tok-p">,</span>
  <span class="tok-mh">0x0000000000000000</span><span class="tok-p">,</span> <span class="tok-mh">0xffdf000000000000</span><span class="tok-p">,</span> <span class="tok-mh">0xffffffffffffffff</span><span class="tok-p">,</span> <span class="tok-mh">0x1fffffffffffffff</span><span class="tok-p">,</span>
  <span class="tok-mh">0x07fffffe03ff0000</span><span class="tok-p">,</span> <span class="tok-mh">0xffffffc007fffffe</span><span class="tok-p">,</span> <span class="tok-mh">0x7fffffffffffffff</span><span class="tok-p">,</span> <span class="tok-mh">0x000000001cfcfcfc</span><span class="tok-p">,</span>
<span class="tok-p">};</span>

<span class="tok-kr">inline</span> <span class="tok-kt">bool</span> <span class="tok-nf">IsAlphanum</span><span class="tok-p">(</span><span class="tok-kt">unsigned</span> <span class="tok-kt">int</span> <span class="tok-n">c</span><span class="tok-p">)</span> <span class="tok-p">{</span>
  <span class="tok-k">return</span> <span class="tok-p">(</span><span class="tok-n">kAlphanumTable</span><span class="tok-p">[</span><span class="tok-n">c</span><span class="tok-o">/</span><span class="tok-mi">64</span><span class="tok-p">]</span> <span class="tok-o">&gt;&gt;</span> <span class="tok-p">(</span><span class="tok-n">c</span><span class="tok-o">%</span><span class="tok-mi">64</span><span class="tok-p">))</span> <span class="tok-o">&amp;</span> <span class="tok-mh">0x1</span><span class="tok-p">;</span>
<span class="tok-p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<div class="title">Choosing hash function</div>
<p>Before we continue forward, let&#8217;s choose hash function.
We want it to be relatively fast to compute but complex enough to be robust to permutations,
e.g. we want for "word1 word2 word3" and "word1 word3 word2" to be hashed to different values.
Thus, per-character XOR is a bad idea.
Taking into consideration the above requirements, I chose
<a href="https://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function">FNV-1a</a>.
It is well studied, widely used in practice (glibc implements <code>std::hash&lt;T&gt;</code> by using it),
not very expensive (two multiplications per 16-bit character), and also easy to code.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cpp"><span class="tok-kt">uint32_t</span> <span class="tok-nf">fnv1a</span><span class="tok-p">(</span><span class="tok-k">const</span> <span class="tok-kt">uint16_t</span><span class="tok-o">*</span> <span class="tok-n">str</span><span class="tok-p">,</span> <span class="tok-kt">int</span> <span class="tok-n">len</span><span class="tok-p">)</span> <span class="tok-p">{</span>
  <span class="tok-kt">uint32_t</span> <span class="tok-n">hash</span> <span class="tok-o">=</span> <span class="tok-mi">2166136261</span><span class="tok-p">;</span>
  <span class="tok-k">for</span> <span class="tok-p">(</span><span class="tok-kt">size_t</span> <span class="tok-n">i</span> <span class="tok-o">=</span> <span class="tok-mi">0</span><span class="tok-p">;</span> <span class="tok-n">i</span> <span class="tok-o">&lt;</span> <span class="tok-n">len</span><span class="tok-p">;</span> <span class="tok-n">i</span><span class="tok-o">++</span><span class="tok-p">)</span> <span class="tok-p">{</span>
    <span class="tok-kt">uint16_t</span> <span class="tok-n">c</span> <span class="tok-o">=</span> <span class="tok-n">str</span><span class="tok-p">[</span><span class="tok-n">i</span><span class="tok-p">];</span>
    <span class="tok-n">hash</span> <span class="tok-o">=</span> <span class="tok-n">hash</span> <span class="tok-o">^</span> <span class="tok-p">(</span><span class="tok-n">c</span> <span class="tok-o">&amp;</span> <span class="tok-mh">0xff</span><span class="tok-p">);</span>
    <span class="tok-n">hash</span> <span class="tok-o">=</span> <span class="tok-n">hash</span> <span class="tok-o">*</span> <span class="tok-mi">16777619</span><span class="tok-p">;</span>
    <span class="tok-n">hash</span> <span class="tok-o">=</span> <span class="tok-n">hash</span> <span class="tok-o">^</span> <span class="tok-p">(</span><span class="tok-n">c</span> <span class="tok-o">&gt;&gt;</span> <span class="tok-mi">16</span><span class="tok-p">);</span>
    <span class="tok-n">hash</span> <span class="tok-o">=</span> <span class="tok-n">hash</span> <span class="tok-o">*</span> <span class="tok-mi">16777619</span><span class="tok-p">;</span>
  <span class="tok-p">}</span>
  <span class="tok-k">return</span> <span class="tok-n">hash</span><span class="tok-p">;</span>
<span class="tok-p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<div class="title">Generating shingles</div>
<p>First place where we can get significant gains in performance is shingle generation algorithm.
Below pseudocode demonstrates naive implementation.
It is implemented exactly as visualized in the very first image.
First, we split text into an array of separate words.
Next we are iterating over every sequence of K=3 adjacent words, compute and emit hash.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code>words[] = Tokenize(text)
for i := 0 .. words.length()-3:
  hash = InitHash()
  for k := 0 .. 2:
    for j := 0 .. words[i+k].length
      hash = UpdateHash(hash, words[i+k][j])
  Collect(hash)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Noticeable issue is that a copy of input text is made into the words array.
It shouldn&#8217;t be very hard to avoid copying because shingling is a type of streaming algorithm,
i.e. we need only to keep track of a window of K=3 consecutive words at a time.</p>
</div>
<div class="paragraph">
<p>But we can do even better by implementing pipeline.
To do this, we are going to store K=3 partially computed hashes.
All these hashes are updated every time we read new alphanumeric character.
When the word is over, the head of the pipline is the full hash of the previous K words,
next element after the head is the partial hash for the last K-1 words, and so on.
So, when the word is over, we eject the head of the pipeline and shift
the remaining hashes.</p>
</div>
<div class="imageblock" style="text-align: center">
<div class="content">
<img src="pipeline.png" alt="pipeline" width="80%">
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cpp"><span class="tok-k">template</span><span class="tok-o">&lt;</span><span class="tok-kt">int</span> <span class="tok-n">K</span><span class="tok-o">&gt;</span> <span class="tok-c1">// shingle length in words, e.g. K=3</span>
<span class="tok-k">const</span> <span class="tok-kt">uint16_t</span><span class="tok-o">*</span> <span class="tok-n">txt</span><span class="tok-p">;</span> <span class="tok-c1">// arg</span>
<span class="tok-kt">int</span> <span class="tok-n">txt_length</span><span class="tok-p">;</span> <span class="tok-c1">// arg</span>
<span class="tok-p">...</span>

<span class="tok-c1">// main loop</span>
<span class="tok-kt">size_t</span> <span class="tok-n">i</span> <span class="tok-o">=</span> <span class="tok-mi">0</span><span class="tok-p">;</span>
<span class="tok-kt">uint32_t</span> <span class="tok-n">pipeline</span><span class="tok-p">[</span><span class="tok-n">K</span><span class="tok-p">];</span>
<span class="tok-k">while</span> <span class="tok-p">(</span><span class="tok-n">i</span> <span class="tok-o">&lt;</span> <span class="tok-n">txt_length</span><span class="tok-p">)</span> <span class="tok-p">{</span>
  <span class="tok-c1">// process next word</span>
  <span class="tok-k">while</span> <span class="tok-p">(</span><span class="tok-n">i</span> <span class="tok-o">&lt;</span> <span class="tok-n">txt_length</span> <span class="tok-o">&amp;&amp;</span> <span class="tok-n">IsAlphanum</span><span class="tok-p">(</span><span class="tok-n">txt</span><span class="tok-p">[</span><span class="tok-n">i</span><span class="tok-p">]))</span> <span class="tok-p">{</span>
    <span class="tok-kt">uint16_t</span> <span class="tok-n">c</span> <span class="tok-o">=</span> <span class="tok-n">txt</span><span class="tok-p">[</span><span class="tok-n">i</span><span class="tok-p">];</span>
    <span class="tok-k">for</span> <span class="tok-p">(</span><span class="tok-kt">int</span> <span class="tok-n">k</span> <span class="tok-o">=</span> <span class="tok-mi">0</span><span class="tok-p">;</span> <span class="tok-n">k</span> <span class="tok-o">&lt;</span> <span class="tok-n">K</span><span class="tok-p">;</span> <span class="tok-n">k</span><span class="tok-o">++</span><span class="tok-p">)</span> <span class="tok-p">{</span>
      <span class="tok-n">pipeline</span><span class="tok-p">[</span><span class="tok-n">k</span><span class="tok-p">]</span> <span class="tok-o">=</span> <span class="tok-n">pipeline</span><span class="tok-p">[</span><span class="tok-n">k</span><span class="tok-p">]</span> <span class="tok-o">^</span> <span class="tok-p">(</span><span class="tok-n">c</span> <span class="tok-o">&amp;</span> <span class="tok-mh">0xff</span><span class="tok-p">);</span>
      <span class="tok-n">pipeline</span><span class="tok-p">[</span><span class="tok-n">k</span><span class="tok-p">]</span> <span class="tok-o">=</span> <span class="tok-n">pipeline</span><span class="tok-p">[</span><span class="tok-n">k</span><span class="tok-p">]</span> <span class="tok-o">*</span> <span class="tok-mi">16777619</span><span class="tok-p">;</span>
      <span class="tok-n">pipiline</span><span class="tok-p">[</span><span class="tok-n">k</span><span class="tok-p">]</span> <span class="tok-o">=</span> <span class="tok-n">pipeline</span><span class="tok-p">[</span><span class="tok-n">k</span><span class="tok-p">]</span> <span class="tok-o">^</span> <span class="tok-p">(</span><span class="tok-n">c</span> <span class="tok-o">&gt;&gt;</span> <span class="tok-mi">16</span><span class="tok-p">);</span>
      <span class="tok-n">pipeline</span><span class="tok-p">[</span><span class="tok-n">k</span><span class="tok-p">]</span> <span class="tok-o">=</span> <span class="tok-n">pipeline</span><span class="tok-p">[</span><span class="tok-n">k</span><span class="tok-p">]</span> <span class="tok-o">*</span> <span class="tok-mi">16777619</span><span class="tok-p">;</span>
    <span class="tok-p">}</span>
    <span class="tok-n">i</span><span class="tok-o">++</span><span class="tok-p">;</span>
  <span class="tok-p">}</span>

  <span class="tok-c1">// collect head of the pipeline</span>
  <span class="tok-n">Collect</span><span class="tok-p">(</span><span class="tok-n">pipeline</span><span class="tok-p">[</span><span class="tok-mi">0</span><span class="tok-p">]);</span>

  <span class="tok-c1">// shift pipeline</span>
  <span class="tok-k">for</span> <span class="tok-p">(</span><span class="tok-kt">int</span> <span class="tok-n">k</span> <span class="tok-o">=</span> <span class="tok-mi">0</span><span class="tok-p">;</span> <span class="tok-n">k</span> <span class="tok-o">&lt;</span> <span class="tok-n">K</span><span class="tok-o">-</span><span class="tok-mi">1</span><span class="tok-p">;</span> <span class="tok-n">k</span><span class="tok-o">++</span><span class="tok-p">)</span> <span class="tok-p">{</span>
    <span class="tok-n">pipeline</span><span class="tok-p">[</span><span class="tok-n">k</span><span class="tok-p">]</span> <span class="tok-o">=</span> <span class="tok-n">pipeline</span><span class="tok-p">[</span><span class="tok-n">k</span><span class="tok-o">+</span><span class="tok-mi">1</span><span class="tok-p">];</span>
  <span class="tok-p">}</span>
  <span class="tok-n">pipeline</span><span class="tok-p">[</span><span class="tok-n">K</span><span class="tok-o">-</span><span class="tok-mi">1</span><span class="tok-p">]</span> <span class="tok-o">=</span> <span class="tok-mi">2166136261</span><span class="tok-p">;</span>

  <span class="tok-c1">// skip delimiter</span>
  <span class="tok-k">while</span> <span class="tok-p">(</span><span class="tok-n">i</span> <span class="tok-o">&lt;</span> <span class="tok-n">txt_length</span> <span class="tok-o">&amp;&amp;</span> <span class="tok-o">!</span><span class="tok-n">IsAlphanum</span><span class="tok-p">(</span><span class="tok-n">txt</span><span class="tok-p">[</span><span class="tok-n">i</span><span class="tok-p">]))</span> <span class="tok-p">{</span>
    <span class="tok-n">i</span><span class="tok-o">++</span><span class="tok-p">;</span>
  <span class="tok-p">}</span>
<span class="tok-p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>It is important that K is known at compile time and is not a runtime argument.
Because K is small (K=3 in our case), compiler unrolls the loop:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="asm"><span class="tok-nf">xorl</span>  <span class="tok-o">%</span><span class="tok-nb">edx</span><span class="tok-p">,</span> <span class="tok-o">%</span><span class="tok-nb">eax</span>
<span class="tok-nf">xorl</span>  <span class="tok-o">%</span><span class="tok-nb">edx</span><span class="tok-p">,</span> <span class="tok-o">%</span><span class="tok-nb">r13d</span>
<span class="tok-nf">xorl</span>  <span class="tok-o">%</span><span class="tok-nb">r12d</span><span class="tok-p">,</span> <span class="tok-o">%</span><span class="tok-nb">edx</span>
<span class="tok-nf">imull</span> <span class="tok-kc">$</span><span class="tok-mi">637696617</span><span class="tok-p">,</span> <span class="tok-o">%</span><span class="tok-nb">eax</span><span class="tok-p">,</span> <span class="tok-o">%</span><span class="tok-nb">eax</span>
<span class="tok-nf">imull</span> <span class="tok-kc">$</span><span class="tok-mi">637696617</span><span class="tok-p">,</span> <span class="tok-o">%</span><span class="tok-nb">r13d</span><span class="tok-p">,</span> <span class="tok-o">%</span><span class="tok-nb">r13d</span>
<span class="tok-nf">imull</span> <span class="tok-kc">$</span><span class="tok-mi">637696617</span><span class="tok-p">,</span> <span class="tok-o">%</span><span class="tok-nb">edx</span><span class="tok-p">,</span> <span class="tok-o">%</span><span class="tok-nb">r12d</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Unrolling has obvious benefit of avoiding conditional check at every iteration.
But more important is that because iterations are independent from one another,
CPU can execute instructions in parallel.
This leads to significant speedup.</p>
</div>
<div class="paragraph">
<div class="title">Selecting smallest hashes</div>
<p>The most naive way would be to collect all hashes into a vector, sort them and then return smallest N hashes.
Experienced algorithmist may know a way to do this without sorting all hashes, by using <code>std::partial_sort</code>.
Its idea is similar to quick sort: at every step we choose pivot and exchange
elements so that in the end array consists of two groups of elements:
elements which are less or equal to pivot go to the beginning, while elements larger than pivot
go into the end of the array.
We repeat the process multiple times always by using left group.
Right group is of no importance and is ignored.</p>
</div>
<div class="paragraph">
<p>But <code>std::partial_sort</code> still implies that we need to collect all hashes to somewhere.
This may be unfeasable for large texts.
We would like to design streaming algorithm with O(N) space.
This leads to the idea of storing N smallest hash values in sorted array.
As such, we can check the presense of an element in O(log N).
Inserting is more expensive because it requires to shift N/2 elements on average.</p>
</div>
<div class="paragraph">
<p>Even better idea is to use heap.
It would make insert really fast.
But the trouble is that our values are not unique,
and checking for element existance in a heap is O(N) time.
To avoid such expensive check, in addition to heap we can maintain
a hash table that would guard heap from receiving duplicate elements.
So, now the algorithm becomes like this: for every incoming hash,
check that it is smaller than <code>heap.peek()</code>,
check that it is not present in the hash table,
and if both conditions are satisfied, then update both heap and hash table by removing
<code>heap.peek()</code> element and inserting hash at hand.</p>
</div>
<div class="paragraph">
<p>This version is asymptocitally optimal, but it still has some problems related to the nature of hash table.
Classical hash table uses dynamical memory allocations, linked lists and it also hashes value,
even though our elements are already high quality hashes.
What if we could replace classical hash table with a simpler one?
We know the number of elements we are going to store in it in advance and also we have
copy of all elements in a heap, so we have something to offer in return.
After some time spent on thinking and benchmarking, this leads to the following solution.
Classical hash table is replaced with manually created hash table with the following properties:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>It is just an array of 4N uint32_t slots.
No more than 2N elements are going to be stored at any given time to ensure search/insert in O(1) time.</p>
</li>
<li>
<p>Special uint32_t value denotes empty slot.</p>
</li>
<li>
<p>Elements are inserted by using linear probing: if the desired slot is occupied,
we scan table below until we find free slot.
This is safe because no more than 2N elements will ever be stored there.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The tradeoff is that such implementation doesn&#8217;t allow deletions.
But this is not a problem.
As soon as table becomes 2N full, we just remove all elements from the table and repopulate it from the heap.
As such, load factor of the table oscillates betwen 0.25 and 0.5.</p>
</div>
<div class="imageblock" style="text-align: center">
<div class="content">
<img src="dataflow.png" alt="dataflow" width="100%">
</div>
</div>
<div class="paragraph">
<p>Below is the pseudo-code for the main loop:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code>def Collect(h):
  if h &lt; heap[0]:
    if !htable.contains(h):
      htable.insert(h)
      heap.pop(heap)
      heap.push(heap, h)

      if htable.size() &gt;= N*2:
        htable.clear()
        for i := 0 .. heap.size()-1:
          htable.insert(heap[i])</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the result we have a solution with O(1) time to check whether an element exists,
and with O(log N) insertion time.
Occasionally hash table must be repopulated, but this happens rarely and thus
its contribution to the total time is negligible.</p>
</div>
<div class="paragraph">
<div class="title">Evaluation</div>
<p>Test collection consists of 1000 long articles from wikipedia,
varying in size from 16KB to 540KB.</p>
</div>
<table class="tableblock frame-all grid-all" style="width: 70%;">
<colgroup>
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top"></th>
<th class="tableblock halign-right valign-top">Time [s]</th>
<th class="tableblock halign-right valign-top">MChars/s</th>
<th class="tableblock halign-right valign-top">Speedup</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">naive</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock">0.939594</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock">52.7</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock">1.0</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">pipeline + sort</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock">0.513581</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock">96.3</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock">1.8</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">pipeline + unordered_set + heap</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock">0.276099</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock">179.2</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock">3.4</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">pipeline + custom htable + heap</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock">0.177911</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock">278.1</p></td>
<td class="tableblock halign-right valign-top"><p class="tableblock">5.3</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>First version is the most basic, reference implementation of everything.
Second version uses pipelined shingle generation, but still collects and sorts all hashes to find N smallest.
Third version uses heap to find N smallest hashes, guarded by <code>std::unordered_set&lt;uint32_t&gt;</code>.
Final version is the modification where unordered set is replaced with custom hash table.
It reaches throughput of 278M characters per second&#8201;&#8212;&#8201;more than enough not to be a bottleneck
in the data pipeline.</p>
</div>
<div class="paragraph">
<div class="title">Pair-wise computation</div>
<p>TBD</p>
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2019-06-21 15:52:07 UTC
</div>
</div>
</body>
</html>