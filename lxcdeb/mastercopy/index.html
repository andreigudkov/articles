<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]-->
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 1.5.8">
<meta name="author" content="Andrei Gudkov">
<title>Setting up LXC on Debian desktop</title>
<style>
/*! normalize.css v2.1.2 | MIT License | git.io/normalize */article,aside,details,figcaption,figure,footer,header,hgroup,main,nav,section,summary{display:block}audio,canvas,video{display:inline-block}audio:not([controls]){display:none;height:0}[hidden],template{display:none}script{display:none !important}html{font-family:sans-serif;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}a{background:transparent}a:focus{outline:thin dotted}a:active,a:hover{outline:0}h1{font-size:2em;margin:.67em 0}abbr[title]{border-bottom:1px dotted}b,strong{font-weight:bold}dfn{font-style:italic}hr{-moz-box-sizing:content-box;box-sizing:content-box;height:0}mark{background:#ff0;color:#000}code,kbd,pre,samp{font-family:monospace,serif;font-size:1em}pre{white-space:pre-wrap}q{quotes:"\201C" "\201D" "\2018" "\2019"}small{font-size:80%}sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}sup{top:-0.5em}sub{bottom:-0.25em}img{border:0}svg:not(:root){overflow:hidden}figure{margin:0}fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}legend{border:0;padding:0}button,input,select,textarea{font-family:inherit;font-size:100%;margin:0}button,input{line-height:normal}button,select{text-transform:none}button,html input[type="button"],input[type="reset"],input[type="submit"]{-webkit-appearance:button;cursor:pointer}button[disabled],html input[disabled]{cursor:default}input[type="checkbox"],input[type="radio"]{box-sizing:border-box;padding:0}input[type="search"]{-webkit-appearance:textfield;-moz-box-sizing:content-box;-webkit-box-sizing:content-box;box-sizing:content-box}input[type="search"]::-webkit-search-cancel-button,input[type="search"]::-webkit-search-decoration{-webkit-appearance:none}button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}textarea{overflow:auto;vertical-align:top}table{border-collapse:collapse;border-spacing:0}*,*::before,*::after{box-sizing:border-box;margin:0}body{font-family:Helvetica,Arial,sans-serif;font-size:16px;color:#222;line-height:1.5;max-width:55em;margin:0 auto}#content,#footnotes{padding-left:.5em;padding-right:.5em}strong{font-weight:bold}em{font-style:italic}:not(pre)>code{font-family:Courier,monospace;line-height:1.0}a{color:#0061c5;text-decoration:none}a:hover{text-decoration:underline}hr{border-width:0 0 1px 0;border-style:solid;border-color:#678}ul,ol{list-style-position:outside;padding-left:0;margin-left:2em}ul li ul,ul li ol,ol li ul,ol li ol{margin-left:1.414em}ul>li{list-style-type:square;font-size:80%}ul>li>*{font-size:125%}ol>li{font-weight:bold}ol>li>*{font-weight:normal}ol.arabic{list-style-type:decimal}ol.decimal{list-style-type:decimal-leading-zero}ol.loweralpha{list-style-type:lower-alpha}ol.upperalpha{list-style-type:upper-alpha}ol.lowerroman{list-style-type:lower-roman}ol.upperroman{list-style-type:upper-roman}ol.lowergreek{list-style-type:lower-greek}.dlist dt{color:#325d72;font-weight:bold}.dlist dt:not(:first-child){margin-top:1em}.dlist dd{margin-left:2em}td.hdlist1{color:#325d72;padding-right:.5em;vertical-align:top}td.hdlist2{padding-bottom:.5em}h1{font-size:28px;font-weight:normal;letter-spacing:-1px;color:white;background-color:#325d72;text-align:center;margin:0 0 .5em 0;padding:.05em .5em}@media print{h1{color:#325d72;background-color:white;font-weight:bold}}h1::after{content:':';width:0;overflow:hidden;display:inline-block;vertical-align:middle}.author{color:#325d72}.email::before{content:"<";color:#325d72}.email::after{content:">";color:#325d72}.author+br,.email+br{display:none}#author{padding-left:.5em}#toc{margin:1em 0 2em 0;padding-left:.5em}#toctitle{font-size:19px;font-weight:bold;color:#325d72;margin:.5em 0}#toc>ul{line-height:1.4;font-size:15px;margin:0 0 0 .5em}#toc ul li{list-style-type:none}#toc li{margin:0}.big{font-size:120%}.small{font-size:75%}.underline{text-decoration:underline}.overline{text-decoration:overline}.line-through{text-decoration:line-through}.aqua{color:#00bfbf}.aqua-background{background-color:#00fafa;border-radius:2px;padding:0 3px}.black{color:"black"}.black-background{background-color:"black";border-radius:2px;padding:0 3px}.blue{color:#0000bf}.blue-background{background-color:#0000fa;border-radius:2px;padding:0 3px}.fuchsia{color:#bf00bf}.fuchsia-background{background-color:#fa00fa;border-radius:2px;padding:0 3px}.gray{color:#606060}.gray-background{background-color:#7d7d7d;border-radius:2px;padding:0 3px}.green{color:#006000}.green-background{background-color:#007d00;border-radius:2px;padding:0 3px}.lime{color:#00bf00}.lime-background{background-color:#00fa00;border-radius:2px;padding:0 3px}.maroon{color:#600000}.maroon-background{background-color:#7d0000;border-radius:2px;padding:0 3px}.navy{color:#000060}.navy-background{background-color:#00007d;border-radius:2px;padding:0 3px}.olive{color:#606000}.olive-background{background-color:#7d7d00;border-radius:2px;padding:0 3px}.purple{color:#600060}.purple-background{background-color:#7d007d;border-radius:2px;padding:0 3px}.red{color:#bf0000}.red-background{background-color:#fa0000;border-radius:2px;padding:0 3px}.silver{color:#909090}.silver-background{background-color:#bcbcbc;border-radius:2px;padding:0 3px}.teal{color:#006060}.teal-background{background-color:#007d7d;border-radius:2px;padding:0 3px}.white{color:#bfbfbf}.white-background{background-color:#fafafa;border-radius:2px;padding:0 3px}.yellow{color:#bfbf00}.yellow-background{background-color:#fafa00;border-radius:2px;padding:0 3px}table.tableblock{border:1px solid #91a7b3;margin-left:auto;margin-right:auto}table.tableblock>caption.title{text-align:left;margin-bottom:.5em}table.tableblock>colgroup>col{width:inherit !important}table.tableblock>tbody>tr>td{border-style:solid;border-color:#91a7b3;border-width:0 1px;padding:0 5px 2px 5px}table.tableblock>tbody>tr:nth-of-type(2n){background-color:#f8f8f8}p.tableblock{text-align:inherit}table.tableblock>thead>tr>td,table.tableblock>thead>tr>th,table.tableblock>tfoot>tr>td,table.tableblock>tfoot>tr>th{color:#325d72;font-weight:bold;line-height:1.35;padding:2px 5px;border:1px solid #91a7b3}table.tableblock>thead>tr>th,table.tableblock>thead>tr>td{border-bottom-width:2px}table.tableblock>tfoot>tr>th,table.tableblock>tfoot>tr>td{border-top-width:2px}th.halign-left,td.halign-left{text-align:left}th.halign-right,td.halign-right{text-align:right}th.halign-center,td.halign-center{text-align:center}th.valign-top,td.valign-top{vertical-align:top}th.valign-bottom,td.valign-bottom{vertical-align:bottom}th.valign-middle,td.valign-middle{vertical-align:middle}div.listingblock{padding:.5em;border-style:solid;border-color:#678;border-width:0 0 0 2px;background-color:#f8f8f8;overflow:auto}div.listingblock .title{text-align:right}div.listingblock pre{font-family:Menlo,Consolas,Monaco,"Lucida Console",monospace;font-size:87.5%;white-space:pre;background-color:#f8f8f8 !important;margin:0}div.listingblock td.linenos{border-right:1px solid #91a7b3;padding-right:.67em}div.listingblock table.pyhltable div.linenodiv{color:#678;text-align:right}div.listingblock table.pyhltable td.code{padding-left:.67em}div.imageblock>div.content>img{max-width:98%}.text-indent{padding-left:2em}img.inlinemath{image-rendering:optimizequality;margin-top:.5ex}h2,h3,h4{font-weight:normal;color:#325d72;margin:0}h2{font-size:27px;letter-spacing:-1px;border-bottom:1px solid #91a7b3}h3{font-size:24px;letter-spacing:-0.75px}h4{font-size:21px;letter-spacing:-0.5px}.title{color:#325d72;font-weight:bold}#footer{font-size:80%;color:white;background-color:#325d72}@media print{#footer{color:#325d72;background-color:white;font-weight:bold}}#footer-text{text-align:center;padding:.5em}#footer-badges{display:none}span.footnote{vertical-align:super;font-size:80%}#footnotes>hr{display:none}#footnotes::before{display:block;border-bottom:1px solid #678;margin:.5em 0;content:"Notes";font-size:19px;font-weight:bold;color:#325d72}#footnotes .footnote{margin-left:.5em;font-size:15px}hr:not(:first-child){margin-top:1.5em}hr:not(:last-child){margin-bottom:1.5em}.imageblock:not(:last-child),.listingblock:not(:last-child),.tableblock:not(:last-child){margin-bottom:1em}p+*{margin-top:1em}.paragraph+*{margin-top:1em}p+.ulist,p+.olist,p+.dlist,p+.hdlist,.paragraph+.ulist,.paragraph+.olist,.paragraph+.dlist,.paragraph+.hdlist,.paragraph+.listingblock{margin-top:.5em !important}li *+.ulist,li *+.olist,li *+.dlist,li *+.hdlist{margin-top:.1em !important}.title:not(:first-child){margin-top:1.5em}.content+.title{margin-top:.5em !important}.title+*{margin-top:1.5em}.title+p,.title+.paragraph,.title+.ulist,.title+.olist,.title+.dlist,.title+.hdlist{margin-top:.5em !important}.ulist:not(:last-child){margin-bottom:1em}.olist:not(:last-child){margin-bottom:1em}li:not(:first-child){margin-top:.1em}.dlist:not(:last-child){margin-bottom:1em}.dlist:not(:first-child){margin-top:1em}.sect3:not(:last-child){margin-bottom:18px}.sect3:not(:first-child){margin-top:18px}h4:not(:last-child){margin-bottom:9px}.sect2:not(:last-child){margin-bottom:22px}.sect2:not(:first-child){margin-top:22px}h3:not(:last-child){margin-bottom:11px}.sect1:not(:last-child){margin-bottom:40px}.sect1:not(:first-child){margin-top:40px}#preamble:not(:last-child){margin-bottom:40px}h2:not(:last-child){margin-bottom:13px}#header:not(:last-child),#content:not(:last-child),#footnotes:not(:last-child){margin-bottom:2em}.text-left{text-align:left}.text-center{text-align:center}.text-right{text-align:right}
</style>
<style>
.listingblock .pygments .hll { background-color: #ffffcc }
.listingblock .pygments, .listingblock .pygments code { background: #f8f8f8; }
.listingblock .pygments .tok-c { color: #408080; font-style: italic } /* Comment */
.listingblock .pygments .tok-err { border: 1px solid #FF0000 } /* Error */
.listingblock .pygments .tok-k { color: #008000; font-weight: bold } /* Keyword */
.listingblock .pygments .tok-o { color: #666666 } /* Operator */
.listingblock .pygments .tok-ch { color: #408080; font-style: italic } /* Comment.Hashbang */
.listingblock .pygments .tok-cm { color: #408080; font-style: italic } /* Comment.Multiline */
.listingblock .pygments .tok-cp { color: #BC7A00 } /* Comment.Preproc */
.listingblock .pygments .tok-cpf { color: #408080; font-style: italic } /* Comment.PreprocFile */
.listingblock .pygments .tok-c1 { color: #408080; font-style: italic } /* Comment.Single */
.listingblock .pygments .tok-cs { color: #408080; font-style: italic } /* Comment.Special */
.listingblock .pygments .tok-gd { color: #A00000 } /* Generic.Deleted */
.listingblock .pygments .tok-ge { font-style: italic } /* Generic.Emph */
.listingblock .pygments .tok-gr { color: #FF0000 } /* Generic.Error */
.listingblock .pygments .tok-gh { color: #000080; font-weight: bold } /* Generic.Heading */
.listingblock .pygments .tok-gi { color: #00A000 } /* Generic.Inserted */
.listingblock .pygments .tok-go { color: #888888 } /* Generic.Output */
.listingblock .pygments .tok-gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.listingblock .pygments .tok-gs { font-weight: bold } /* Generic.Strong */
.listingblock .pygments .tok-gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.listingblock .pygments .tok-gt { color: #0044DD } /* Generic.Traceback */
.listingblock .pygments .tok-kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.listingblock .pygments .tok-kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.listingblock .pygments .tok-kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.listingblock .pygments .tok-kp { color: #008000 } /* Keyword.Pseudo */
.listingblock .pygments .tok-kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.listingblock .pygments .tok-kt { color: #B00040 } /* Keyword.Type */
.listingblock .pygments .tok-m { color: #666666 } /* Literal.Number */
.listingblock .pygments .tok-s { color: #BA2121 } /* Literal.String */
.listingblock .pygments .tok-na { color: #7D9029 } /* Name.Attribute */
.listingblock .pygments .tok-nb { color: #008000 } /* Name.Builtin */
.listingblock .pygments .tok-nc { color: #0000FF; font-weight: bold } /* Name.Class */
.listingblock .pygments .tok-no { color: #880000 } /* Name.Constant */
.listingblock .pygments .tok-nd { color: #AA22FF } /* Name.Decorator */
.listingblock .pygments .tok-ni { color: #999999; font-weight: bold } /* Name.Entity */
.listingblock .pygments .tok-ne { color: #D2413A; font-weight: bold } /* Name.Exception */
.listingblock .pygments .tok-nf { color: #0000FF } /* Name.Function */
.listingblock .pygments .tok-nl { color: #A0A000 } /* Name.Label */
.listingblock .pygments .tok-nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
.listingblock .pygments .tok-nt { color: #008000; font-weight: bold } /* Name.Tag */
.listingblock .pygments .tok-nv { color: #19177C } /* Name.Variable */
.listingblock .pygments .tok-ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
.listingblock .pygments .tok-w { color: #bbbbbb } /* Text.Whitespace */
.listingblock .pygments .tok-mb { color: #666666 } /* Literal.Number.Bin */
.listingblock .pygments .tok-mf { color: #666666 } /* Literal.Number.Float */
.listingblock .pygments .tok-mh { color: #666666 } /* Literal.Number.Hex */
.listingblock .pygments .tok-mi { color: #666666 } /* Literal.Number.Integer */
.listingblock .pygments .tok-mo { color: #666666 } /* Literal.Number.Oct */
.listingblock .pygments .tok-sa { color: #BA2121 } /* Literal.String.Affix */
.listingblock .pygments .tok-sb { color: #BA2121 } /* Literal.String.Backtick */
.listingblock .pygments .tok-sc { color: #BA2121 } /* Literal.String.Char */
.listingblock .pygments .tok-dl { color: #BA2121 } /* Literal.String.Delimiter */
.listingblock .pygments .tok-sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.listingblock .pygments .tok-s2 { color: #BA2121 } /* Literal.String.Double */
.listingblock .pygments .tok-se { color: #BB6622; font-weight: bold } /* Literal.String.Escape */
.listingblock .pygments .tok-sh { color: #BA2121 } /* Literal.String.Heredoc */
.listingblock .pygments .tok-si { color: #BB6688; font-weight: bold } /* Literal.String.Interpol */
.listingblock .pygments .tok-sx { color: #008000 } /* Literal.String.Other */
.listingblock .pygments .tok-sr { color: #BB6688 } /* Literal.String.Regex */
.listingblock .pygments .tok-s1 { color: #BA2121 } /* Literal.String.Single */
.listingblock .pygments .tok-ss { color: #19177C } /* Literal.String.Symbol */
.listingblock .pygments .tok-bp { color: #008000 } /* Name.Builtin.Pseudo */
.listingblock .pygments .tok-fm { color: #0000FF } /* Name.Function.Magic */
.listingblock .pygments .tok-vc { color: #19177C } /* Name.Variable.Class */
.listingblock .pygments .tok-vg { color: #19177C } /* Name.Variable.Global */
.listingblock .pygments .tok-vi { color: #19177C } /* Name.Variable.Instance */
.listingblock .pygments .tok-vm { color: #19177C } /* Name.Variable.Magic */
.listingblock .pygments .tok-il { color: #666666 } /* Literal.Number.Integer.Long */
</style>
</head>
<body class="article">
<div id="header">
<h1>Setting up LXC on Debian desktop</h1>
<div class="details">
<span id="author" class="author">Andrei Gudkov</span><br>
<span id="email" class="email"><a href="mailto:gudokk@gmail.com">gudokk@gmail.com</a></span><br>
</div>
<div id="toc" class="toc">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#_introduction">Introduction</a></li>
<li><a href="#_creating_containers_from_prebuilt_images">Creating containers from prebuilt images</a></li>
<li><a href="#_creating_containers_using_custom_templates">Creating containers using custom templates</a></li>
<li><a href="#_environment_variables">Environment variables</a></li>
<li><a href="#_accessing_host_data">Accessing host data</a></li>
<li><a href="#_network_basic_setup">Network: basic setup</a></li>
<li><a href="#_network_better_dns">Network: better DNS</a></li>
<li><a href="#_network_protecting_lan_from_containers">Network: protecting LAN from containers</a></li>
<li><a href="#_x11_applications_via_ssh">X11 applications via SSH</a></li>
<li><a href="#_x11_applications_via_unix_socket">X11 applications via unix socket</a></li>
<li><a href="#_pulseaudio">PulseAudio</a></li>
<li><a href="#_webcam">Webcam</a></li>
<li><a href="#_application_troubleshooting">Application troubleshooting</a></li>
<li><a href="#_caching_packages">Caching packages</a></li>
<li><a href="#_unprivileged_containers">Unprivileged containers</a></li>
</ul>
</div>
</div>
<div id="content">
<div class="sect1">
<h2 id="_introduction">Introduction</h2>
<div class="sectionbody">
<div class="paragraph">
<div class="title">Why containers on workstation?</div>
<p>Containers are usually associated with high-end server boxes.
This is exactly the place where they first appeared.
At some point during evolution of hardware, computational power of single server box
became high enough to host dozens of independent services side by side.
This created problems with resource prioritization and security.
Eventually container technology emerged.
It allowed developers to lock every single service into separate, isolated, secure environment
with only small performance overhead.
Moreover, developers gained precise tool to distribute system resources among these environments.</p>
</div>
<div class="paragraph">
<p>The reasons to use containers in a workstation are different.
The first one is to isolate binary non-trusted applications,
such as messengers, games, IDEs and CADs&#8201;&#8212;&#8201;actually, any software
that requires connectivity to the Internet but cannot be audited
because it is not open source.
Who knows what information about the user such software collects and sends to the outside?
To install such an application directly to the host system would be unhygienic to say the least.
It would nullify all the hard work performed by Linux developers and maintainers
regarding security and privacy protection.
Browsers can also be considered insecure, partly because of constant stream of bugs
and partly because JavaScript is allowed to do nasty things, such as scanning
local ports and querying for geolocation.
Confining browser in a container is more robust solution to this problem
than installing protective browser plugins.</p>
</div>
<div class="paragraph">
<p>Another good reason to use containers on workstation stems from the necessity
to work with third-party software that requires hard-to-meet dependencies.
All Linux distributions adhere to the philosophy of packing every&#8201;&#8212;&#8201;no matter how small&#8201;&#8212;&#8201;library into separate versioned package.
As such, some third-party software may require installation of dozens of dependencies,
often of specific versions, not provided by your Linux distribution.
Situation is aggravated when you need to install a package created for another distribution
(e.g. Debian package for Ubuntu or vice versa), since different distributions use
somewhat different naming and versioning schemes for their packages.
Creating separate container for such software makes dependency satisfaction natural
and without performing any modifications to the host system.
You can run multiple containers in parallel with different Linux distributions and/or distribution releases
depending on third-party software requirements.
You can also compile source code from scratch and run infamous "make install" inside the container.
If you spoil some container too much or break it, you can cheaply recreate it from scratch.</p>
</div>
<div class="paragraph">
<p>Containers on workstation also simplify local debugging of cluster architectures.
The idea is to create a scaled-down copy of large production cluster in a developer&#8217;s workstation.
Every physical node is instantiated locally as a container (possibly with container nesting if you use
containers in production cluster).
Such scaled-down copy is a full representation of the large production cluster,
with all the components and interconnections present.
A huge part of errors can be discovered and debugged locally while running tests in such setup
before moving to large-scale integration testing with real hardware and network.</p>
</div>
<div class="paragraph">
<div class="title">Why not Docker or LXD?</div>
<p>There are currently plenty of container management software for Linux:
nearly monopolistic Docker, LXD over LXC, or LXC alone.
They work at different levels as roughly visualized below:</p>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="cstack.png" alt="cstack" width="90%">
</div>
</div>
<div class="paragraph">
<p>LXD and Docker are examples of high-level container managers which attempt
to create out-of-the box solution to deal with standard use cases.
LXC is located lower.
As such, it provides more control of what you are doing but demands more manual labour in return.
Whether you decide to use low-level LXC for container management or to switch to higher level
Docker or LXD, even single-time experience with LXC will provide you with a wealth of knowledge
about troubleshooting various Linux desktop subsystems.</p>
</div>
<div class="paragraph">
<p>The rest of the article is a step-by step instruction on how to setup
LXC containers in Debian "buster" for use in everyday desktop environment.
First section describes basic setup, and the following sections
add progressively information on networking, X server, PulseAudio and USB devices.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_creating_containers_from_prebuilt_images">Creating containers from prebuilt images</h2>
<div class="sectionbody">
<div class="paragraph">
<p>First section won&#8217;t be significantly different from the
<a href="https://linuxcontainers.org/lxc/getting-started/">guide</a> provided by LXC site.
Obviously we need to install lxc package first.
In the command below I also added additional option to apt-get as I always do
to avoid installing unnecessary packages.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="console"><span></span><span class="tok-gp">gudok@gudok6:~$</span> sudo apt-get --no-install-recommends install lxc</code></pre>
</div>
</div>
<div class="paragraph">
<p>LXC package brings a lot of lxc-* commands into the system.
Among the most widely used are lxc-create, lxc-start, lxc-info, lxc-stop and lxc-destroy
used to manage lifecycle of containers, and lxc-attach to connect to containers and run commands inside them.
The same package also installs two systemd services: lxc and lxc-net.
lxc-net is used to setup virtual network.
lxc service automatically starts those containers during boot time which were configured with autostart.
Virtual network is disabled by default and there are no containers present.
Thus these services do not spawn any daemons right after the installation.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="console"><span></span><span class="tok-gp">gudok@gudok6:~$</span> sudo systemctl status lxc-net
<span class="tok-go">● lxc-net.service - LXC network bridge setup</span>

<span class="tok-gp">gudok@gudok6:~$</span> sudo systemctl status lxc
<span class="tok-go">● lxc.service - LXC Container Initialization and Autoboot Code</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Everything is ready to create our first container.
There are two common ways of doing this.
The first one is to download prebuilt image provided by LXC team,
and another one is to build image from scratch with custom script.
Containers created in these two ways have a bit different set of initially installed packages and system settings.
We will try both of them.
lxc-create is the top-level command used to create new containers.
However, it doesn&#8217;t do it by itself.
Instead it calls one of the helper template scripts from <code>/usr/share/lxc/templates/</code>.
Every template defines its own set of options, which are passed from lxc-create.</p>
</div>
<div class="paragraph">
<p>The "lxc-download" template is the script used to download prebuilt images from LXC team.
Prebuilt images are available for all recent releases of well known linux distributions.
Let&#8217;s call it once directly to list its options and second time to list available images.
Second command connects to remote server and may take some time to complete as a consequence:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="console"><span></span><span class="tok-gp">gudok@gudok6:~$</span> /usr/share/lxc/templates/lxc-download --help
<span class="tok-go">LXC container image downloader</span>

<span class="tok-go">Special arguments:</span>
<span class="tok-go">[ -h | --help ]: Print this help message and exit</span>
<span class="tok-go">[ -l | --list ]: List all available images and exit</span>

<span class="tok-go">Required arguments:</span>
<span class="tok-go">[ -d | --dist &lt;distribution&gt; ]: The name of the distribution</span>
<span class="tok-go">[ -r | --release &lt;release&gt; ]: Release name/version</span>
<span class="tok-go">[ -a | --arch &lt;architecture&gt; ]: Architecture of the container</span>
<span class="tok-go">....</span>

<span class="tok-gp">gudok@gudok6:~$</span> /usr/share/lxc/templates/lxc-download --list <span class="tok-p">|</span> grep debian <span class="tok-p">|</span> grep amd64
<span class="tok-go">debian  bullseye amd64   default 20190825_05:24</span>
<span class="tok-go">debian  buster   amd64   default 20190825_05:24</span>
<span class="tok-go">debian  jessie   amd64   default 20190825_05:24</span>
<span class="tok-go">debian  sid      amd64   default 20190825_05:24</span>
<span class="tok-go">debian  stretch  amd64   default 20190826_05:24</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Now instruct lxc-create to use lxc-download template to create new container
from specified image (distribution, release, architecture) with given name ("ff" below).
Options after <code>--</code> are passed to the template script.
Important note is that all lxc-* commands should be run under root user.
This will create so-called "privileged" containers, which are easier to work with.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="console"><span></span><span class="tok-gp">gudok@gudok6:~$</span> sudo lxc-create -t /usr/share/lxc/templates/lxc-download -n ff -- -d debian -r buster -a amd64
<span class="tok-go">Unpacking the rootfs</span>
<span class="tok-go">You just created a Debian buster amd64 (20190825_05:24) container.</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Setup of the new container is over.
Now you can start it, attach to it and test it.
As with any Linux setup, the first steps inside the container
would be the installation of some essential packages,
such as less, vim, procps (top) and maybe openssh-server.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="console"><span></span><span class="tok-gp">gudok@gudok6:~$</span> sudo lxc-start -n ff
<span class="tok-gp">gudok@gudok6:~$</span> sudo lxc-attach -n ff
<span class="tok-gp">root@ff:/#</span> <span class="tok-nb">echo</span> <span class="tok-s1">&#39;Hello!&#39;</span>
<span class="tok-go">Hello!</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>This completes initial setup and now you can use newly created container for your needs.
Container management is done with lxc-* commands.
Take some time to accustom yourself to them.
The container is installed into <code>/var/lib/lxc/ff</code> and consists of simple
key/value configuration file along with root filesystem.
Default configuration file is enough to use container, albeit without networking and device access.
Read the configuration file and try to understand what its options are responsible for.
We will modify it later multiple times as we will be adding features to our container.
Some explanation of the options may be found in manual page <code>lxc.container.conf(5)</code>.
In addition to configuration file, there is also the root filesystem.
Its internals are the basic linux setup.
Shell on the host can be used to copy files directly to and from container&#8217;s filesystem
without using scp and directory mounting.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_creating_containers_using_custom_templates">Creating containers using custom templates</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Another way of creating containers is to build their images on the fly by using per-distribution templates.
Debian comes with a set of custom templates for Debian, Ubuntu, CentOS and other distributions.
These scripts build root file system either entirely from scratch or by using distribution&#8217;s recommended
tool, such as debootstrap in case of Debian.
The benefits of this method are that only Debian APT repository is accessed
and that template scripts can be easily adjusted to someone&#8217;s needs.
However, templates which come with Debian "buster" are deprecated in favor of downloading prebuilt packages.
Images produces by these templates are different from prebuilt packages and lack some features.
Anyway, I recommend to use this method at least once to understand the process under the hood.</p>
</div>
<div class="paragraph">
<p>Starting with Debian "buster", custom template scripts are not part of lxc package.
They were deprecated and moved into separate lxc-template package.
Installing it brings a lot of per-distribution templates, in our case we are interested in "lxc-debian" template.
Let&#8217;s use it to build new container.
The options of lxc-debian template are similar to that of lxc-download, i.e. we need to specify
desired release ("buster") and architecture ("amd64").
The command takes a couple of minutes to complete on the first run.
It internally calls debootstrap which downloads and unpacks a number of .deb packages
(lxc-create &#8594; lxc-debian template &#8594; debootstrap &#8594; package download).
After the first run, downloaded packages become cached, and further containers are created nearly instantaneously.
After calling debootstrap, lxc-debian template also heavily patches
newly created container filesystem.
It modifies its various configuration files in <code>/etc</code> among other things
because container setup differs significantly from setup on raw hardware.
You are encouraged to look into <code>/usr/share/lxc/templates/lxc-debian</code> to see what template script is doing.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="console"><span></span><span class="tok-gp">gudok@gudok6:~$</span> sudo apt-get install --no-install-recommends lxc-templates
<span class="tok-go">Setting up lxc-templates (3.0.3-1) ...</span>

<span class="tok-gp">gudok@gudok6:~$</span> sudo lxc-create -t /usr/share/lxc/templates/lxc-debian -n gg -- -r buster -a amd64
<span class="tok-go">debootstrap is /usr/sbin/debootstrap</span>
<span class="tok-go">Checking cache download in /var/cache/lxc/debian/rootfs-buster-amd64 ...</span>
<span class="tok-go">Creating SSH2 RSA key; this may take some time ...</span>
<span class="tok-go">2048 SHA256:7g5pkOI9NXcoVG09aRjKMllxBYJb1nvNLuavvJ7W2ZA root@gudok6 (RSA)</span>
<span class="tok-go">Current default time zone: &#39;Etc/UTC&#39;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_environment_variables">Environment variables</h2>
<div class="sectionbody">
<div class="paragraph">
<p>When attaching to a container, all host&#8217;s environment variables are propagated into container by default.
This may cause applications to malfunction, for example because they aware of some
environment variable that refers to a system resource present in the host but not in the container.
Additionally, if you have some secrets (passwords, URLs) set up as environment variables,
then they also will leak to the processes inside the container.
To be on the safe side, it is better to attach to containers by using <code>lxc-attach --clear-env -n &lt;container&gt;</code>.
This will disable propagation of host&#8217;s variables into the container.
The downside is that it clears too many variables.
So, in addition to <code>--clear-env</code> I recommend to manually set essential variables.
This can be done in <code>/etc/lxc/default.conf</code>.
After that containers must be restarted for changes to take effect.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="ini"><span></span><span class="tok-na">lxc.environment</span> <span class="tok-o">=</span> <span class="tok-s">USER=root</span>
<span class="tok-na">lxc.environment</span> <span class="tok-o">=</span> <span class="tok-s">HOME=/root</span>
<span class="tok-na">lxc.environment</span> <span class="tok-o">=</span> <span class="tok-s">TERM=xterm-256color</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_accessing_host_data">Accessing host data</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Mounting host filesystem nodes into container is easily done with bind mounts.
Bind mounts are closer to hard links rather than to true mounts.
They create another view of some already existing node.
Even better, bind mounts allow source node to be not necessarily a directory,
but also a plain file or a unix socket.
Created view may be set to readonly mode, and there is even no restriction
that source and target nodes must be present in the same filesystem instance.</p>
</div>
<div class="paragraph">
<p>Bind mounts are created by appending one or more <code>lxc.mount.entry</code> options
to configuration file of the container.
The value of this option has the same format as entries in <code>/etc/fstab</code>.
The most widely used options are <code>ro</code>/<code>rw</code> to select readonly or read/write permissions,
<code>bind</code> instructs to use bind mount, and LXC-specific <code>create=file</code> or <code>create=dir</code>
will automatically create target file/directory in a container for you if it doesn&#8217;t exist.</p>
</div>
<div class="paragraph">
<p>Note that absolute paths refer to host filesystem,
while relative paths are relative to container filesystem.
In the example below the first variant is the correct way of specifying mount entry.
The second variant is also correct and does exactly the same thing
but it is not so robust because of hardcoded path to container filesystem.
The third variant is wrong, because it instructs
to mount directory into host&#8217;s <code>/root/video</code>, not into the container&#8217;s one.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="ini"><span></span><span class="tok-na">lxc.mount.entry</span> <span class="tok-o">=</span> <span class="tok-s">/volume/DATA/video root/video none ro,bind,create=dir 0 0</span>
<span class="tok-na">lxc.mount.entry</span> <span class="tok-o">=</span> <span class="tok-s">/volume/DATA/video /var/lib/lxc/some_container_name/rootfs/root/video none ro,bind,create=dir 0 0</span>
<span class="tok-na">lxc.mount.entry</span> <span class="tok-o">=</span> <span class="tok-s">/volume/DATA/video /root/video none ro,bind,create=dir 0 0</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_network_basic_setup">Network: basic setup</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Nearly all modern software requires Internet connection.
Networking in container systems is ugly.
The most standard way to enable container networking in LXC is to create virtual switch.
Host machine and all containers "connect" to ports of this switch.
Additionally, host machine provides routing, DHCP and DNS capabilities
to containers.
This configuration looks like a typical local network, with the exception
that this is not a physical LAN, but is an emulated one:</p>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="net.svg" alt="net" width="60%">
</div>
</div>
<div class="paragraph">
<p>Of course, any non-standard network configuration is possible.
For example, someone might want to expose physical network interface to one of the containers,
or to create multiple virtual switches with one switch per every container.
The trouble is that any non-standard configuration would require writing a lot of scripts,
while the configuration described above is already implemented in scripts shipped with LXC package.
To enable it, you only need to modify one shell variable.
Create file <code>/etc/default/lxc-net</code> with the following contents:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="bash"><span></span><span class="tok-nv">USE_LXC_BRIDGE</span><span class="tok-o">=</span><span class="tok-nb">true</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Settings in this file override default values from <code>/usr/lib/x86_64-linux-gnu/lxc/lxc-net</code>
and from <code>/etc/default/lxc</code>.
Effective default settings are listed below, names are self-explanatory.
If your physical LAN uses 10.0.0.0/8, then you may want to change virtual network address
from 10.0.3.0/24 to some unused address range, e.g. to 192.168.20.0/24.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="bash"><span></span><span class="tok-nv">USE_LXC_BRIDGE</span><span class="tok-o">=</span><span class="tok-s2">&quot;false&quot;</span>
<span class="tok-nv">LXC_BRIDGE</span><span class="tok-o">=</span><span class="tok-s2">&quot;lxcbr0&quot;</span>
<span class="tok-nv">LXC_BRIDGE_MAC</span><span class="tok-o">=</span><span class="tok-s2">&quot;00:16:3e:00:00:00&quot;</span>
<span class="tok-nv">LXC_ADDR</span><span class="tok-o">=</span><span class="tok-s2">&quot;10.0.3.1&quot;</span>
<span class="tok-nv">LXC_NETMASK</span><span class="tok-o">=</span><span class="tok-s2">&quot;255.255.255.0&quot;</span>
<span class="tok-nv">LXC_NETWORK</span><span class="tok-o">=</span><span class="tok-s2">&quot;10.0.3.0/24&quot;</span>
<span class="tok-nv">LXC_DHCP_RANGE</span><span class="tok-o">=</span><span class="tok-s2">&quot;10.0.3.2,10.0.3.254&quot;</span>
<span class="tok-nv">LXC_DHCP_MAX</span><span class="tok-o">=</span><span class="tok-s2">&quot;253&quot;</span>
<span class="tok-nv">LXC_DHCP_CONFILE</span><span class="tok-o">=</span><span class="tok-s2">&quot;&quot;</span>
<span class="tok-nv">LXC_DHCP_PING</span><span class="tok-o">=</span><span class="tok-s2">&quot;true&quot;</span>
<span class="tok-nv">LXC_DOMAIN</span><span class="tok-o">=</span><span class="tok-s2">&quot;&quot;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Now restart the lxc-net service with <code>systemctl restart lxc-net</code> or reboot the workstation.
When lxc-net service is started, it will observe that <code>USE_LXC_BRIDGE</code> is true and
will setup virtual switch, connect host machine to this switch and start <code>dnsmasq</code> daemon,
that provides DHCP and DNS services to containers.</p>
</div>
<div class="paragraph">
<p>With virtual network present, you can instruct containers to connect to it.
To do this, add the following lines to <code>/etc/lxc/default.conf</code> and restart the containers.
This will enable networking in all containers.
Alternatively, you can edit configuration file of every container directly (<code>/var/lib/lxc/&lt;name&gt;/config</code>)
if you want to enable networking selectively.
Watch carefully option names, e.g. "net" vs "network".
Option names are different in LXC 2 and LXC 3.
Below settings are valid for LXC 3, which is shipped with Debian "buster".</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="ini"><span></span><span class="tok-na">lxc.net.0.type</span> <span class="tok-o">=</span> <span class="tok-s">veth</span>
<span class="tok-na">lxc.net.0.link</span> <span class="tok-o">=</span> <span class="tok-s">lxcbr0</span>
<span class="tok-na">lxc.net.0.flags</span> <span class="tok-o">=</span> <span class="tok-s">up</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Now inside every container that has networking enabled you will see good old <code>eth0</code> interface
up and running:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="console"><span></span><span class="tok-gp">root@ff:/#</span> /sbin/ifconfig -a
<span class="tok-go">eth0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span>
<span class="tok-go">        inet 10.0.3.243  netmask 255.255.255.0  broadcast 10.0.3.255</span>

<span class="tok-gp">root@ff:/#</span> apt-get install iputils-ping
<span class="tok-go">Get:1 http://deb.debian.org/debian buster/main amd64 iputils-ping amd64 3:20180629-2 [43.0 kB]</span>
<span class="tok-go">Setting up iputils-ping (3:20180629-2) ...</span>

<span class="tok-gp">root@ff:/#</span> ping <span class="tok-m">10</span>.0.3.1
<span class="tok-go">PING 10.0.3.1 (10.0.3.1) 56(84) bytes of data.</span>
<span class="tok-go">64 bytes from 10.0.3.1: icmp_seq=1 ttl=64 time=0.110 ms</span>

<span class="tok-gp">root@ff:/#</span> ping <span class="tok-m">1</span>.1.1.1
<span class="tok-go">PING 1.1.1.1 (1.1.1.1) 56(84) bytes of data.</span>
<span class="tok-go">64 bytes from 1.1.1.1: icmp_seq=1 ttl=248 time=4.63 ms</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>With this setup there is full connectivity
Container &harr; Host, Container &harr; Container2 and Container &#8594; Internet.
Note that host and all containers are considered remote relative to each other,
like if they were connected through physical LAN.
If you wish to connect to a service running on one of them,
then the service must listen on 0.0.0.0 or at least on 10.0.3.x,
and also firewall rules must not prohibit packet flow in both directions.
Listening only on 127.0.0.1 won&#8217;t work.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_network_better_dns">Network: better DNS</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Containers are able to address each other by names (<code>ping ff</code>) immediately after basic network is set up.
No additional configuration is required.
When <code>dhclient</code> inside a container requests IP address, it also includes its hostname
as part of the request.
<code>dnsmasq</code>, acting as DHCP and DNS server simultaneously, assigns some IP address to the container
and also adds an entry to its DNS table.
Hence every container is able to resolve IP address of every other container transparently through DNS.</p>
</div>
<div class="paragraph">
<p>Host, on the other hand, is not able to resolve IP addresses of containers by default.
To fix this, we need to use local <code>dnsmasq</code> daemon as primary DNS server on the host.
Add following option to host&#8217;s <code>/etc/dhcp/dhclient.conf</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code>prepend domain-name-servers 10.0.3.1;</code></pre>
</div>
</div>
<div class="paragraph">
<p>After reconfiguring networking you should see that local <code>dnsmasq</code> daemon is
always the primary DNS server.
This modification is robust to advertising of DNS servers by upstream routers,
e.g. when you move your laptop from one wireless network to another one.
10.0.3.1 will always remain the first entry.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="console"><span></span><span class="tok-gp">gudok@gudok6:~$</span> sudo systemctl restart networking
<span class="tok-gp">gudok@gudok6:~$</span> cat /etc/resolv.conf
<span class="tok-go">nameserver 10.0.3.1</span>
<span class="tok-go">nameserver 192.168.88.1</span>
<span class="tok-go">nameserver 1.1.1.1</span>
<span class="tok-go">nameserver 1.0.0.1</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Now when some application on the host calls <code>gethostbyname()</code>,
DNS request is sent first to local <code>dnsmasq</code> daemon.
If request is the name of one of the containers, then <code>dnsmasq</code> will respond with its IP address by itself
by using its local DNS table.
For all other hostnames it acts as DNS proxy and sends requests to upstream DNS server
specified in <code>/etc/resolv.conf</code>.
Don&#8217;t worry: it is clever enough not to send requests recursively to itself.</p>
</div>
<div class="paragraph">
<p>If you want to address containers by their IP addresses and not by hostnames,
then it is desirable to assign static IP addresses to containers.
The clever way to do this is through <code>dhclient</code> configuration when container is created.
Choose unused IP address from 10.0.3.0/24 range and add the following option into <em>container&#8217;s</em>
<code>/etc/dhcp/dhclient.conf</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="console"><span></span><span class="tok-go">send dhcp-requested-address 10.0.3.55;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Now when container asks DHCP server for IP address, it will ask for this particular address 10.0.3.55.
If there are no collisions, then DHCP server will assign exactly this address.
This approach is better than static network configuration because container still sends DHCP request with its hostname,
allowing <code>dnsmasq</code> to add DNS entry {container name} &#8594; {desired IP}.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_network_protecting_lan_from_containers">Network: protecting LAN from containers</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Best practice of container isolation is to allow only those features that are truly required.
Everything is prohibited unless explicitly allowed by configuration.
And by enabling networking inside containers we already allowed too much.
We allowed applications inside containers to connect to services running in the host environment
and on all devices connected to physical LAN: smartphones, routers, and a variety of IoT devices
which you might have in your LAN.
Such setup has identically poor network security as running application directly on the host itself.
If you have any services not protected by passwords, for example, HTTP server with listing of your home
directory enabled or a home security camera, then your private data may be leaking to the outside
via malicious software.
And if you think that malicious software is the only troublemaker, then you are wrong.
It is common for websites to build fingerprints of their users.
Such fingerprints often include list of open services on localhost and on LAN devices.
While you are browsing such web site, JavaScript code in the background tries
to connect to well-known ports on your devices, e.g. 127.0.0.1:80, 192.168.0.1:22 and so on.
The list of open services is sent to remote database to be included as part of your fingerprint.</p>
</div>
<div class="paragraph">
<p>Surely such behaviour must be prohibited.
And containers are good in this regard because we can do this globally for all applications with iptables,
rather than installing browser plugins or configuring AppArmor for every untrusted application.
What we are going to do is to configure iptables to prohibit containers from establishing connections to LAN IP addresses.</p>
</div>
<div class="paragraph">
<p>Unfortunately lxc-net service already installs some rules, and it is impossible to override them cleanly
by using <code>/etc/iptables/rules.v*</code>.
We will have to patch directly <code>/usr/lib/x86_64-linux-gnu/lxc/lxc-net</code>.
There are two places in this file related to iptables setup: when lxc-net is started and when it is shut down.
Locate the first group and replace it with the rules below.
Also replace the rules for shutdown with the rules below, but now use <code>-D</code> option instead of <code>-I</code>.
If done right, then after starting and stopping lxc-net with <code>systemctl stop lxc-net</code>
iptables ruleset will be clean of <code>lxcbr0</code> interface rules.
You can check this with <code>sudo iptables --list -vn</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="bash"><span></span>iptables <span class="tok-nv">$use_iptables_lock</span> -I INPUT -i <span class="tok-si">${</span><span class="tok-nv">LXC_BRIDGE</span><span class="tok-si">}</span> -j DROP
iptables <span class="tok-nv">$use_iptables_lock</span> -I INPUT -i <span class="tok-si">${</span><span class="tok-nv">LXC_BRIDGE</span><span class="tok-si">}</span> -m state --state RELATED,ESTABLISHED -j ACCEPT
iptables <span class="tok-nv">$use_iptables_lock</span> -I INPUT -i <span class="tok-si">${</span><span class="tok-nv">LXC_BRIDGE</span><span class="tok-si">}</span> -p icmp -j ACCEPT
iptables <span class="tok-nv">$use_iptables_lock</span> -I INPUT -i <span class="tok-si">${</span><span class="tok-nv">LXC_BRIDGE</span><span class="tok-si">}</span> -p udp -m udp --dport <span class="tok-m">67</span> -j ACCEPT
iptables <span class="tok-nv">$use_iptables_lock</span> -I INPUT -i <span class="tok-si">${</span><span class="tok-nv">LXC_BRIDGE</span><span class="tok-si">}</span> -p tcp -m tcp --dport <span class="tok-m">67</span> -j ACCEPT
iptables <span class="tok-nv">$use_iptables_lock</span> -I INPUT -i <span class="tok-si">${</span><span class="tok-nv">LXC_BRIDGE</span><span class="tok-si">}</span> -p udp -m udp --dport <span class="tok-m">53</span> -j ACCEPT
iptables <span class="tok-nv">$use_iptables_lock</span> -I INPUT -i <span class="tok-si">${</span><span class="tok-nv">LXC_BRIDGE</span><span class="tok-si">}</span> -p tcp -m tcp --dport <span class="tok-m">53</span> -j ACCEPT
iptables <span class="tok-nv">$use_iptables_lock</span> -I OUTPUT -o <span class="tok-si">${</span><span class="tok-nv">LXC_BRIDGE</span><span class="tok-si">}</span> -j ACCEPT
iptables <span class="tok-nv">$use_iptables_lock</span> -I FORWARD -o <span class="tok-si">${</span><span class="tok-nv">LXC_BRIDGE</span><span class="tok-si">}</span> -j DROP
iptables <span class="tok-nv">$use_iptables_lock</span> -I FORWARD -o <span class="tok-si">${</span><span class="tok-nv">LXC_BRIDGE</span><span class="tok-si">}</span> -m state --state RELATED,ESTABLISHED -j ACCEPT
iptables <span class="tok-nv">$use_iptables_lock</span> -I FORWARD -i <span class="tok-si">${</span><span class="tok-nv">LXC_BRIDGE</span><span class="tok-si">}</span> -j ACCEPT
iptables <span class="tok-nv">$use_iptables_lock</span> -I FORWARD -i <span class="tok-si">${</span><span class="tok-nv">LXC_BRIDGE</span><span class="tok-si">}</span> -d <span class="tok-m">10</span>.0.0.0/8 -j DROP
iptables <span class="tok-nv">$use_iptables_lock</span> -I FORWARD -i <span class="tok-si">${</span><span class="tok-nv">LXC_BRIDGE</span><span class="tok-si">}</span> -d <span class="tok-m">172</span>.16.0.0/12 -j DROP
iptables <span class="tok-nv">$use_iptables_lock</span> -I FORWARD -i <span class="tok-si">${</span><span class="tok-nv">LXC_BRIDGE</span><span class="tok-si">}</span> -d <span class="tok-m">192</span>.168.0.0/16 -j DROP
iptables <span class="tok-nv">$use_iptables_lock</span> -I FORWARD -i <span class="tok-si">${</span><span class="tok-nv">LXC_BRIDGE</span><span class="tok-si">}</span> -m state --state RELATED,ESTABLISHED -j ACCEPT
iptables <span class="tok-nv">$use_iptables_lock</span> -I FORWARD -i <span class="tok-si">${</span><span class="tok-nv">LXC_BRIDGE</span><span class="tok-si">}</span> -p icmp -j ACCEPT
iptables <span class="tok-nv">$use_iptables_lock</span> -t nat -I POSTROUTING -s <span class="tok-si">${</span><span class="tok-nv">LXC_NETWORK</span><span class="tok-si">}</span> ! -d <span class="tok-si">${</span><span class="tok-nv">LXC_NETWORK</span><span class="tok-si">}</span> -j MASQUERADE
iptables <span class="tok-nv">$use_iptables_lock</span> -t mangle -I POSTROUTING -o <span class="tok-si">${</span><span class="tok-nv">LXC_BRIDGE</span><span class="tok-si">}</span> -p udp -m udp --dport <span class="tok-m">68</span> -j CHECKSUM --checksum-fill</code></pre>
</div>
</div>
<div class="paragraph">
<p>The central idea of these rules is that we prohibit containers from initiating connections to LAN addresses.
This means that container will be able to establish connection neither to the host processes, nor to any LAN device.
The exceptions are made for DHCP and DNS services and also for ICMP packets.
On the other hand, host and LAN devices are able to connect to services exposed by containers.</p>
</div>
<div class="paragraph">
<p>Similar ruleset is required for IPv6.
But because IPv6 turned out to be a stillborn technology, I prefer to disable it
permanently on host machine in <code>/etc/sysctl.conf</code> rather than waste my time on it.
Readers who disagree with me are free to write IPv6 ruleset on their own as an exercise.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="ini"><span></span><span class="tok-na">net.ipv6.conf.all.disable_ipv6</span> <span class="tok-o">=</span> <span class="tok-s">1</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Rules above still allow communication between containers.
I didn&#8217;t find elegant way of blocking it.
If you really need to prohibit intercontainer communication, consider investigating one of the following options:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>configure iptables inside containers (not robust)</p>
</li>
<li>
<p>setup single virtual switch per every container (a lot of coding)</p>
</li>
<li>
<p>setup VLANs on a single virtual switch (again a lot of coding)</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_x11_applications_via_ssh">X11 applications via SSH</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The standard way of working with X11 applications on remote host is by using <code>ssh -X/ssh -Y</code>.
Containers are no different in this regard.
It should be noted in advance that X11 applications work slowly through SSH even
when application and X server are located on the same physical box.
Slowness is the result of data being encrypted, passed through network stack, and decrypted.
This significantly increases transmission latency.
The next section will explain how to work with X11 applications directly without any intermediaries,
but currently let&#8217;s focus on doing this with SSH, which is much simpler.</p>
</div>
<div class="paragraph">
<p>First let&#8217;s perform standard SSH setup on the container.
Generate new key (SSH will create <code>$HOME/.ssh</code> directory layout with correct permissions),
and also add your host&#8217;s public key into the list of authorized keys in the container.
Now we can connect from host to the container without entering password.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="console"><span></span><span class="tok-gp">gudok@gudok6:~$</span> sudo lxc-attach -n ff -- ssh-keygen -t rsa
<span class="tok-go">Generating public/private rsa key pair.</span>
<span class="tok-go">Created directory &#39;/root/.ssh&#39;.</span>
<span class="tok-go">Your public key has been saved in /root/.ssh/id_rsa.pub.</span>
<span class="tok-go">The key fingerprint is:</span>
<span class="tok-go">SHA256:L42mhV/WvyYorFW9d4jKSf1ox08OXDcJcmzf3MsBLU4 root@ff</span>

<span class="tok-gp">gudok@gudok6:~$</span> cat ~/.ssh/id_rsa.pub <span class="tok-p">|</span> sudo lxc-attach -n ff -- tee -a /root/.ssh/authorized_keys
<span class="tok-go">ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQC/ES4Ep//7qM23EBGPME9tb1pup+7wz0/GbFiDXYqhVNRqys6xKdDB/tuns3iFsBEH93ppN9/vkFKWrUShXlDF/1pUP6pzqet3U8caBdTEHzNbDijGqxzGWUEOeJ/4o7AN14EWC1QYlR12cjGKZt1B+uYYy4s8F2HEgAOjskL7Pr7TIpp9OTKX7AVihvcQKtNtHGPLWGvqMkfKEdioBF3OUeH8aVAIjJHVtF+M+Ywahf7fAPOdk40CBDtwVROds4HcGgdlxuDnRDpm5JjheSsK9YT4drhsK+/uuciT+2wIeZsqswU4zTWjOBAx91iRtccptz7LLvs6jM+EJ98ue9U3 gudok@gudok6</span>

<span class="tok-gp">gudok@gudok6:~$</span> ssh root@<span class="tok-k">$(</span>sudo lxc-info -Hin ff<span class="tok-k">)</span>
<span class="tok-go">Linux ff 4.19.0-5-amd64 #1 SMP Debian 4.19.37-5 (2019-06-19) x86_64</span>
<span class="tok-go">Last login: Thu Aug 22 13:59:40 2019 from 10.0.3.1</span>

<span class="tok-gp">root@ff:~#</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Next step is to fix SSH behaviour.
There are two standard connection modes in X11: trusted and untrusted.
In trusted mode application has full control over the display.
It may, among other things, take screenshots and subscribe to all key events like a keylogger.
Untrusted mode prohibits all potentially malicious actions.
Historically there was only trusted mode, it could be enabled with <code>ssh -X</code>.
Later, when security implications of trusted mode became apparent, an untrusted mode was added.
SSH introduced <code>ssh -Y</code> option meant to be used when you really want to establish trusted connection,
while <code>ssh -X</code> was downgraded to mean untrusted connection.
But not in Debian.
To avoid compatibility issues, both <code>ssh -X</code> and <code>ssh -Y</code> refer to trusted mode in Debian by default.
Let&#8217;s fix this.
Add the below options into <code>/etc/ssh/ssh_config</code>.
They revert behaviour of SSH to that of SSH upstream configuration and other Linux distributions.
<code>ssh -X</code> and <code>ssh -Y</code> will now establish untrusted and trusted connections respectively.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code>Host *
ForwardX11Trusted no</code></pre>
</div>
</div>
<div class="paragraph">
<p>The final step is to install a couple of packages in a container: <code>xauth</code> and <code>x11-apps</code>.
The first one is mandatory because it is used by SSH to store authorization information.
<code>ssh -X/-Y</code> won&#8217;t work without it.
Second package contains a bunch of small applications handy for testing X11, including xlogo, xeyes and xwd.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="console"><span></span><span class="tok-gp">root@ff:/#</span> apt-get install --no-install-recommends xauth x11-apps
<span class="tok-go">Reading package lists... Done</span>
<span class="tok-go">Setting up x11-apps (7.7+7) ...</span>
<span class="tok-go">Setting up xauth (1:1.0.10-1) ...</span>
<span class="tok-go">Processing triggers for man-db (2.8.5-2) ...</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>If everything was done right, now you will be able to connect from host to a container with SSH
and launch X11 applications successfully.
If this doesn&#8217;t work, rerun ssh with <code>-v</code> option and read the error log.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="console"><span></span><span class="tok-gp">gudok@gudok6:~$</span> ssh -X root@<span class="tok-k">$(</span>sudo lxc-info -Hin ff<span class="tok-k">)</span> xeyes</code></pre>
</div>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="xeyes.png" alt="xeyes" width="79">
</div>
</div>
<div class="paragraph">
<p>Untrusted mode (<code>ssh -X</code>) is enough for majority of applications.
Trusted mode (<code>ssh -Y</code>) may be required if application requires deep integration with graphical subsystem,
such as graphical acceleration.
To check the differences between trusted and untrusted modes, you can try to take a screenshot.
First command works fine, but second one fails with fatal error.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="console"><span></span><span class="tok-gp">gudok@gudok6:~$</span> ssh -Y root@<span class="tok-k">$(</span>sudo lxc-info -Hin ff<span class="tok-k">)</span> <span class="tok-s1">&#39;xwd -root -screen -silent -display $DISPLAY &gt; /tmp/screenshot.xwd&#39;</span>

<span class="tok-gp">gudok@gudok6:~$</span> ssh -X root@<span class="tok-k">$(</span>sudo lxc-info -Hin ff<span class="tok-k">)</span> <span class="tok-s1">&#39;xwd -root -screen -silent -display $DISPLAY &gt; /tmp/screenshot.xwd&#39;</span>
<span class="tok-go">bash: line 1:  1207 Segmentation fault      xwd -root -screen -silent -display $DISPLAY &gt; /tmp/screenshot.xwd</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_x11_applications_via_unix_socket">X11 applications via unix socket</h2>
<div class="sectionbody">
<div class="paragraph">
<p>X forwarding with SSH is slow.
You can see it, for example, when scrolling a web page in a browser.
We need another way.
Actually, we can make in-container applications work as fast as on host system,
since both container and X server are located on the same physical box.
The fact that containers are confined to isolated environments is not an obstacle.
But in order to make use of new approach, we need to understand the basics of X.
We are interested in two topics: transport protocols and authorization.</p>
</div>
<div class="paragraph">
<p>Applications communicate with X server by means of some stream-oriented transport.
X server supports the following transports: pathname unix sockets, abstract namespace unix sockets, TCP.
What transports X server actually listens to depends on the options it was started with.
And because starting X server is the responsibility of desktop manager,
list of effective transports may vary depending on the used desktop manager.
For example, SDDM by default starts X server with only abstract namespace unix socket enabled.
Any local application can use it to connect to X server.
But it won&#8217;t work for in-container applications because there is no way of sharing
(at least in an easy way) abstract namespace unix sockets into containers.</p>
</div>
<div class="paragraph">
<p>What we are going to do is to enable pathname unix socket transport in X server
and then mount it into containers.
Pathname unix sockets can be mounted into containers like directories and regular files.
To enable this transport, we need to modify desktop manager settings.
The process depends on desktop manager.
In SDDM it is done by creating <code>/etc/sddm.conf</code> file with the following contents:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="ini"><span></span><span class="tok-k">[X11]</span>
<span class="tok-na">ServerArguments</span><span class="tok-o">=</span><span class="tok-s">-listen unix -listen local -nolisten tcp</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>This set of arguments instructs X server to create and listen on pathname unix socket
(<code>/tmp/.X11-unix/X0</code>) and abstract name space unix socket (<code>@/tmp/.X11-unix/X0</code>), but not to listen on TCP.
After restarting X server we can check that X is really started with these options
and that it really listens on both types of unix sockets.
Abstract namespace unix socket is denoted in netstat output with <code>@</code> in the beginning of its "path".
Actually, it is not a path, but just a unique socket name.
It is not present in filesystem in contrast to another, pathname unix socket.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="console"><span></span><span class="tok-gp">gudok@gudok6:~$</span> sudo systemctl status sddm
<span class="tok-go">● sddm.service - Simple Desktop Display Manager</span>
<span class="tok-go">   Active: active (running) since Wed 2019-08-21 17:48:42 MSK; 1 day 1h ago</span>
<span class="tok-go">   CGroup: /system.slice/sddm.service</span>
<span class="tok-go">           ├─ 927 /usr/bin/sddm</span>
<span class="tok-go">           └─6213 /usr/lib/xorg/Xorg -listen unix -listen local -nolisten tcp -auth /var/run/sddm/{3390f040-4b79-471c-8d44-1ad0871bf16a</span>

<span class="tok-gp">gudok@gudok6:~$</span> netstat -l <span class="tok-p">|</span> grep X11-unix
<span class="tok-go">unix  2      [ ACC ]     STREAM     LISTENING     147529   /tmp/.X11-unix/X0</span>
<span class="tok-go">unix  2      [ ACC ]     STREAM     LISTENING     147528   @/tmp/.X11-unix/X0</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Now let&#8217;s mount <code>/tmp/.X11-unix/X0</code> into the container and set other important options in advance.
Add the following options into <code>/etc/lxc/default.conf</code> or into per-container configuration file
and restart affected containers.
After attaching to container you should see the file <code>/tmp/.X11-unix/X0</code> present with the identical
attributes as on the host.
X11 applications will be able to use it to connect to X server.
In addition to mounting, we also set custom path for <code>.Xauthority</code> file that will be used
to store authorization cookies, and <code>DISPLAY</code> variable.
The latter instructs applications which transport to use.
Values :0 through :9 correspond to unix sockets.
If, for example, <code>DISPLAY=:5</code>, then application will try to connect to
<code>/tmp/.X11-unix/X5</code> and <code>@/tmp/.X11-unix/X5</code>, and fail if neither of them works.
Values :10 through :19 correspond to TCP ports 6010 through 6019.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="ini"><span></span><span class="tok-na">lxc.mount.entry</span> <span class="tok-o">=</span> <span class="tok-s">/tmp/.X11-unix tmp/.X11-unix none ro,bind,create=dir 0 0</span>
<span class="tok-na">lxc.environment</span> <span class="tok-o">=</span> <span class="tok-s">DISPLAY=:0</span>
<span class="tok-na">lxc.environment</span> <span class="tok-o">=</span> <span class="tok-s">XAUTHORITY=/root/.Xauthority</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Second challenge is authorization.
Host applications use so called "server interpreted" authorization.
It allows all applications on the host running with UID of your user to connect to X server in trusted mode.
We instead will use more restrictive cookie based authorization inside our containers.
It works in the following way: we use <code>xauth generate &lt;options&gt;</code> utility on host system.
It connects to X server and asks it to generate new authorization cookie with given options.
Server generates new cookie, stores it internally until restart, and returns it also to xauth client,
which stores it in <code>.Xauthority</code> file.
Next we use again xauth program, now inside a container, to store newly generated cookie in container&#8217;s <code>.Xauthority</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="console"><span></span><span class="tok-gp">gudok@gudok6:~$</span> xauth -f /tmp/ff.xauth generate :0 . untrusted timeout <span class="tok-m">2147483</span>
<span class="tok-go">xauth:  file /tmp/ff.xauth does not exist</span>

<span class="tok-gp">gudok@gudok6:~$</span> xauth -f /tmp/ff.xauth list
<span class="tok-go">gudok6/unix:0  MIT-MAGIC-COOKIE-1  8897d56747607202463ef46e20d7f389</span>

<span class="tok-gp">gudok@gudok6:~$</span> sudo lxc-attach -n ff

<span class="tok-gp">root@ff:/#</span> xauth add <span class="tok-nv">$DISPLAY</span> MIT-MAGIC-COOKIE-1 8897d56747607202463ef46e20d7f389

<span class="tok-gp">root@ff:/#</span> xauth list
<span class="tok-go">ff/unix:0  MIT-MAGIC-COOKIE-1  8897d56747607202463ef46e20d7f389</span>

<span class="tok-gp">root@ff:/#</span> xeyes</code></pre>
</div>
</div>
<div class="paragraph">
<p>Important points are that we use untrusted mode, that we specify large timeout and
that we use custom <code>.Xauthority</code> file on the host.
Timeout sets when cookie is expired in X server.
After expiration, X server will remove it from the list of allowed cookies and
applications won&#8217;t be able to connect anymore with this cookie.
Default timeout is only a couple of seconds, which is not enough even to start single application manually.
We set it instead to the highest possible value.
At the moment of writing values larger than 2147483 cause X server to crash due to a bug.
Custom <code>.Xauthority</code> file is important because otherwise xauth will rewrite respective cookies in the default one.
We don&#8217;t want this because settings for already exiting cookies and newly generated ones are different.</p>
</div>
<div class="paragraph">
<p>The above sequence of actions must be performed after every X server restart.
To avoid the hassle, create a script to connect to a container.
You can use the below basic script to start with.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="bash"><span></span><span class="tok-ch">#!/usr/bin/env bash</span>
<span class="tok-nb">set</span> -e
<span class="tok-nb">set</span> -o pipefail
<span class="tok-nb">set</span> -u

<span class="tok-nb">readonly</span> <span class="tok-nv">container</span><span class="tok-o">=</span><span class="tok-s1">&#39;ff&#39;</span>
<span class="tok-k">if</span> <span class="tok-o">[</span> <span class="tok-k">$(</span>sudo lxc-info -sH -n <span class="tok-si">${</span><span class="tok-nv">container</span><span class="tok-si">}</span><span class="tok-k">)</span> !<span class="tok-o">=</span> <span class="tok-s1">&#39;RUNNING&#39;</span> <span class="tok-o">]</span><span class="tok-p">;</span> <span class="tok-k">then</span>
  sudo lxc-start -n <span class="tok-si">${</span><span class="tok-nv">container</span><span class="tok-si">}</span>

  <span class="tok-nv">path</span><span class="tok-o">=</span><span class="tok-k">$(</span>mktemp /tmp/xauth.XXXXXXXXXX<span class="tok-k">)</span>
  xauth -f <span class="tok-si">${</span><span class="tok-nv">path</span><span class="tok-si">}</span> generate <span class="tok-si">${</span><span class="tok-nv">DISPLAY</span><span class="tok-si">}</span> . untrusted timeout <span class="tok-m">2147483</span>
  <span class="tok-nv">cookie</span><span class="tok-o">=</span><span class="tok-k">$(</span>xauth -f <span class="tok-si">${</span><span class="tok-nv">path</span><span class="tok-si">}</span> list <span class="tok-p">|</span> grep <span class="tok-si">${</span><span class="tok-nv">DISPLAY</span><span class="tok-si">}</span> <span class="tok-p">|</span> awk <span class="tok-s1">&#39;{print $3}&#39;</span><span class="tok-k">)</span>
  rm -f <span class="tok-si">${</span><span class="tok-nv">path</span><span class="tok-si">}</span>
  sudo lxc-attach -n <span class="tok-si">${</span><span class="tok-nv">container</span><span class="tok-si">}</span> --clear-env xauth add <span class="tok-s1">&#39;:0&#39;</span> . <span class="tok-si">${</span><span class="tok-nv">cookie</span><span class="tok-si">}</span>
<span class="tok-k">fi</span>
<span class="tok-nb">exec</span> sudo lxc-attach -n <span class="tok-si">${</span><span class="tok-nv">container</span><span class="tok-si">}</span> --clear-env -- <span class="tok-nv">$@</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>To complete the picture, here is the explanation why this setup works and how SSH setup differs from it.
When some X11 application is started inside a container, it notices that <code>DISPLAY</code> variable is set to <code>:0</code>.
This instructs it to use <code>/tmp/.X11-unix/X0</code> and <code>@/tmp/.X11-unix/X0</code> unix sockets as transport to X server.
It tries them both and detects that the first one is working.
Next the application reads <code>XAUTHORITY</code> variable that gives the location of the file with cookies as <code>/root/.Xauthority</code>.
It searches it for the cookie corresponding to display <code>:0</code> and uses this cookie to authorize itself within X server.
X server grants permission because it previously issued this cookie and it has not expired yet.</p>
</div>
<div class="paragraph">
<p>SSH forwarding has the same authorization process, but it uses TCP as the transport.
When connection with <code>ssh -X/-Y</code> is established, SSH opens TCP socket 6010 inside the container,
pretending to be X server itself, and also setups <code>DISPLAY</code> and <code>XAUTHORITY</code> variables.
Applications see that <code>DISPLAY</code> is <code>:10</code>.
This instructs them to use TCP localhost:6010 as transport.
SSH forwards all data on :6010 to the client SSH process on the host machine,
which in turn forwards it to host&#8217;s <code>/tmp/.X11-unix/X0</code> or <code>@/tmp/.X11-unix/X0</code>.</p>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="xforwarding.svg" alt="xforwarding" width="70%">
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_pulseaudio">PulseAudio</h2>
<div class="sectionbody">
<div class="paragraph">
<p>PulseAudio works similar to X server, except that it doesn&#8217;t use authorization by default.
It works through unix socket, which we can mount inside containers.
Applications which use PulseAudio are aware of <code>PULSE_SERVER</code> environment variable.
It consists of protocol name (<code>unix:</code>) followed by path to unix socket
to be used to communicate with the server.
Adding the below options to container configuration file is all that is needed for PulseAudio to work.
Obviously, 1000 must be replaced with the UID of your user.
You can retrieve UID of your user with <code>id</code> command.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="ini"><span></span><span class="tok-na">lxc.mount.entry</span> <span class="tok-o">=</span> <span class="tok-s">/run/user/1000/pulse/native tmp/pulse/native none rw,bind,create=file 0 0</span>
<span class="tok-na">lxc.environment</span> <span class="tok-o">=</span> <span class="tok-s">PULSE_SERVER=unix:/tmp/pulse/native</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>After that restart containers, install pulse utilities and test audio.
Don&#8217;t forget to enable microphone if it is disabled:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="console"><span></span><span class="tok-gp">root@ff:/#</span> apt-get install --no-install-recommends pulseaudio-utils
<span class="tok-go">Setting up pulseaudio-utils (12.2-4) ...</span>

<span class="tok-gp">root@ff:/tmp#</span> parecord &gt; voice.wav
<span class="tok-go">^C</span>
<span class="tok-gp">root@ff:/tmp#</span> paplay &lt; voice.wav</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you don&#8217;t want to share PulseAudio socket of your user, you can create additional
socket specifically to be used inside containers.
On host system execute the following command and then adjust the configuration of containers accordingly:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="console"><span></span><span class="tok-gp">gudok@gudok6:~$</span> pactl load-module module-native-protocol-unix <span class="tok-nv">socket</span><span class="tok-o">=</span>/tmp/pulse.socket</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_webcam">Webcam</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Video cameras have standard "video4linux" interface in Linux and are available as <code>/dev/video*</code> devices.
Thus, they can be mounted into containers.
In addition to mounting we also need to set permissions
to allow in-container processes to access file devices.
To do so, we need to find out device ID.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="console"><span></span><span class="tok-gp">gudok@gudok6:~$</span> ls -l /dev/video*
<span class="tok-go">crw-rw----+ 1 root video 81, 0 Aug 21 17:48 /dev/video0</span>
<span class="tok-go">crw-rw----+ 1 root video 81, 1 Aug 21 17:48 /dev/video1</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Here I have two video cameras.
They are character devices ("c") with major device number 81 and minor device numbers 0 and 1 respectively.
Major device ID corresponds to some class of the device.
These numbers are fixed, with character device 81 being reserved for video4linux device type.
Device number association can also be retrieved from
<a href="https://www.kernel.org/doc/html/latest/admin-guide/devices.html">documentation</a>.
Now let&#8217;s mount the device and allow containers to read/write all character devices with major device number 81:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="ini"><span></span><span class="tok-na">lxc.cgroup.devices.allow</span> <span class="tok-o">=</span> <span class="tok-s">c 81:* rw</span>
<span class="tok-na">lxc.mount.entry</span> <span class="tok-o">=</span> <span class="tok-s">/dev/video0 dev/video0 none bind,optional,create=file</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>To check whether webcam works, you can use VLC or any other media player with video capture capability.
Or if you don&#8217;t want to install heavy packages, then there is simple <code>fswebcam</code> utility.
It captures single frame from the camera and writes it as still image.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="console"><span></span><span class="tok-gp">root@ff:/#</span> apt-get install --no-install-recommends fswebcam
<span class="tok-go">Setting up fswebcam (20140113-2) ...</span>

<span class="tok-gp">root@ff:/#</span> fswebcam -S <span class="tok-m">5</span> /tmp/test.png
<span class="tok-go">/dev/video0 opened.</span>
<span class="tok-go">Skipping 5 frames...</span>
<span class="tok-go">Capturing 1 frames...</span>
<span class="tok-go">Writing JPEG image to &#39;/tmp/test.png&#39;.</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Described method is applicable not only for webcams.
Any device that is communicated with by means of some <code>/dev/*</code> file can be allowed access from containers by mounting it.
Find out the device file, call <code>ls -l</code> on it to display its major/minor device numbers and type (block or character),
and add the appropriate options to container configuration file.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_application_troubleshooting">Application troubleshooting</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Some applications may work differently or refuse to function altogether if run under root.
For instance, this is the case with VLC.
There is not much sense in adding new user from security point of view.
Instead VLC may be patched with the following common hack:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="console"><span></span><span class="tok-gp">root@ff:/#</span> sed -i <span class="tok-s1">&#39;s/geteuid/getppid/&#39;</span> /usr/bin/vlc</code></pre>
</div>
</div>
<div class="paragraph">
<p>Default container images are minimalistic.
Third-party applications may require manual installation of additional packages.
For example, Skype installs but fails to start without printing any diagnostic information to console.
However, reading its log file reveals that <code>libgconf-2-4</code> must be installed.
In general case if third-part application doesn&#8217;t work and doesn&#8217;t produce meaningful error messages,
the first step to debug it is to use <code>strace</code>.</p>
</div>
<div class="paragraph">
<p>Some applications may depend on environment variables.
For example, Firefox hangs permanently during startup if environment variables are not cleared.
ncurses applications such as <code>top</code> require <code>TERM</code> to be correctly set.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_caching_packages">Caching packages</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Typically the same set of basic packages is installed in every container.
If you do not have APT repository in your LAN, then this may be time-consuming.
To solve this problem, you can setup <code>apt-cacher-ng</code> that acts as a caching proxy
to Debian/Ubuntu repositories and then instruct containers to use it instead of connecting
to APT repository directly.</p>
</div>
<div class="paragraph">
<p>Create additional container that will be used exclusively as a cache, I call it <code>acng</code> below.
Install <code>apt-cacher-ng</code> inside it.
As soon as you install it, it starts listening on standard proxy port 3142.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="console"><span></span><span class="tok-gp">root@acng:/#</span> apt-get install apt-cacher-ng
<span class="tok-go">Setting up libwrap0:amd64 (7.6.q-28) ...</span>
<span class="tok-go">Setting up apt-cacher-ng (3.2-2) ...</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Now let&#8217;s instruct containers to use this proxy when accessing APT repositories.
First, we must be sure that all repository URLs use raw http scheme and not https.
It doesn&#8217;t matter what particular mirrors are used, only the scheme.
Default <code>sources.list</code> configuration is fine.
If you added other repository URLs manually, then check that they use HTTP scheme.
Next, add <code>proxy</code> file that instructs APT to access repository via proxy.
These steps can be performed on all containers, including proxy container itself and even host machine.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="console"><span></span><span class="tok-gp">root@ff:/#</span> cat /etc/apt/sources.list
<span class="tok-go">deb http://deb.debian.org/debian buster main</span>
<span class="tok-go">deb http://security.debian.org/debian-security buster/updates main</span>

<span class="tok-gp">root@ff:/#</span> cat /etc/apt/apt.conf.d/proxy
<span class="tok-go">Acquire::http { Proxy &quot;http://acng:3142&quot;; }</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Now when installing new packages, <code>apt-get</code> will send requests via proxy.
Proxy will detect that requested URL belongs to one of Debian repositories
and return cached package if found.
If package is not yet cached, it will download package.
It will always use the same <code>deb.debian.org</code> no matter what mirror is specified in the URL.</p>
</div>
<div class="paragraph">
<p>In addition, <code>apt-cacher-ng</code> instance exposures report on cache efficiency.
Provided you configured DNS as was described in the corresponding section, you can access
it directly from the host at <a href="http://acng:3142/acng-report.html">http://acng:3142/acng-report.html</a>.</p>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="acng.png" alt="acng" width="60%">
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_unprivileged_containers">Unprivileged containers</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Described above recipes are applicable for so-called privileged containers.
Privileged containers are started under root user, which is able to configure all confinement features.
In contrast, unprivileged containers allow to create and run containers under ordinary users.
Unfortunately, setup becomes more complicated, and there are also additional
restrictions imposed on unprivileged containers.
And because security of unprivileged containers is not significantly better
than that of privileged ones, I do not recommend to get involved with them.
However, if you really want to, then first test setup with privileged containers
before repeating it with unprivileged ones.
Unprivileged containers are much harder to debug.
Errors may vary from flapping error messages to segmentation faults.</p>
</div>
<div class="paragraph">
<p>All commands now must be executed with ordinary user.
Other differences:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top"></th>
<th class="tableblock halign-left valign-top">priveleged</th>
<th class="tableblock halign-left valign-top">unpriveleged</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">User</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">root</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Any ordinary user</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Default configuration file</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>/etc/lxc/default.conf</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>$HOME/.config/lxc/default.conf</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Container location</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>/var/lib/lxc/</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>$HOME/.local/share/lxc/</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Container template</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>lxc-download</code> or <code>lxc-debian</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>lxc-download</code> only</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Below is the list of what needs to be done to make unprivileged containers work:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Set option <code>kernel.unprivileged_userns_clone = 1</code> in <code>/etc/sysctl.conf</code></p>
</li>
<li>
<p>Install following packages: uidmap, libpam-cgfs</p>
</li>
<li>
<p>Ensure that <code>/etc/subuid</code> and <code>/etc/subgid</code> have your user included.
Both files should contain entry similar to this one: <code>gudok:689824:65536</code>.
This says that unpriveleged containers of the specified user will use UIDs/GIDs
in the range [689824, 689824+65536).
If entries for your user are missing, add them either with
<code>usermod --add-subuids/--add-subgids</code> commands or manually.</p>
</li>
<li>
<p>Copy <code>/etc/lxc/default.conf</code> to <code>$HOME/.config/lxc/default.conf</code>.
Create directory hierarchy if it doesn&#8217;t exist.</p>
</li>
<li>
<p>Add UID and GID mappings of your user to the default configuration file:</p>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="ini"><span></span><span class="tok-na">lxc.idmap</span> <span class="tok-o">=</span> <span class="tok-s">u 0 689824 65536</span>
<span class="tok-na">lxc.idmap</span> <span class="tok-o">=</span> <span class="tok-s">g 0 689824 65536</span></code></pre>
</div>
</div>
</li>
<li>
<p>In the default configuration file, change <code>lxc.apparmor.profile = generated</code>
to <code>lxc.apparmor.profile = unconfined</code>.</p>
</li>
<li>
<p>Create <code>/etc/lxc/lxc-usernet</code> and add entry for your user: <code>gudok veth lxcbr0 100</code>.
This will allow you to have up to 100 containers connected to virtual switch.</p>
</li>
<li>
<p>Reboot the workstation (you may get cryptic segmentation faults if don&#8217;t do that)</p>
</li>
<li>
<p>Run <code>lxc-checkconfig</code> and check that everything is enabled and there are no error and warning messages.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Now it is possible to create unprivileged containers.
The procedure is exactly the same as with privileged containers, just run all the commands with ordinary user, not root.
Remember that <code>lxc-debian</code> template won&#8217;t work, only <code>lxc-download</code>.
If something goes wrong, try to execute lxc-* command with <code>--logfile /tmp/lxc.log --logpriority DEBUG</code> options.
Log file contains much more verbose messages than those ones printed to stdout.</p>
</div>
<div class="paragraph">
<p>All other features described in the article work fine with unprivileged containers except accessing device files.
Unprivileged containers do not support <code>lxc.cgroup.devices.allow</code> option.
Remove it from (default) configuration file, or containers will fail to start.
Device files can still be mounted, but you have to manually set permissions on them.
The easiest way is to allow everybody to read/write the device file:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="console"><span></span><span class="tok-gp">gudok@gudok6:~$</span> sudo chown a+rw /dev/video0</code></pre>
</div>
</div>
<div class="paragraph">
<p>There is also another, cleaner way.
Create one more device file with <code>mknod</code> with the same attributes (device type, major id, minor id)
as the original device file.
Hence both files will refer to the same actual device object inside Linux.
Now set the owner of the new file to be the UID:GID of the root user of the container.
The latter numbers are not the same as your user ID.
Instead they are the first values from UID/GID mappings.
First user created inside a container is root, hence the very first numbers from UID/GID mappings
are used to map it outside the container.
Alternatively, check the ownership of the root filesystem of the container.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="console"><span></span><span class="tok-gp">gudok@gudok6:~$</span> ls -l /dev/video0*
<span class="tok-go">crw-rw-rw-+ 1 root video 81, 0 Aug 27 09:34 /dev/video0</span>

<span class="tok-gp">gudok@gudok6:~$</span> sudo mknod /dev/video0.gudok c <span class="tok-m">81</span> <span class="tok-m">0</span>

<span class="tok-gp">gudok@gudok6:~$</span> ls -ld <span class="tok-nv">$HOME</span>/.local/share/lxc/ff/rootfs
<span class="tok-go">drwxr-xr-x 21 689824 689824 4096 Aug 26 08:26 /home/gudok/.local/share/lxc/ff/rootfs</span>

<span class="tok-gp">gudok@gudok6:~$</span> sudo chown <span class="tok-m">689824</span>:689824 /dev/video0.gudok

<span class="tok-gp">gudok@gudok6:~$</span> ls -l /dev/video0*
<span class="tok-go">crw-rw-rw-+ 1 root   video  81, 0 Aug 27 09:34 /dev/video0</span>
<span class="tok-go">crw-r--r--  1 689824 689824 81, 0 Aug 27 11:30 /dev/video0.gudok</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Now we have additional device file which refers to our camera and is owned by the container&#8217;s root user.
We can mount it.
Processes in containers running under container&#8217;s root now should be able to access the device file.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="ini"><span></span><span class="tok-na">lxc.mount.entry</span> <span class="tok-o">=</span> <span class="tok-s">/dev/video0.gudok dev/video0 none bind,optional,create=file</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Another nuisance with unrprivileged containers is that you cannot copy files directly from host file system into
LXC container (e.g.  <code>cp ~/.vimrc ~/.local/share/lxc/ff/rootfs/root/</code> will fail) because the owner of this directory
is different from your ordinary user ID.
To circumvent this problem use the following command that remaps user and group IDs:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="console"><span></span><span class="tok-gp">gudok@gudok6:~$</span> lxc-usernsexec -m b:0:689824:65536 -- &lt;some command&gt;
<span class="tok-gp">gudok@gudok6:~$</span> lxc-usernsexec -m b:0:689824:65536 -- cp <span class="tok-nv">$HOME</span>/.vimrc ~/.local/share/lxc/ff/rootfs/root/</code></pre>
</div>
</div>
<div class="paragraph">
<p>What happens here is that every user in range [689824, 689824+65536) on the host file system is remapped to [0, 65536)
respectively into the container.</p>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2020-03-15 16:39:41 UTC
</div>
</div>
</body>
</html>