<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]-->
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 1.5.8">
<title>Dangers of linking inline functions</title>
<style>
/*! normalize.css v2.1.2 | MIT License | git.io/normalize */article,aside,details,figcaption,figure,footer,header,hgroup,main,nav,section,summary{display:block}audio,canvas,video{display:inline-block}audio:not([controls]){display:none;height:0}[hidden],template{display:none}script{display:none !important}html{font-family:sans-serif;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}a{background:transparent}a:focus{outline:thin dotted}a:active,a:hover{outline:0}h1{font-size:2em;margin:.67em 0}abbr[title]{border-bottom:1px dotted}b,strong{font-weight:bold}dfn{font-style:italic}hr{-moz-box-sizing:content-box;box-sizing:content-box;height:0}mark{background:#ff0;color:#000}code,kbd,pre,samp{font-family:monospace,serif;font-size:1em}pre{white-space:pre-wrap}q{quotes:"\201C" "\201D" "\2018" "\2019"}small{font-size:80%}sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}sup{top:-0.5em}sub{bottom:-0.25em}img{border:0}svg:not(:root){overflow:hidden}figure{margin:0}fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}legend{border:0;padding:0}button,input,select,textarea{font-family:inherit;font-size:100%;margin:0}button,input{line-height:normal}button,select{text-transform:none}button,html input[type="button"],input[type="reset"],input[type="submit"]{-webkit-appearance:button;cursor:pointer}button[disabled],html input[disabled]{cursor:default}input[type="checkbox"],input[type="radio"]{box-sizing:border-box;padding:0}input[type="search"]{-webkit-appearance:textfield;-moz-box-sizing:content-box;-webkit-box-sizing:content-box;box-sizing:content-box}input[type="search"]::-webkit-search-cancel-button,input[type="search"]::-webkit-search-decoration{-webkit-appearance:none}button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}textarea{overflow:auto;vertical-align:top}table{border-collapse:collapse;border-spacing:0}*,*::before,*::after{box-sizing:border-box;margin:0}body{font-family:Helvetica,Arial,sans-serif;font-size:16px;color:#222;line-height:1.5;max-width:55em;margin:0 auto}#content,#footnotes{padding-left:.5em;padding-right:.5em}strong{font-weight:bold}em{font-style:italic}:not(pre)>code{font-family:Courier,monospace;line-height:1.0}a{color:#0061c5;text-decoration:none}a:hover{text-decoration:underline}hr{border-width:0 0 1px 0;border-style:solid;border-color:#678}ul,ol{list-style-position:outside;padding-left:0;margin-left:2em}ul li ul,ul li ol,ol li ul,ol li ol{margin-left:1.414em}ul>li{list-style-type:square;font-size:80%}ul>li>*{font-size:125%}ol>li{font-weight:bold}ol>li>*{font-weight:normal}ol.arabic{list-style-type:decimal}ol.decimal{list-style-type:decimal-leading-zero}ol.loweralpha{list-style-type:lower-alpha}ol.upperalpha{list-style-type:upper-alpha}ol.lowerroman{list-style-type:lower-roman}ol.upperroman{list-style-type:upper-roman}ol.lowergreek{list-style-type:lower-greek}.dlist dt{color:#325d72;font-weight:bold}.dlist dt:not(:first-child){margin-top:1em}.dlist dd{margin-left:2em}td.hdlist1{color:#325d72;padding-right:.5em;vertical-align:top}td.hdlist2{padding-bottom:.5em}h1{font-size:28px;font-weight:normal;letter-spacing:-1px;color:white;background-color:#325d72;text-align:center;margin:0 0 .5em 0;padding:.05em .5em}@media print{h1{color:#325d72;background-color:white;font-weight:bold}}h1::after{content:':';width:0;overflow:hidden;display:inline-block;vertical-align:middle}.author{color:#325d72}.email::before{content:"<";color:#325d72}.email::after{content:">";color:#325d72}.author+br,.email+br{display:none}#author{padding-left:.5em}#toc{margin:1em 0 2em 0;padding-left:.5em}#toctitle{font-size:19px;font-weight:bold;color:#325d72;margin:.5em 0}#toc>ul{line-height:1.4;font-size:15px;margin:0 0 0 .5em}#toc ul li{list-style-type:none}#toc li{margin:0}.big{font-size:120%}.small{font-size:75%}.underline{text-decoration:underline}.overline{text-decoration:overline}.line-through{text-decoration:line-through}.aqua{color:#00bfbf}.aqua-background{background-color:#00fafa;border-radius:2px;padding:0 3px}.black{color:"black"}.black-background{background-color:"black";border-radius:2px;padding:0 3px}.blue{color:#0000bf}.blue-background{background-color:#0000fa;border-radius:2px;padding:0 3px}.fuchsia{color:#bf00bf}.fuchsia-background{background-color:#fa00fa;border-radius:2px;padding:0 3px}.gray{color:#606060}.gray-background{background-color:#7d7d7d;border-radius:2px;padding:0 3px}.green{color:#006000}.green-background{background-color:#007d00;border-radius:2px;padding:0 3px}.lime{color:#00bf00}.lime-background{background-color:#00fa00;border-radius:2px;padding:0 3px}.maroon{color:#600000}.maroon-background{background-color:#7d0000;border-radius:2px;padding:0 3px}.navy{color:#000060}.navy-background{background-color:#00007d;border-radius:2px;padding:0 3px}.olive{color:#606000}.olive-background{background-color:#7d7d00;border-radius:2px;padding:0 3px}.purple{color:#600060}.purple-background{background-color:#7d007d;border-radius:2px;padding:0 3px}.red{color:#bf0000}.red-background{background-color:#fa0000;border-radius:2px;padding:0 3px}.silver{color:#909090}.silver-background{background-color:#bcbcbc;border-radius:2px;padding:0 3px}.teal{color:#006060}.teal-background{background-color:#007d7d;border-radius:2px;padding:0 3px}.white{color:#bfbfbf}.white-background{background-color:#fafafa;border-radius:2px;padding:0 3px}.yellow{color:#bfbf00}.yellow-background{background-color:#fafa00;border-radius:2px;padding:0 3px}table.tableblock{border:1px solid #91a7b3;margin-left:auto;margin-right:auto}table.tableblock>caption.title{text-align:left;margin-bottom:.5em}table.tableblock>colgroup>col{width:inherit !important}table.tableblock>tbody>tr>td{border-style:solid;border-color:#91a7b3;border-width:0 1px;padding:0 5px 2px 5px}table.tableblock>tbody>tr:nth-of-type(2n){background-color:#f3f5f7}p.tableblock{text-align:inherit}table.tableblock>thead>tr>td,table.tableblock>thead>tr>th,table.tableblock>tfoot>tr>td,table.tableblock>tfoot>tr>th{color:#325d72;font-weight:bold;line-height:1.35;padding:2px 5px;border:1px solid #91a7b3}table.tableblock>thead>tr>th,table.tableblock>thead>tr>td{border-bottom-width:2px}table.tableblock>tfoot>tr>th,table.tableblock>tfoot>tr>td{border-top-width:2px}th.halign-left,td.halign-left{text-align:left}th.halign-right,td.halign-right{text-align:right}th.halign-center,td.halign-center{text-align:center}th.valign-top,td.valign-top{vertical-align:top}th.valign-bottom,td.valign-bottom{vertical-align:bottom}th.valign-middle,td.valign-middle{vertical-align:middle}div.listingblock{padding:.5em;border-style:solid;border-color:#678;border-width:0 0 0 2px;background-color:#f3f5f7;overflow:auto}div.listingblock .title{text-align:right}div.listingblock pre{font-family:Menlo,Consolas,Monaco,"Lucida Console",monospace;font-size:87.5%;white-space:pre;background-color:#f3f5f7 !important;margin:0}div.listingblock td.linenos{border-right:1px solid #91a7b3;padding-right:.67em}div.listingblock table.pyhltable div.linenodiv{color:#678;text-align:right}div.listingblock table.pyhltable td.code{padding-left:.67em}div.imageblock>div.content>img{max-width:98%}.text-indent{padding-left:2em}img.inlinemath{image-rendering:optimizequality;margin-top:.5ex}h2,h3,h4{font-weight:normal;color:#325d72;margin:0}h2{font-size:27px;letter-spacing:-1px;border-bottom:1px solid #91a7b3}h3{font-size:24px;letter-spacing:-0.75px}h4{font-size:21px;letter-spacing:-0.5px}.title{color:#325d72;font-weight:bold}#footer{font-size:80%;color:white;background-color:#325d72}@media print{#footer{color:#325d72;background-color:white;font-weight:bold}}#footer-text{text-align:center;padding:.5em}#footer-badges{display:none}span.footnote{vertical-align:super;font-size:80%}#footnotes>hr{display:none}#footnotes::before{display:block;border-bottom:1px solid #678;margin:.5em 0;content:"Notes";font-size:19px;font-weight:bold;color:#325d72}#footnotes .footnote{margin-left:.5em;font-size:15px}hr:not(:first-child){margin-top:1.5em}hr:not(:last-child){margin-bottom:1.5em}.imageblock:not(:last-child),.listingblock:not(:last-child),.tableblock:not(:last-child){margin-bottom:1em}p+*{margin-top:1em}.paragraph+*{margin-top:1em}p+.ulist,p+.olist,p+.dlist,p+.hdlist,.paragraph+.ulist,.paragraph+.olist,.paragraph+.dlist,.paragraph+.hdlist,.paragraph+.listingblock{margin-top:.5em !important}li *+.ulist,li *+.olist,li *+.dlist,li *+.hdlist{margin-top:.1em !important}.title:not(:first-child){margin-top:1.5em}.content+.title{margin-top:.5em !important}.title+*{margin-top:1.5em}.title+p,.title+.paragraph,.title+.ulist,.title+.olist,.title+.dlist,.title+.hdlist{margin-top:.5em !important}.ulist:not(:last-child){margin-bottom:1em}.olist:not(:last-child){margin-bottom:1em}li:not(:first-child){margin-top:.1em}.dlist:not(:last-child){margin-bottom:1em}.dlist:not(:first-child){margin-top:1em}.sect3:not(:last-child){margin-bottom:18px}.sect3:not(:first-child){margin-top:18px}h4:not(:last-child){margin-bottom:9px}.sect2:not(:last-child){margin-bottom:22px}.sect2:not(:first-child){margin-top:22px}h3:not(:last-child){margin-bottom:11px}.sect1:not(:last-child){margin-bottom:40px}.sect1:not(:first-child){margin-top:40px}#preamble:not(:last-child){margin-bottom:40px}h2:not(:last-child){margin-bottom:13px}#header:not(:last-child),#content:not(:last-child),#footnotes:not(:last-child){margin-bottom:2em}.text-left{text-align:left}.text-center{text-align:center}.text-right{text-align:right}
</style>
<style>
.listingblock .pygments .hll { background-color: #ffffcc }
.listingblock .pygments, .listingblock .pygments code { background: #f8f8f8; }
.listingblock .pygments .tok-c { color: #408080; font-style: italic } /* Comment */
.listingblock .pygments .tok-err { border: 1px solid #FF0000 } /* Error */
.listingblock .pygments .tok-k { color: #008000; font-weight: bold } /* Keyword */
.listingblock .pygments .tok-o { color: #666666 } /* Operator */
.listingblock .pygments .tok-ch { color: #408080; font-style: italic } /* Comment.Hashbang */
.listingblock .pygments .tok-cm { color: #408080; font-style: italic } /* Comment.Multiline */
.listingblock .pygments .tok-cp { color: #BC7A00 } /* Comment.Preproc */
.listingblock .pygments .tok-cpf { color: #408080; font-style: italic } /* Comment.PreprocFile */
.listingblock .pygments .tok-c1 { color: #408080; font-style: italic } /* Comment.Single */
.listingblock .pygments .tok-cs { color: #408080; font-style: italic } /* Comment.Special */
.listingblock .pygments .tok-gd { color: #A00000 } /* Generic.Deleted */
.listingblock .pygments .tok-ge { font-style: italic } /* Generic.Emph */
.listingblock .pygments .tok-gr { color: #FF0000 } /* Generic.Error */
.listingblock .pygments .tok-gh { color: #000080; font-weight: bold } /* Generic.Heading */
.listingblock .pygments .tok-gi { color: #00A000 } /* Generic.Inserted */
.listingblock .pygments .tok-go { color: #888888 } /* Generic.Output */
.listingblock .pygments .tok-gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.listingblock .pygments .tok-gs { font-weight: bold } /* Generic.Strong */
.listingblock .pygments .tok-gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.listingblock .pygments .tok-gt { color: #0044DD } /* Generic.Traceback */
.listingblock .pygments .tok-kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.listingblock .pygments .tok-kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.listingblock .pygments .tok-kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.listingblock .pygments .tok-kp { color: #008000 } /* Keyword.Pseudo */
.listingblock .pygments .tok-kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.listingblock .pygments .tok-kt { color: #B00040 } /* Keyword.Type */
.listingblock .pygments .tok-m { color: #666666 } /* Literal.Number */
.listingblock .pygments .tok-s { color: #BA2121 } /* Literal.String */
.listingblock .pygments .tok-na { color: #7D9029 } /* Name.Attribute */
.listingblock .pygments .tok-nb { color: #008000 } /* Name.Builtin */
.listingblock .pygments .tok-nc { color: #0000FF; font-weight: bold } /* Name.Class */
.listingblock .pygments .tok-no { color: #880000 } /* Name.Constant */
.listingblock .pygments .tok-nd { color: #AA22FF } /* Name.Decorator */
.listingblock .pygments .tok-ni { color: #999999; font-weight: bold } /* Name.Entity */
.listingblock .pygments .tok-ne { color: #D2413A; font-weight: bold } /* Name.Exception */
.listingblock .pygments .tok-nf { color: #0000FF } /* Name.Function */
.listingblock .pygments .tok-nl { color: #A0A000 } /* Name.Label */
.listingblock .pygments .tok-nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
.listingblock .pygments .tok-nt { color: #008000; font-weight: bold } /* Name.Tag */
.listingblock .pygments .tok-nv { color: #19177C } /* Name.Variable */
.listingblock .pygments .tok-ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
.listingblock .pygments .tok-w { color: #bbbbbb } /* Text.Whitespace */
.listingblock .pygments .tok-mb { color: #666666 } /* Literal.Number.Bin */
.listingblock .pygments .tok-mf { color: #666666 } /* Literal.Number.Float */
.listingblock .pygments .tok-mh { color: #666666 } /* Literal.Number.Hex */
.listingblock .pygments .tok-mi { color: #666666 } /* Literal.Number.Integer */
.listingblock .pygments .tok-mo { color: #666666 } /* Literal.Number.Oct */
.listingblock .pygments .tok-sa { color: #BA2121 } /* Literal.String.Affix */
.listingblock .pygments .tok-sb { color: #BA2121 } /* Literal.String.Backtick */
.listingblock .pygments .tok-sc { color: #BA2121 } /* Literal.String.Char */
.listingblock .pygments .tok-dl { color: #BA2121 } /* Literal.String.Delimiter */
.listingblock .pygments .tok-sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.listingblock .pygments .tok-s2 { color: #BA2121 } /* Literal.String.Double */
.listingblock .pygments .tok-se { color: #BB6622; font-weight: bold } /* Literal.String.Escape */
.listingblock .pygments .tok-sh { color: #BA2121 } /* Literal.String.Heredoc */
.listingblock .pygments .tok-si { color: #BB6688; font-weight: bold } /* Literal.String.Interpol */
.listingblock .pygments .tok-sx { color: #008000 } /* Literal.String.Other */
.listingblock .pygments .tok-sr { color: #BB6688 } /* Literal.String.Regex */
.listingblock .pygments .tok-s1 { color: #BA2121 } /* Literal.String.Single */
.listingblock .pygments .tok-ss { color: #19177C } /* Literal.String.Symbol */
.listingblock .pygments .tok-bp { color: #008000 } /* Name.Builtin.Pseudo */
.listingblock .pygments .tok-fm { color: #0000FF } /* Name.Function.Magic */
.listingblock .pygments .tok-vc { color: #19177C } /* Name.Variable.Class */
.listingblock .pygments .tok-vg { color: #19177C } /* Name.Variable.Global */
.listingblock .pygments .tok-vi { color: #19177C } /* Name.Variable.Instance */
.listingblock .pygments .tok-vm { color: #19177C } /* Name.Variable.Magic */
.listingblock .pygments .tok-il { color: #666666 } /* Literal.Number.Integer.Long */
</style>
</head>
<body class="article">
<div id="header">
<h1>Dangers of linking inline functions</h1>
</div>
<div id="content">
<div class="paragraph">
<p>Andrei Gudkov &lt;<a href="mailto:gudokk@gmail.com">gudokk@gmail.com</a>&gt;</p>
</div>
<div class="paragraph">
<p>Software developers often forget about existence of linker.
However, it is an essential step in producing executables.
Linker along with ELF format provide rather complex platform,
required by a compiler to correctly implement programming
language features.
It is relatively easy to understand the source of an error
when only single object file is linked,
but with many object files, the odds of encountering non-trivial
error increase.
Here I will demonstrate and explain two such errors.
First one relates to inlining or, actually, to a situation when inlining fails
and linker reports that there is an undefined reference to inline function.
C and C++ work differently regarding inlining.
Second problem is a subtle one.
It relates to C++ only and results in that wrong function is used when called.
Program compiles and links fine, but may crash in runtime or, even worse,
work incorrectly.</p>
</div>
<div class="paragraph">
<div class="title">Object file basics</div>
<p>First of all we need to understand object files on a basic level.
Semantically, the heart of an object file is a dictionary of tuples {<code>symbol_name</code>, <code>symbol_type</code>, <code>symbol_body</code>}.
Command line utility <code>nm &lt;path&gt;</code> can be used to dump what&#8217;s inside an object file.
For example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>0000000000000000 T _Z10total_costdi
                 U _Z12adjust_priceP4Item
0000000000000037 T _Z9min_priceRKSt6vectorI4ItemSaIS0_EE
000000000000001c t _ZL13adjust_amountP4Item
0000000000000008 r _ZL2PI
0000000000000000 W _ZNKSt6vectorI4ItemSaIS0_EE4sizeEv
0000000000000000 W _ZNKSt6vectorI4ItemSaIS0_EEixEm
0000000000000000 r _ZStL19piecewise_construct</pre>
</div>
</div>
<div class="paragraph">
<p>Every symbol is a function or a variable.</p>
</div>
<div class="paragraph">
<p>Symbol name is chosen by compiler.
Different compilers and languages have different rules for naming.
In C, where overloading is not allowed, names are exactly the same as given by a programmer.
In C++ we have overloading, resulting in that there may be many functions with the same name
but with different number and types of arguments.
To uniquely distinguish between them, naming scheme is more complex in C++.
Symbol names for C++ functions also include namespace name and argument types.
For example, the function <code>double total_cost(double price, int count);</code>
has the very same symbol name <code>total_cost</code> if compiled by gcc,
but much more complex name <code>_Z10total_costdi</code> if compiled by g++.</p>
</div>
<div class="paragraph">
<p>Symbol body contains either the machine code (for functions) or binary value (for variables).</p>
</div>
<div class="paragraph">
<p>The most mysterious part is symbol type.
It should not be confused with programming language types, such as integers and floats.
Symbol type instructs linker on how to deal with this symbol during linking.
There are many symbol types (see manual page <code>nm(1)</code> for all of them),
but we will be interested only in the following few of them:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>T</strong>&#8201;&#8212;&#8201;Global symbol.
It can be referenced from all object files, not only the current one.
If linker encounters multiple <strong>T</strong> symbols with the same name across object files,
it reports an error.</p>
</li>
<li>
<p><strong>t</strong>&#8201;&#8212;&#8201;Local symbol.
It can be referenced only from the current object file.
Multiple <strong>t</strong> symbols with the same name are fine, provided they are located
inside different object files.</p>
</li>
<li>
<p><strong>W</strong>&#8201;&#8212;&#8201;Weak global symbol.
It can be referenced globally, similar to <strong>T</strong>.
The difference is that if there are multiple weak symbols with the same name across object files,
linker retains only single copy, and this copy is used by all functions from all object files.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>General rule is that uppercase characters stand for global symbol types,
while lowercase characters denote local symbol types.
As such, fourth variant, <strong>w</strong>, also exists but it is not very useful.
Neither C nor C++ have a need for deduplicating symbols inside single object file
because ODR rule prohibits multiple definitions of the same symbol
inside single translation unit.
If a programmer mistakenly created multiple definitions of the same variable or function
in single translation unit,
such error would be detected earlier, during compilation stage.</p>
</div>
<div class="paragraph">
<p>During linking, a number of error messages can be reported.
The most common are:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Undefined reference to <code>&lt;symbol_name&gt;</code>.
This means that there was declaration of a symbol, it was actually referenced
from somewhere, but definition was not found in any of the object files
passed to the linker.</p>
</li>
<li>
<p>Multiple definition of <code>&lt;symbol_name&gt;</code>.
This means that there are multiple entries of some symbol name across
object files and they cannot be deduplicated because of their types.
For example, such error would be reported if these symbols had types <strong>T</strong>, <strong>T</strong>.
However, <strong>W</strong>, <strong>W</strong>, <strong>T</strong>, <strong>W</strong> would be fine; <strong>W</strong>, <strong>W</strong>, <strong>W</strong> would also be fine.
Linker retains only single body in the last two cases.</p>
</li>
</ol>
</div>
<div class="paragraph">
<div class="title">When inlining fails [C]</div>
<p>Now let&#8217;s focus on the scope of the article: the errors.
Imagine the following piece of C code:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c"><table class="pyhltable"><tr><td class="linenos"><div class="linenodiv"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33</div></td><td class="code"><span></span><span class="tok-cm">/* util.h */</span>
<span class="tok-cp">#ifndef __UTIL_H__</span>
<span class="tok-cp">#define __UTIL_H__</span>
<span class="tok-kr">inline</span> <span class="tok-kt">double</span> <span class="tok-nf">circle_area</span><span class="tok-p">(</span><span class="tok-kt">double</span> <span class="tok-n">r</span><span class="tok-p">)</span> <span class="tok-p">{</span>
  <span class="tok-k">static</span> <span class="tok-k">const</span> <span class="tok-kt">double</span> <span class="tok-n">pi</span> <span class="tok-o">=</span> <span class="tok-mf">3.14159</span><span class="tok-p">;</span>
  <span class="tok-k">return</span> <span class="tok-mf">2.0</span> <span class="tok-o">*</span> <span class="tok-n">pi</span> <span class="tok-o">*</span> <span class="tok-n">r</span><span class="tok-p">;</span>
<span class="tok-p">}</span>
<span class="tok-cp">#endif </span><span class="tok-cm">/* __UTIL_H__ */</span><span class="tok-cp"></span>

<span class="tok-cm">/* big.c */</span>
<span class="tok-cp">#include</span> <span class="tok-cpf">&quot;big.h&quot;</span><span class="tok-cp"></span>
<span class="tok-cp">#include</span> <span class="tok-cpf">&quot;util.h&quot;</span><span class="tok-cp"></span>
<span class="tok-cp">#include</span> <span class="tok-cpf">&lt;stdio.h&gt;</span><span class="tok-cp"></span>
<span class="tok-kt">void</span> <span class="tok-nf">print_big_pizza_area</span><span class="tok-p">()</span> <span class="tok-p">{</span>
  <span class="tok-n">printf</span><span class="tok-p">(</span><span class="tok-s">&quot;%f</span><span class="tok-se">\n</span><span class="tok-s">&quot;</span><span class="tok-p">,</span> <span class="tok-n">circle_area</span><span class="tok-p">(</span><span class="tok-mi">50</span><span class="tok-p">));</span>
<span class="tok-p">}</span>

<span class="tok-cm">/* small.c */</span>
<span class="tok-cp">#include</span> <span class="tok-cpf">&quot;small.h&quot;</span><span class="tok-cp"></span>
<span class="tok-cp">#include</span> <span class="tok-cpf">&quot;util.h&quot;</span><span class="tok-cp"></span>
<span class="tok-cp">#include</span> <span class="tok-cpf">&lt;stdio.h&gt;</span><span class="tok-cp"></span>
<span class="tok-kt">void</span> <span class="tok-nf">print_small_pizza_area</span><span class="tok-p">()</span> <span class="tok-p">{</span>
  <span class="tok-n">printf</span><span class="tok-p">(</span><span class="tok-s">&quot;%f</span><span class="tok-se">\n</span><span class="tok-s">&quot;</span><span class="tok-p">,</span> <span class="tok-n">circle_area</span><span class="tok-p">(</span><span class="tok-mi">30</span><span class="tok-p">));</span>
<span class="tok-p">}</span>

<span class="tok-cm">/* main.c */</span>
<span class="tok-kt">void</span> <span class="tok-nf">print_big_pizza_area</span><span class="tok-p">();</span>
<span class="tok-kt">void</span> <span class="tok-nf">print_small_pizza_area</span><span class="tok-p">();</span>
<span class="tok-kt">int</span> <span class="tok-nf">main</span><span class="tok-p">(</span><span class="tok-kt">int</span> <span class="tok-n">argc</span><span class="tok-p">,</span> <span class="tok-kt">char</span><span class="tok-o">*</span> <span class="tok-n">argv</span><span class="tok-p">[])</span> <span class="tok-p">{</span>
  <span class="tok-n">print_small_pizza_area</span><span class="tok-p">();</span>
  <span class="tok-n">print_big_pizza_area</span><span class="tok-p">();</span>
  <span class="tok-k">return</span> <span class="tok-mi">0</span><span class="tok-p">;</span>
<span class="tok-p">}</span>
</td></tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>As you can see, there are two <code>print_*</code> functions, and each of them calls inline function <code>circle_area()</code>.
The program above compiles and executes perfectly fine&#8230;&#8203; until
compiled with optimizations disabled (<code>-O0</code>).
When compiled with <code>-O3</code>, compiler optimizations are in effect,
and almost all functions declared as inline are actually inlined.
Thus, the body of the function <code>circle_area()</code> will be expanded in all functions where
it is referenced, namely <code>print_small_pizza_area()</code> and <code>print_big_pizza_area()</code>.
Compiler won&#8217;t generate any symbols for <code>circle_area()</code>.
There is just no need for that.
Executable file will contain symbols for <code>main()</code>, <code>print_small_pizza_area()</code> and <code>print_big_pizza_area()</code>,
but not for <code>circle_area()</code>.</p>
</div>
<div class="paragraph">
<p>No-optimization build is entirely different.
Compilers usually do not perform inlining in this mode.
Instead, they treat inline function definitions as <em>declarations</em> only.
In rare circumstances this happens even with <code>-O3</code>.
For example, this happens when function recursively calls itself.
Or when a function is too big but is referenced multiple times:
compiler concludes that it is cheaper to call separate function instead of inlining it
in all places.
Inline keyword is a mere hint.
If you need guaranteed inlining, you have to use compiler-dependent extensions,
such as <code>&#95;&#95;attribute&#95;&#95;((alway_inline))</code> in gcc.</p>
</div>
<div class="paragraph">
<p>When compiler decides not to inline a function, it generates a standard call
and ignores the body of the inline function entirely.
Now, when linker tries to produce executable file, it will see that
function <code>circle_area()</code> is called, but it is itself not present in any of
the object files.
Linker reports "undefined reference" error.</p>
</div>
<div class="paragraph">
<p>There are two possible solutions.
First one is to use <code>inline</code> together with <code>static</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c"><span></span><span class="tok-kr">inline</span> <span class="tok-k">static</span> <span class="tok-kt">double</span> <span class="tok-nf">circle_size</span><span class="tok-p">(</span><span class="tok-kt">double</span> <span class="tok-n">r</span><span class="tok-p">);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Now if compiler decides not to inline a function, it will instantiate
function in every object file where it is referenced from.
It will assign symbol type <strong>t</strong>&#8201;&#8212;&#8201;local symbol&#8201;&#8212;&#8201;to instantiated functions.
Linker, in turn, will include both functions into executable and link
functions <code>print_big_pizza_area()</code> and <code>print_small_pizza_area()</code> with respective <code>circle_area()</code> copies,
even though these copies are identical.</p>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="static.svg" alt="static" width="60%">
</div>
</div>
<div class="paragraph">
<p>Second possible solution is to explicitly instantiate inline function
in one (and only one) of the translation units by using <code>extern</code> keyword.
For example, it would be natural to include source file <code>util.c</code>
into above program and instantiate <code>pizza_area()</code> there.
Of course, we want it to be globally visible, so no <code>static</code> is used.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="c"><span></span><span class="tok-cp">#include</span> <span class="tok-cpf">&quot;util.h&quot;</span><span class="tok-cp"></span>
<span class="tok-k">extern</span> <span class="tok-kr">inline</span> <span class="tok-kt">double</span> <span class="tok-nf">circle_size</span><span class="tok-p">(</span><span class="tok-kt">double</span> <span class="tok-n">r</span><span class="tok-p">);</span></code></pre>
</div>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="extern.svg" alt="extern" width="60%">
</div>
</div>
<div class="paragraph">
<p>Both approaches have drawbacks.
Declaring inline functions as <code>static</code> leads to code size bloat.
However, this is typically not an issue because failure to inline functions
rarely happens in <code>-O3</code> mode used for production builds.
On the other hand, explicit instantiation of inline functions with <code>extern</code> requires
programmers to keep declarations in sync in multiple places.
Extern declarations must be updated every time new inline function is added
or the signature of existing inline function is changed.</p>
</div>
<div class="paragraph">
<div class="title">When inlining fails [C++]</div>
<p>C++ is different.
There is no need to add <code>static</code> to inline functions in C++.
When C++ compiler decides not to inline function, it automatically
instantiates it with weak symbol type, <strong>W</strong>.
Every object file where inline function is instantiated, gets such symbol.
When linker assembles final executable, it retains only single version of every weak symbol,
and this version is used whenever the function is referenced.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ nm big.o
0000000000000000 W _Z11circle_aread
0000000000000000 T _Z20print_big_pizza_areav

$ nm small.o
0000000000000000 W _Z11circle_aread
0000000000000000 T _Z22print_small_pizza_areav

$ nm main.o
0000000000000000 T main

$ nm main
00000000000006f0 T _Z20print_big_pizza_areav
000000000000073d T _Z22print_small_pizza_areav
00000000000006d0 T main
0000000000000721 W _Z11circle_aread</pre>
</div>
</div>
<div class="paragraph">
<p>Why does C++ use weak symbols?
Mechanism of weak symbols is required not because of inlining, but because of templates.
Templates are very similar to inline functions in that they are both forms of automatic code generation.
Template functions and classes may be instantiated multiple times
and with different sets of arguments.
The author of the template may not know all the combinations
and is not able to explicitly instantiate all combinations in source files.
Definitions of functions and methods go directly to header files instead.
When compiler sees that some template function or class is used with specific
set of arguments, it automatically instantiates it in object file where it is used.
For example, if 20 translation units use <code>std::vector&lt;int&gt;</code>, then all
20 object files will get symbols for <code>std::vector&lt;int&gt;::push_back()</code>, <code>std::vector&lt;int&gt;::size()</code>, etc.
(That&#8217;s the reason why C++ projects take so much time to compile.)</p>
</div>
<div class="paragraph">
<p>C++ compiler avoids "multiple definition of &#8230;&#8203;" linking error by marking
instantiated template functions and template class members with symbol type <strong>W</strong>.
The same is true for inline functions, when they are not actually
inlined but instantiated.
Linker retains only single version of each weak symbol and uses it everywhere
when it is referenced.
Thus, whether optimization mode is <code>-O0</code> or <code>-O3</code>, linker succeeds without any errors.
No <code>static</code> or <code>extern</code> is required.</p>
</div>
<div class="paragraph">
<div class="title">Wrong function body is used</div>
<p>At this point it should appear that C++ approach is more robust compared to C.
Alas, weak symbols may create more subtle errors.
It is relatively easy to create identically named but differently implemented inline functions,
template functions or template classes in different translation units.
All of them will be instantiated with <strong>W</strong> symbol type,
and linker will erroneously retain only single version, which will be used everywhere.
It won&#8217;t check that their bodies are different.
Consider this example that seems harmless at first glance:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cpp"><table class="pyhltable"><tr><td class="linenos"><div class="linenodiv"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23</div></td><td class="code"><span></span><span class="tok-c1">// source1.cc</span>
<span class="tok-cp">#include</span> <span class="tok-cpf">&lt;iostream&gt;</span><span class="tok-cp"></span>
<span class="tok-kr">inline</span> <span class="tok-kt">double</span> <span class="tok-nf">constant</span><span class="tok-p">()</span> <span class="tok-p">{</span> <span class="tok-k">return</span> <span class="tok-mf">3.14159</span><span class="tok-p">;</span> <span class="tok-p">}</span>
<span class="tok-kt">void</span> <span class="tok-nf">print_pi</span><span class="tok-p">()</span> <span class="tok-p">{</span>
  <span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">cout</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-n">constant</span><span class="tok-p">()</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">endl</span><span class="tok-p">;</span>
<span class="tok-p">}</span>

<span class="tok-c1">// source2.cc</span>
<span class="tok-cp">#include</span> <span class="tok-cpf">&lt;iostream&gt;</span><span class="tok-cp"></span>
<span class="tok-kr">inline</span> <span class="tok-kt">double</span> <span class="tok-nf">constant</span><span class="tok-p">()</span> <span class="tok-p">{</span> <span class="tok-k">return</span> <span class="tok-mf">2.71828</span><span class="tok-p">;</span> <span class="tok-p">}</span>
<span class="tok-kt">void</span> <span class="tok-nf">print_e</span><span class="tok-p">()</span> <span class="tok-p">{</span>
  <span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">cout</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-n">constant</span><span class="tok-p">()</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-n">std</span><span class="tok-o">::</span><span class="tok-n">endl</span><span class="tok-p">;</span>
<span class="tok-p">}</span>

<span class="tok-c1">// main.cc</span>
<span class="tok-kt">void</span> <span class="tok-nf">print_e</span><span class="tok-p">();</span>
<span class="tok-kt">void</span> <span class="tok-nf">print_pi</span><span class="tok-p">();</span>

<span class="tok-kt">int</span> <span class="tok-nf">main</span><span class="tok-p">()</span> <span class="tok-p">{</span>
  <span class="tok-n">print_e</span><span class="tok-p">();</span>
  <span class="tok-n">print_pi</span><span class="tok-p">();</span>
  <span class="tok-k">return</span> <span class="tok-mi">0</span><span class="tok-p">;</span>
<span class="tok-p">}</span>
</td></tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>After compiling with <code>-O0</code>, both <code>source1.o</code> and <code>source2.o</code> object files will contain
symbol for function <code>constant()</code> with type <strong>W</strong>, but with different implementations.
Linker will retain only one of these versions and generate a call to this
version from both <code>print_e()</code> and <code>print_pi()</code> functions.
Which function will be eliminated and which one will be preserved is undefined,
but at least if using GNU linker it appears that the order of object files on the command line matters.
In both cases the program works incorrectly:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ g++ source1.cc -c -O0
$ g++ source2.cc -c -O0
$ g++ main.cc -c -O0
$
$ g++ main.o source1.o source2.o -o main
$ ./main
3.14159
3.14159
$
$ g++ main.o source2.o source1.o -o main
$ ./main
2.71828
2.71828</pre>
</div>
</div>
<div class="paragraph">
<p>It is not very hard to stumble upon such error in large projects.
Multiple programmers can easily create differently implemented
inline functions with the same common name and argument types,
such as <code>inline int64_t current_time()</code> or <code>inline void escape(std::string* s)</code>.
Unit tests for every single component will work fine, but when all components
are linked together into single executable, program will demonstrate unexpected behavior.
And good luck with debugging it!</p>
</div>
<div class="paragraph">
<p>The correct solution is to never litter global namespace.
There are multiple ways to achieve it.
One way is to use C approach and declare functions as <code>static</code>,
but C++ provides more elegant way of isolation: named and anonymous namespaces.
Using any of these three approaches fixes the error.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cpp"><table class="pyhltable"><tr><td class="linenos"><div class="linenodiv"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12</div></td><td class="code"><span></span><span class="tok-c1">// static</span>
<span class="tok-kr">inline</span> <span class="tok-k">static</span> <span class="tok-kt">double</span> <span class="tok-nf">constant</span><span class="tok-p">()</span> <span class="tok-p">{</span> <span class="tok-k">return</span> <span class="tok-mf">2.71828</span><span class="tok-p">;</span> <span class="tok-p">}</span>

<span class="tok-c1">// named namespace</span>
<span class="tok-k">namespace</span> <span class="tok-n">source1_private_ns</span> <span class="tok-p">{</span>
  <span class="tok-kr">inline</span> <span class="tok-kt">double</span> <span class="tok-n">constant</span><span class="tok-p">()</span> <span class="tok-p">{</span> <span class="tok-k">return</span> <span class="tok-mf">2.71828</span><span class="tok-p">;</span> <span class="tok-p">}</span>
<span class="tok-p">}</span>

<span class="tok-c1">// anonymous namespace</span>
<span class="tok-k">namespace</span> <span class="tok-p">{</span>
  <span class="tok-kr">inline</span> <span class="tok-kt">double</span> <span class="tok-n">constant</span><span class="tok-p">()</span> <span class="tok-p">{</span> <span class="tok-k">return</span> <span class="tok-mf">2.71828</span><span class="tok-p">;</span> <span class="tok-p">}</span>
<span class="tok-p">}</span>
</td></tr></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>Using <code>static</code> will produce local (<strong>t</strong>) symbols instead of weak symbols (<strong>W</strong>).
Using named namespace will incorporate namespace into symbol name, so that
identically named functions will get differently named symbols.
The same thing will happen if anonymous namespace is used,
with added benefit that you do not need to choose a name for namespace yourself.</p>
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2018-12-24 16:26:23 UTC
</div>
</div>
</body>
</html>